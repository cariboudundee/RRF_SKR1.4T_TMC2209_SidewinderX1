(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Visualizer"],{"./node_modules/cache-loader/dist/cjs.js?!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=script&lang=js&":function(e,t,n){"use strict";n.r(t);n("./node_modules/regenerator-runtime/runtime.js");var o=n("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),c=n("./node_modules/@babel/runtime/helpers/esm/objectSpread2.js"),h=n("./node_modules/vuex/dist/vuex.esm.js"),d=n("./node_modules/gcode-preview/dist/gcode-preview.js"),p=n("./node_modules/three/build/three.module.js");t["default"]={computed:Object(c["default"])({},Object(h["mapState"])("machine/model",{jobFile:function jobFile(e){return e.job.file.fileName},filePosition:function filePosition(e){return e.job.filePosition},fileSize:function fileSize(e){return e.job.file.size}})),data:function data(){return{active:!0,fileName:null,fileContent:null,lastFilePosition:0,preview:null}},methods:Object(c["default"])(Object(c["default"])({},Object(h["mapActions"])("machine",["download"])),{},{loadCurrentFile:function loadCurrentFile(){var e=this;return Object(o["default"])(regeneratorRuntime.mark((function _callee(){return regeneratorRuntime.wrap((function _callee$(t){while(1)switch(t.prev=t.next){case 0:if(!e.jobFile){t.next=3;break}return t.next=3,e.loadFile(e.jobFile);case 3:case"end":return t.stop()}}),_callee)})))()},loadFile:function loadFile(e){var t=this;return Object(o["default"])(regeneratorRuntime.mark((function _callee2(){return regeneratorRuntime.wrap((function _callee2$(n){while(1)switch(n.prev=n.next){case 0:return t.fileName=e,n.next=3,t.download({filename:e,type:"text"});case 3:t.fileContent=n.sent,t.preview.clear(),e===t.jobFile?t.filePosition?(t.preview.processGCode(t.fileContent.substring(0,t.filePosition)),t.lastFilePosition=t.filePosition):t.lastFilePosition=0:(t.preview.processGCode(t.fileContent),t.lastFilePosition=0);case 6:case"end":return n.stop()}}),_callee2)})))()},resize:function resize(){this.preview&&this.preview.resize()}}),mounted:function mounted(){this.preview=new d["WebGLPreview"]({canvas:this.$refs.preview,limit:1/0,topLayerColor:new p["Color"]("lime").getHex(),lastSegmentColor:new p["Color"]("red").getHex()}),this.loadCurrentFile()},activated:function activated(){this.active&&this.fileContent&&(this.preview.processGCode(this.fileContent.substring(this.lastFilePosition,this.filePosition)),this.lastFilePosition=this.filePosition),this.active=!0},deactivated:function deactivated(){this.active=!1},watch:{filePosition:function filePosition(e){this.active&&this.jobFile===this.fileName&&e>0&&(this.fileContent&&this.preview.processGCode(this.fileContent.substring(this.lastFilePosition,e)),this.lastFilePosition=e)},jobFile:function jobFile(){this.loadCurrentFile()}}}},'./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3e016849-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=template&id=502b953a&scoped=true&':function(e,t,n){"use strict";n.r(t),n.d(t,"render",(function(){return render})),n.d(t,"staticRenderFns",(function(){return o}));var render=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{directives:[{name:"resize",rawName:"v-resize",value:e.resize,expression:"resize"}],staticClass:"mt-3"},[n("canvas",{ref:"preview"})])},o=[]},"./node_modules/gcode-preview/dist/gcode-preview.js":function(e,t,n){!function(e,o){o(t,n("./node_modules/gcode-preview/node_modules/three/build/three.module.js"),n("./node_modules/three-orbitcontrols/OrbitControls.js"))}(0,(function(e,t,n){"use strict";class i extends class{constructor(e,t){this.gcode=e,this.comment=t}}{constructor(e,t,n){super(e,n),this.params=t}}class r{constructor(e,t){this.layer=e,this.commands=t}}class s{constructor(){this.layers=[],this.curZ=0,this.maxZ=0}parseCommand(e,t=!0){const n=e.trim().split(";"),o=n[0],c=t&&n[1]||null,h=o.split(/ +/g),d=h[0].toLowerCase();switch(d){case"g0":case"g1":const e=this.parseMove(h.slice(1));return new i(d,e,c);default:return null}}parseMove(e){return e.reduce((e,t)=>{const n=t.charAt(0).toLowerCase();return"x"!=n&&"y"!=n&&"z"!=n&&"e"!=n||(e[n]=parseFloat(t.slice(1))),e},{})}groupIntoLayers(e){for(const t of e.filter(e=>e instanceof i)){const e=t.params;e.z&&(this.curZ=e.z),e.e>0&&(null!=e.x||null!=e.y)&&this.curZ>this.maxZ?(this.maxZ=this.curZ,this.currentLayer=new r(this.layers.length,[t]),this.layers.push(this.currentLayer)):this.currentLayer&&this.currentLayer.commands.push(t)}return this.layers}parseGcode(e){const t=Array.isArray(e)?e:e.split("\n").filter(e=>e.length>0),n=this.lines2commands(t);return this.groupIntoLayers(n),{layers:this.layers}}lines2commands(e){return e.filter(e=>e.length>0).map(e=>this.parseCommand(e)).filter(e=>null!==e)}}t.UniformsLib.line={linewidth:{value:1},resolution:{value:new t.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},t.ShaderLib.line={uniforms:t.UniformsUtils.merge([t.UniformsLib.common,t.UniformsLib.fog,t.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};var a=function(e){t.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:t.UniformsUtils.clone(t.ShaderLib.line.uniforms),vertexShader:t.ShaderLib.line.vertexShader,fragmentShader:t.ShaderLib.line.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(e){this.uniforms.diffuse.value=e}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(e){this.uniforms.linewidth.value=e}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(e){this.uniforms.dashScale.value=e}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(e){this.uniforms.dashSize.value=e}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(e){this.uniforms.gapSize.value=e}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(e){this.uniforms.resolution.value.copy(e)}}}),this.setValues(e)};(a.prototype=Object.create(t.ShaderMaterial.prototype)).constructor=a,a.prototype.isLineMaterial=!0;var o,c,l=function(){t.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry",this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new t.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))};l.prototype=Object.assign(Object.create(t.InstancedBufferGeometry.prototype),{constructor:l,isLineSegmentsGeometry:!0,applyMatrix4:function(e){var t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==t&&(t.applyMatrix4(e),n.applyMatrix4(e),t.data.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(e){var n;e instanceof Float32Array?n=e:Array.isArray(e)&&(n=new Float32Array(e));var o=new t.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceStart",new t.InterleavedBufferAttribute(o,3,0)),this.setAttribute("instanceEnd",new t.InterleavedBufferAttribute(o,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(e){var n;e instanceof Float32Array?n=e:Array.isArray(e)&&(n=new Float32Array(e));var o=new t.InstancedInterleavedBuffer(n,6,1);return this.setAttribute("instanceColorStart",new t.InterleavedBufferAttribute(o,3,0)),this.setAttribute("instanceColorEnd",new t.InterleavedBufferAttribute(o,3,3)),this},fromWireframeGeometry:function(e){return this.setPositions(e.attributes.position.array),this},fromEdgesGeometry:function(e){return this.setPositions(e.attributes.position.array),this},fromMesh:function(e){return this.fromWireframeGeometry(new t.WireframeGeometry(e.geometry)),this},fromLineSegements:function(e){var t=e.geometry;return t.isGeometry?this.setPositions(t.vertices):t.isBufferGeometry&&this.setPositions(t.position.array),this},computeBoundingBox:(c=new t.Box3,function(){null===this.boundingBox&&(this.boundingBox=new t.Box3);var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;void 0!==e&&void 0!==n&&(this.boundingBox.setFromBufferAttribute(e),c.setFromBufferAttribute(n),this.boundingBox.union(c))}),computeBoundingSphere:(o=new t.Vector3,function(){null===this.boundingSphere&&(this.boundingSphere=new t.Sphere),null===this.boundingBox&&this.computeBoundingBox();var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;if(void 0!==e&&void 0!==n){var c=this.boundingSphere.center;this.boundingBox.getCenter(c);for(var h=0,d=0,p=e.count;d<p;d++)o.fromBufferAttribute(e,d),h=Math.max(h,c.distanceToSquared(o)),o.fromBufferAttribute(n,d),h=Math.max(h,c.distanceToSquared(o));this.boundingSphere.radius=Math.sqrt(h),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},applyMatrix:function(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}});var u=function(){l.call(this),this.type="LineGeometry"};u.prototype=Object.assign(Object.create(l.prototype),{constructor:u,isLineGeometry:!0,setPositions:function(e){for(var t=e.length-3,n=new Float32Array(2*t),o=0;o<t;o+=3)n[2*o]=e[o],n[2*o+1]=e[o+1],n[2*o+2]=e[o+2],n[2*o+3]=e[o+3],n[2*o+4]=e[o+4],n[2*o+5]=e[o+5];return l.prototype.setPositions.call(this,n),this},setColors:function(e){for(var t=e.length-3,n=new Float32Array(2*t),o=0;o<t;o+=3)n[2*o]=e[o],n[2*o+1]=e[o+1],n[2*o+2]=e[o+2],n[2*o+3]=e[o+3],n[2*o+4]=e[o+4],n[2*o+5]=e[o+5];return l.prototype.setColors.call(this,n),this},fromLine:function(e){var t=e.geometry;return t.isGeometry?this.setPositions(t.vertices):t.isBufferGeometry&&this.setPositions(t.position.array),this},copy:function(){return this}});var h,d,f=function(e,n){t.Mesh.call(this),this.type="LineSegments2",this.geometry=void 0!==e?e:new l,this.material=void 0!==n?n:new a({color:16777215*Math.random()})};f.prototype=Object.assign(Object.create(t.Mesh.prototype),{constructor:f,isLineSegments2:!0,computeLineDistances:(h=new t.Vector3,d=new t.Vector3,function(){for(var e=this.geometry,n=e.attributes.instanceStart,o=e.attributes.instanceEnd,c=new Float32Array(2*n.data.count),p=0,m=0,g=n.data.count;p<g;p++,m+=2)h.fromBufferAttribute(n,p),d.fromBufferAttribute(o,p),c[m]=0===m?0:c[m-1],c[m+1]=c[m]+h.distanceTo(d);var y=new t.InstancedInterleavedBuffer(c,2,1);return e.setAttribute("instanceDistanceStart",new t.InterleavedBufferAttribute(y,1,0)),e.setAttribute("instanceDistanceEnd",new t.InterleavedBufferAttribute(y,1,1)),this}),raycast:function(){var e=new t.Vector4,n=new t.Vector4,o=new t.Vector4,c=new t.Vector3,h=new t.Matrix4,d=new t.Line3,p=new t.Vector3;return function(m,g){null===m.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');var y=m.ray,x=m.camera,b=x.projectionMatrix,M=this.geometry,_=this.material,w=_.resolution,S=_.linewidth,T=M.attributes.instanceStart,E=M.attributes.instanceEnd;y.at(1,o),o.w=1,o.applyMatrix4(x.matrixWorldInverse),o.applyMatrix4(b),o.multiplyScalar(1/o.w),o.x*=w.x/2,o.y*=w.y/2,o.z=0,c.copy(o);var L=this.matrixWorld;h.multiplyMatrices(x.matrixWorldInverse,L);for(var A=0,C=T.count;A<C;A++){e.fromBufferAttribute(T,A),n.fromBufferAttribute(E,A),e.w=1,n.w=1,e.applyMatrix4(h),n.applyMatrix4(h),e.applyMatrix4(b),n.applyMatrix4(b),e.multiplyScalar(1/e.w),n.multiplyScalar(1/n.w);var P=e.z<-1&&n.z<-1,R=e.z>1&&n.z>1;if(!P&&!R){e.x*=w.x/2,e.y*=w.y/2,n.x*=w.x/2,n.y*=w.y/2,d.start.copy(e),d.start.z=0,d.end.copy(n),d.end.z=0;var B=d.closestPointToPointParameter(c,!0);d.at(B,p);var D=t.MathUtils.lerp(e.z,n.z,B),G=D>=-1&&D<=1,I=c.distanceTo(p)<.5*S;if(G&&I){d.start.fromBufferAttribute(T,A),d.end.fromBufferAttribute(E,A),d.start.applyMatrix4(L),d.end.applyMatrix4(L);var O=new t.Vector3,V=new t.Vector3;y.distanceSqToSegment(d.start,d.end,V,O),g.push({point:V,pointOnLine:O,distance:y.origin.distanceTo(V),object:this,face:null,faceIndex:A,uv:null,uv2:null})}}}}}()}),e.WebGLPreview=class{constructor(e){if(this.parser=new s,this.backgroundColor=14737632,this.travelColor=10027008,this.extrusionColor=65280,this.renderExtrusion=!0,this.renderTravel=!1,this.singleLayerMode=!1,this.scene=new t.Scene,this.scene.background=new t.Color(this.backgroundColor),this.canvas=e.canvas,this.targetId=e.targetId,this.endLayer=e.endLayer,this.startLayer=e.startLayer,this.topLayerColor=e.topLayerColor,this.lastSegmentColor=e.lastSegmentColor,this.lineWidth=e.lineWidth,console.debug("opts",e),!this.canvas&&!this.targetId)throw Error("Set either opts.canvas or opts.targetId");if(this.canvas)this.renderer=new t.WebGLRenderer({canvas:this.canvas,preserveDrawingBuffer:!0});else{const e=document.getElementById(this.targetId);if(!e)throw new Error("Unable to find element "+this.targetId);this.renderer=new t.WebGLRenderer({preserveDrawingBuffer:!0}),this.canvas=this.renderer.domElement,e.appendChild(this.canvas)}this.camera=new t.PerspectiveCamera(75,this.canvas.offsetWidth/this.canvas.offsetHeight,10,1e3),this.camera.position.set(0,0,50),this.resize(),new n(this.camera,this.renderer.domElement),this.animate()}get layers(){return this.parser.layers}get maxLayerIndex(){var e;return(null!==(e=this.endLayer)&&void 0!==e?e:this.layers.length)-1}get minLayerIndex(){var e;return this.singleLayerMode?this.maxLayerIndex:(null!==(e=this.startLayer)&&void 0!==e?e:0)-1}animate(){requestAnimationFrame(()=>this.animate()),this.renderer.render(this.scene,this.camera)}processGCode(e){this.parser.parseGcode(e),this.render()}render(){for(var e,n;this.scene.children.length>0;)this.scene.remove(this.scene.children[0]);this.group=new t.Group,this.group.name="gcode";const o={x:0,y:0,z:0,e:0};for(let c=0;c<this.layers.length&&!(c>this.maxLayerIndex);c++){const h={extrusion:[],travel:[],z:o.z},d=this.layers[c];for(const e of d.commands)if("g0"==e.gcode||"g1"==e.gcode){const t=e,n={x:void 0!==t.params.x?t.params.x:o.x,y:void 0!==t.params.y?t.params.y:o.y,z:void 0!==t.params.z?t.params.z:o.z,e:void 0!==t.params.e?t.params.e:o.e};if(c>=this.minLayerIndex){const e=t.params.e>0;(e&&this.renderExtrusion||!e&&this.renderTravel)&&this.addLineSegment(h,o,n,e)}t.params.x&&(o.x=t.params.x),t.params.y&&(o.y=t.params.y),t.params.z&&(o.z=t.params.z),t.params.e&&(o.e=t.params.e)}if(this.renderExtrusion){const o=Math.round(80*c/this.layers.length),d=new t.Color(`hsl(0, 0%, ${o}%)`).getHex();if(c==this.layers.length-1){const t=null!==(e=this.topLayerColor)&&void 0!==e?e:d,o=null!==(n=this.lastSegmentColor)&&void 0!==n?n:t,c=h.extrusion.splice(-3);this.addLine(h.extrusion,t);const p=h.extrusion.splice(-3);this.addLine([...p,...c],o)}else this.addLine(h.extrusion,d)}this.renderTravel&&this.addLine(h.travel,this.travelColor)}this.group.quaternion.setFromEuler(new t.Euler(-Math.PI/2,0,0)),this.group.position.set(-100,-20,100),this.scene.add(this.group),this.renderer.render(this.scene,this.camera)}clear(){this.startLayer=1,this.endLayer=1/0,this.singleLayerMode=!1,this.parser=new s}resize(){const[e,t]=[this.canvas.offsetWidth,this.canvas.offsetHeight];this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(e,t,!1)}addLineSegment(e,t,n,o){(o?e.extrusion:e.travel).push(t.x,t.y,t.z,n.x,n.y,n.z)}addLine(e,n){if("number"==typeof this.lineWidth&&this.lineWidth>0)return void this.addThickLine(e,n);const o=new t.BufferGeometry;o.setAttribute("position",new t.Float32BufferAttribute(e,3));const c=new t.LineBasicMaterial({color:n}),h=new t.LineSegments(o,c);this.group.add(h)}addThickLine(e,t){if(!e.length)return;const n=new u,o=new a({color:t,linewidth:this.lineWidth/(1e3*window.devicePixelRatio)});n.setPositions(e);const c=new f(n,o);this.group.add(c)}},Object.defineProperty(e,"__esModule",{value:!0})}))},"./node_modules/gcode-preview/node_modules/three/build/three.module.js":function(e,t,n){"use strict";n.r(t),n.d(t,"ACESFilmicToneMapping",(function(){return de})),n.d(t,"AddEquation",(function(){return I})),n.d(t,"AddOperation",(function(){return se})),n.d(t,"AdditiveAnimationBlendMode",(function(){return nn})),n.d(t,"AdditiveBlending",(function(){return R})),n.d(t,"AlphaFormat",(function(){return qe})),n.d(t,"AlwaysDepth",(function(){return K})),n.d(t,"AlwaysStencilFunc",(function(){return Gn})),n.d(t,"AmbientLight",(function(){return AmbientLight})),n.d(t,"AmbientLightProbe",(function(){return AmbientLightProbe})),n.d(t,"AnimationClip",(function(){return AnimationClip})),n.d(t,"AnimationLoader",(function(){return AnimationLoader})),n.d(t,"AnimationMixer",(function(){return AnimationMixer})),n.d(t,"AnimationObjectGroup",(function(){return AnimationObjectGroup})),n.d(t,"AnimationUtils",(function(){return uc})),n.d(t,"ArcCurve",(function(){return ArcCurve})),n.d(t,"ArrayCamera",(function(){return ArrayCamera})),n.d(t,"ArrowHelper",(function(){return ArrowHelper})),n.d(t,"Audio",(function(){return Audio})),n.d(t,"AudioAnalyser",(function(){return AudioAnalyser})),n.d(t,"AudioContext",(function(){return Tc})),n.d(t,"AudioListener",(function(){return AudioListener})),n.d(t,"AudioLoader",(function(){return AudioLoader})),n.d(t,"AxesHelper",(function(){return AxesHelper})),n.d(t,"AxisHelper",(function(){return AxisHelper})),n.d(t,"BackSide",(function(){return T})),n.d(t,"BasicDepthPacking",(function(){return mn})),n.d(t,"BasicShadowMap",(function(){return b})),n.d(t,"BinaryTextureLoader",(function(){return BinaryTextureLoader})),n.d(t,"Bone",(function(){return Bone})),n.d(t,"BooleanKeyframeTrack",(function(){return BooleanKeyframeTrack})),n.d(t,"BoundingBoxHelper",(function(){return BoundingBoxHelper})),n.d(t,"Box2",(function(){return Box2})),n.d(t,"Box3",(function(){return Box3})),n.d(t,"Box3Helper",(function(){return Box3Helper})),n.d(t,"BoxBufferGeometry",(function(){return BoxBufferGeometry})),n.d(t,"BoxGeometry",(function(){return BoxGeometry})),n.d(t,"BoxHelper",(function(){return BoxHelper})),n.d(t,"BufferAttribute",(function(){return BufferAttribute})),n.d(t,"BufferGeometry",(function(){return BufferGeometry})),n.d(t,"BufferGeometryLoader",(function(){return BufferGeometryLoader})),n.d(t,"ByteType",(function(){return Ie})),n.d(t,"Cache",(function(){return hc})),n.d(t,"Camera",(function(){return Camera})),n.d(t,"CameraHelper",(function(){return CameraHelper})),n.d(t,"CanvasRenderer",(function(){return CanvasRenderer})),n.d(t,"CanvasTexture",(function(){return CanvasTexture})),n.d(t,"CatmullRomCurve3",(function(){return CatmullRomCurve3})),n.d(t,"CineonToneMapping",(function(){return he})),n.d(t,"CircleBufferGeometry",(function(){return CircleBufferGeometry})),n.d(t,"CircleGeometry",(function(){return CircleGeometry})),n.d(t,"ClampToEdgeWrapping",(function(){return _e})),n.d(t,"Clock",(function(){return Clock})),n.d(t,"ClosedSplineCurve3",(function(){return ClosedSplineCurve3})),n.d(t,"Color",(function(){return Color})),n.d(t,"ColorKeyframeTrack",(function(){return ColorKeyframeTrack})),n.d(t,"CompressedTexture",(function(){return CompressedTexture})),n.d(t,"CompressedTextureLoader",(function(){return CompressedTextureLoader})),n.d(t,"ConeBufferGeometry",(function(){return ConeBufferGeometry})),n.d(t,"ConeGeometry",(function(){return ConeGeometry})),n.d(t,"CubeCamera",(function(){return CubeCamera})),n.d(t,"CubeGeometry",(function(){return BoxGeometry})),n.d(t,"CubeReflectionMapping",(function(){return me})),n.d(t,"CubeRefractionMapping",(function(){return ge})),n.d(t,"CubeTexture",(function(){return CubeTexture})),n.d(t,"CubeTextureLoader",(function(){return CubeTextureLoader})),n.d(t,"CubeUVReflectionMapping",(function(){return xe})),n.d(t,"CubeUVRefractionMapping",(function(){return be})),n.d(t,"CubicBezierCurve",(function(){return CubicBezierCurve})),n.d(t,"CubicBezierCurve3",(function(){return CubicBezierCurve3})),n.d(t,"CubicInterpolant",(function(){return CubicInterpolant})),n.d(t,"CullFaceBack",(function(){return p})),n.d(t,"CullFaceFront",(function(){return m})),n.d(t,"CullFaceFrontBack",(function(){return g})),n.d(t,"CullFaceNone",(function(){return d})),n.d(t,"Curve",(function(){return Curve})),n.d(t,"CurvePath",(function(){return CurvePath})),n.d(t,"CustomBlending",(function(){return G})),n.d(t,"CustomToneMapping",(function(){return pe})),n.d(t,"CylinderBufferGeometry",(function(){return CylinderBufferGeometry})),n.d(t,"CylinderGeometry",(function(){return CylinderGeometry})),n.d(t,"Cylindrical",(function(){return Cylindrical})),n.d(t,"DataTexture",(function(){return DataTexture})),n.d(t,"DataTexture2DArray",(function(){return DataTexture2DArray})),n.d(t,"DataTexture3D",(function(){return DataTexture3D})),n.d(t,"DataTextureLoader",(function(){return DataTextureLoader})),n.d(t,"DecrementStencilOp",(function(){return wn})),n.d(t,"DecrementWrapStencilOp",(function(){return Tn})),n.d(t,"DefaultLoadingManager",(function(){return dc})),n.d(t,"DepthFormat",(function(){return Ke})),n.d(t,"DepthStencilFormat",(function(){return $e})),n.d(t,"DepthTexture",(function(){return DepthTexture})),n.d(t,"DirectionalLight",(function(){return DirectionalLight})),n.d(t,"DirectionalLightHelper",(function(){return DirectionalLightHelper})),n.d(t,"DirectionalLightShadow",(function(){return DirectionalLightShadow})),n.d(t,"DiscreteInterpolant",(function(){return DiscreteInterpolant})),n.d(t,"DodecahedronBufferGeometry",(function(){return DodecahedronBufferGeometry})),n.d(t,"DodecahedronGeometry",(function(){return DodecahedronGeometry})),n.d(t,"DoubleSide",(function(){return E})),n.d(t,"DstAlphaFactor",(function(){return q})),n.d(t,"DstColorFactor",(function(){return Y})),n.d(t,"DynamicBufferAttribute",(function(){return DynamicBufferAttribute})),n.d(t,"DynamicCopyUsage",(function(){return Hn})),n.d(t,"DynamicDrawUsage",(function(){return On})),n.d(t,"DynamicReadUsage",(function(){return Fn})),n.d(t,"EdgesGeometry",(function(){return EdgesGeometry})),n.d(t,"EdgesHelper",(function(){return EdgesHelper})),n.d(t,"EllipseCurve",(function(){return EllipseCurve})),n.d(t,"EqualDepth",(function(){return te})),n.d(t,"EqualStencilFunc",(function(){return Cn})),n.d(t,"EquirectangularReflectionMapping",(function(){return ye})),n.d(t,"EquirectangularRefractionMapping",(function(){return ve})),n.d(t,"Euler",(function(){return Euler})),n.d(t,"EventDispatcher",(function(){return EventDispatcher})),n.d(t,"ExtrudeBufferGeometry",(function(){return ExtrudeBufferGeometry})),n.d(t,"ExtrudeGeometry",(function(){return ExtrudeGeometry})),n.d(t,"Face3",(function(){return Face3})),n.d(t,"Face4",(function(){return Face4})),n.d(t,"FaceColors",(function(){return Cl})),n.d(t,"FileLoader",(function(){return FileLoader})),n.d(t,"FlatShading",(function(){return L})),n.d(t,"Float32Attribute",(function(){return Float32Attribute})),n.d(t,"Float32BufferAttribute",(function(){return Float32BufferAttribute})),n.d(t,"Float64Attribute",(function(){return Float64Attribute})),n.d(t,"Float64BufferAttribute",(function(){return Float64BufferAttribute})),n.d(t,"FloatType",(function(){return Ue})),n.d(t,"Fog",(function(){return Fog})),n.d(t,"FogExp2",(function(){return FogExp2})),n.d(t,"Font",(function(){return Font})),n.d(t,"FontLoader",(function(){return FontLoader})),n.d(t,"FrontFaceDirectionCCW",(function(){return x})),n.d(t,"FrontFaceDirectionCW",(function(){return y})),n.d(t,"FrontSide",(function(){return S})),n.d(t,"Frustum",(function(){return Frustum})),n.d(t,"GammaEncoding",(function(){return ln})),n.d(t,"Geometry",(function(){return Geometry})),n.d(t,"GeometryUtils",(function(){return Rl})),n.d(t,"GreaterDepth",(function(){return re})),n.d(t,"GreaterEqualDepth",(function(){return ne})),n.d(t,"GreaterEqualStencilFunc",(function(){return Dn})),n.d(t,"GreaterStencilFunc",(function(){return Rn})),n.d(t,"GridHelper",(function(){return GridHelper})),n.d(t,"Group",(function(){return Group})),n.d(t,"HalfFloatType",(function(){return ze})),n.d(t,"HemisphereLight",(function(){return HemisphereLight})),n.d(t,"HemisphereLightHelper",(function(){return HemisphereLightHelper})),n.d(t,"HemisphereLightProbe",(function(){return HemisphereLightProbe})),n.d(t,"IcosahedronBufferGeometry",(function(){return IcosahedronBufferGeometry})),n.d(t,"IcosahedronGeometry",(function(){return IcosahedronGeometry})),n.d(t,"ImageBitmapLoader",(function(){return ImageBitmapLoader})),n.d(t,"ImageLoader",(function(){return ImageLoader})),n.d(t,"ImageUtils",(function(){return Xn})),n.d(t,"ImmediateRenderObject",(function(){return ImmediateRenderObject})),n.d(t,"IncrementStencilOp",(function(){return _n})),n.d(t,"IncrementWrapStencilOp",(function(){return Sn})),n.d(t,"InstancedBufferAttribute",(function(){return InstancedBufferAttribute})),n.d(t,"InstancedBufferGeometry",(function(){return InstancedBufferGeometry})),n.d(t,"InstancedInterleavedBuffer",(function(){return InstancedInterleavedBuffer})),n.d(t,"InstancedMesh",(function(){return InstancedMesh})),n.d(t,"Int16Attribute",(function(){return Int16Attribute})),n.d(t,"Int16BufferAttribute",(function(){return Int16BufferAttribute})),n.d(t,"Int32Attribute",(function(){return Int32Attribute})),n.d(t,"Int32BufferAttribute",(function(){return Int32BufferAttribute})),n.d(t,"Int8Attribute",(function(){return Int8Attribute})),n.d(t,"Int8BufferAttribute",(function(){return Int8BufferAttribute})),n.d(t,"IntType",(function(){return Ne})),n.d(t,"InterleavedBuffer",(function(){return InterleavedBuffer})),n.d(t,"InterleavedBufferAttribute",(function(){return InterleavedBufferAttribute})),n.d(t,"Interpolant",(function(){return Interpolant})),n.d(t,"InterpolateDiscrete",(function(){return Zt})),n.d(t,"InterpolateLinear",(function(){return Jt})),n.d(t,"InterpolateSmooth",(function(){return Qt})),n.d(t,"InvertStencilOp",(function(){return En})),n.d(t,"JSONLoader",(function(){return JSONLoader})),n.d(t,"KeepStencilOp",(function(){return bn})),n.d(t,"KeyframeTrack",(function(){return KeyframeTrack})),n.d(t,"LOD",(function(){return LOD})),n.d(t,"LatheBufferGeometry",(function(){return LatheBufferGeometry})),n.d(t,"LatheGeometry",(function(){return LatheGeometry})),n.d(t,"Layers",(function(){return Layers})),n.d(t,"LensFlare",(function(){return LensFlare})),n.d(t,"LessDepth",(function(){return $})),n.d(t,"LessEqualDepth",(function(){return ee})),n.d(t,"LessEqualStencilFunc",(function(){return Pn})),n.d(t,"LessStencilFunc",(function(){return An})),n.d(t,"Light",(function(){return Light})),n.d(t,"LightProbe",(function(){return LightProbe})),n.d(t,"LightShadow",(function(){return LightShadow})),n.d(t,"Line",(function(){return Line})),n.d(t,"Line3",(function(){return Line3})),n.d(t,"LineBasicMaterial",(function(){return LineBasicMaterial})),n.d(t,"LineCurve",(function(){return LineCurve})),n.d(t,"LineCurve3",(function(){return LineCurve3})),n.d(t,"LineDashedMaterial",(function(){return LineDashedMaterial})),n.d(t,"LineLoop",(function(){return LineLoop})),n.d(t,"LinePieces",(function(){return Ll})),n.d(t,"LineSegments",(function(){return LineSegments})),n.d(t,"LineStrip",(function(){return El})),n.d(t,"LinearEncoding",(function(){return sn})),n.d(t,"LinearFilter",(function(){return Ce})),n.d(t,"LinearInterpolant",(function(){return LinearInterpolant})),n.d(t,"LinearMipMapLinearFilter",(function(){return De})),n.d(t,"LinearMipMapNearestFilter",(function(){return Re})),n.d(t,"LinearMipmapLinearFilter",(function(){return Be})),n.d(t,"LinearMipmapNearestFilter",(function(){return Pe})),n.d(t,"LinearToneMapping",(function(){return le})),n.d(t,"Loader",(function(){return Loader})),n.d(t,"LoaderUtils",(function(){return xc})),n.d(t,"LoadingManager",(function(){return LoadingManager})),n.d(t,"LogLuvEncoding",(function(){return hn})),n.d(t,"LoopOnce",(function(){return qt})),n.d(t,"LoopPingPong",(function(){return Yt})),n.d(t,"LoopRepeat",(function(){return Xt})),n.d(t,"LuminanceAlphaFormat",(function(){return Je})),n.d(t,"LuminanceFormat",(function(){return Ze})),n.d(t,"MOUSE",(function(){return c})),n.d(t,"Material",(function(){return Material})),n.d(t,"MaterialLoader",(function(){return MaterialLoader})),n.d(t,"Math",(function(){return Wn})),n.d(t,"MathUtils",(function(){return Wn})),n.d(t,"Matrix3",(function(){return Matrix3})),n.d(t,"Matrix4",(function(){return Matrix4})),n.d(t,"MaxEquation",(function(){return F})),n.d(t,"Mesh",(function(){return Mesh})),n.d(t,"MeshBasicMaterial",(function(){return MeshBasicMaterial})),n.d(t,"MeshDepthMaterial",(function(){return MeshDepthMaterial})),n.d(t,"MeshDistanceMaterial",(function(){return MeshDistanceMaterial})),n.d(t,"MeshFaceMaterial",(function(){return MeshFaceMaterial})),n.d(t,"MeshLambertMaterial",(function(){return MeshLambertMaterial})),n.d(t,"MeshMatcapMaterial",(function(){return MeshMatcapMaterial})),n.d(t,"MeshNormalMaterial",(function(){return MeshNormalMaterial})),n.d(t,"MeshPhongMaterial",(function(){return MeshPhongMaterial})),n.d(t,"MeshPhysicalMaterial",(function(){return MeshPhysicalMaterial})),n.d(t,"MeshStandardMaterial",(function(){return MeshStandardMaterial})),n.d(t,"MeshToonMaterial",(function(){return MeshToonMaterial})),n.d(t,"MinEquation",(function(){return N})),n.d(t,"MirroredRepeatWrapping",(function(){return we})),n.d(t,"MixOperation",(function(){return ae})),n.d(t,"MultiMaterial",(function(){return MultiMaterial})),n.d(t,"MultiplyBlending",(function(){return D})),n.d(t,"MultiplyOperation",(function(){return oe})),n.d(t,"NearestFilter",(function(){return Se})),n.d(t,"NearestMipMapLinearFilter",(function(){return Ae})),n.d(t,"NearestMipMapNearestFilter",(function(){return Ee})),n.d(t,"NearestMipmapLinearFilter",(function(){return Le})),n.d(t,"NearestMipmapNearestFilter",(function(){return Te})),n.d(t,"NeverDepth",(function(){return Q})),n.d(t,"NeverStencilFunc",(function(){return Ln})),n.d(t,"NoBlending",(function(){return C})),n.d(t,"NoColors",(function(){return Al})),n.d(t,"NoToneMapping",(function(){return ce})),n.d(t,"NormalAnimationBlendMode",(function(){return tn})),n.d(t,"NormalBlending",(function(){return P})),n.d(t,"NotEqualDepth",(function(){return ie})),n.d(t,"NotEqualStencilFunc",(function(){return Bn})),n.d(t,"NumberKeyframeTrack",(function(){return NumberKeyframeTrack})),n.d(t,"Object3D",(function(){return Object3D})),n.d(t,"ObjectLoader",(function(){return ObjectLoader})),n.d(t,"ObjectSpaceNormalMap",(function(){return vn})),n.d(t,"OctahedronBufferGeometry",(function(){return OctahedronBufferGeometry})),n.d(t,"OctahedronGeometry",(function(){return OctahedronGeometry})),n.d(t,"OneFactor",(function(){return z})),n.d(t,"OneMinusDstAlphaFactor",(function(){return X})),n.d(t,"OneMinusDstColorFactor",(function(){return Z})),n.d(t,"OneMinusSrcAlphaFactor",(function(){return W})),n.d(t,"OneMinusSrcColorFactor",(function(){return k})),n.d(t,"OrthographicCamera",(function(){return OrthographicCamera})),n.d(t,"PCFShadowMap",(function(){return M})),n.d(t,"PCFSoftShadowMap",(function(){return _})),n.d(t,"PMREMGenerator",(function(){return PMREMGenerator})),n.d(t,"ParametricBufferGeometry",(function(){return ParametricBufferGeometry})),n.d(t,"ParametricGeometry",(function(){return ParametricGeometry})),n.d(t,"Particle",(function(){return Particle})),n.d(t,"ParticleBasicMaterial",(function(){return ParticleBasicMaterial})),n.d(t,"ParticleSystem",(function(){return ParticleSystem})),n.d(t,"ParticleSystemMaterial",(function(){return ParticleSystemMaterial})),n.d(t,"Path",(function(){return Path})),n.d(t,"PerspectiveCamera",(function(){return PerspectiveCamera})),n.d(t,"Plane",(function(){return Plane})),n.d(t,"PlaneBufferGeometry",(function(){return PlaneBufferGeometry})),n.d(t,"PlaneGeometry",(function(){return PlaneGeometry})),n.d(t,"PlaneHelper",(function(){return PlaneHelper})),n.d(t,"PointCloud",(function(){return PointCloud})),n.d(t,"PointCloudMaterial",(function(){return PointCloudMaterial})),n.d(t,"PointLight",(function(){return PointLight})),n.d(t,"PointLightHelper",(function(){return PointLightHelper})),n.d(t,"Points",(function(){return Points})),n.d(t,"PointsMaterial",(function(){return PointsMaterial})),n.d(t,"PolarGridHelper",(function(){return PolarGridHelper})),n.d(t,"PolyhedronBufferGeometry",(function(){return PolyhedronBufferGeometry})),n.d(t,"PolyhedronGeometry",(function(){return PolyhedronGeometry})),n.d(t,"PositionalAudio",(function(){return PositionalAudio})),n.d(t,"PropertyBinding",(function(){return PropertyBinding})),n.d(t,"PropertyMixer",(function(){return PropertyMixer})),n.d(t,"QuadraticBezierCurve",(function(){return QuadraticBezierCurve})),n.d(t,"QuadraticBezierCurve3",(function(){return QuadraticBezierCurve3})),n.d(t,"Quaternion",(function(){return Quaternion})),n.d(t,"QuaternionKeyframeTrack",(function(){return QuaternionKeyframeTrack})),n.d(t,"QuaternionLinearInterpolant",(function(){return QuaternionLinearInterpolant})),n.d(t,"REVISION",(function(){return o})),n.d(t,"RGBADepthPacking",(function(){return gn})),n.d(t,"RGBAFormat",(function(){return Ye})),n.d(t,"RGBAIntegerFormat",(function(){return ot})),n.d(t,"RGBA_ASTC_10x10_Format",(function(){return At})),n.d(t,"RGBA_ASTC_10x5_Format",(function(){return Tt})),n.d(t,"RGBA_ASTC_10x6_Format",(function(){return Et})),n.d(t,"RGBA_ASTC_10x8_Format",(function(){return Lt})),n.d(t,"RGBA_ASTC_12x10_Format",(function(){return Ct})),n.d(t,"RGBA_ASTC_12x12_Format",(function(){return Pt})),n.d(t,"RGBA_ASTC_4x4_Format",(function(){return yt})),n.d(t,"RGBA_ASTC_5x4_Format",(function(){return vt})),n.d(t,"RGBA_ASTC_5x5_Format",(function(){return xt})),n.d(t,"RGBA_ASTC_6x5_Format",(function(){return bt})),n.d(t,"RGBA_ASTC_6x6_Format",(function(){return Mt})),n.d(t,"RGBA_ASTC_8x5_Format",(function(){return _t})),n.d(t,"RGBA_ASTC_8x6_Format",(function(){return wt})),n.d(t,"RGBA_ASTC_8x8_Format",(function(){return St})),n.d(t,"RGBA_BPTC_Format",(function(){return Rt})),n.d(t,"RGBA_ETC2_EAC_Format",(function(){return gt})),n.d(t,"RGBA_PVRTC_2BPPV1_Format",(function(){return pt})),n.d(t,"RGBA_PVRTC_4BPPV1_Format",(function(){return dt})),n.d(t,"RGBA_S3TC_DXT1_Format",(function(){return st})),n.d(t,"RGBA_S3TC_DXT3_Format",(function(){return ct})),n.d(t,"RGBA_S3TC_DXT5_Format",(function(){return lt})),n.d(t,"RGBDEncoding",(function(){return fn})),n.d(t,"RGBEEncoding",(function(){return un})),n.d(t,"RGBEFormat",(function(){return Qe})),n.d(t,"RGBFormat",(function(){return Xe})),n.d(t,"RGBIntegerFormat",(function(){return it})),n.d(t,"RGBM16Encoding",(function(){return pn})),n.d(t,"RGBM7Encoding",(function(){return dn})),n.d(t,"RGB_ETC1_Format",(function(){return ft})),n.d(t,"RGB_ETC2_Format",(function(){return mt})),n.d(t,"RGB_PVRTC_2BPPV1_Format",(function(){return ht})),n.d(t,"RGB_PVRTC_4BPPV1_Format",(function(){return ut})),n.d(t,"RGB_S3TC_DXT1_Format",(function(){return at})),n.d(t,"RGFormat",(function(){return nt})),n.d(t,"RGIntegerFormat",(function(){return rt})),n.d(t,"RawShaderMaterial",(function(){return RawShaderMaterial})),n.d(t,"Ray",(function(){return Ray})),n.d(t,"Raycaster",(function(){return Raycaster})),n.d(t,"RectAreaLight",(function(){return RectAreaLight})),n.d(t,"RedFormat",(function(){return et})),n.d(t,"RedIntegerFormat",(function(){return tt})),n.d(t,"ReinhardToneMapping",(function(){return ue})),n.d(t,"RepeatWrapping",(function(){return Me})),n.d(t,"ReplaceStencilOp",(function(){return Mn})),n.d(t,"ReverseSubtractEquation",(function(){return V})),n.d(t,"RingBufferGeometry",(function(){return RingBufferGeometry})),n.d(t,"RingGeometry",(function(){return RingGeometry})),n.d(t,"SRGB8_ALPHA8_ASTC_10x10_Format",(function(){return kt})),n.d(t,"SRGB8_ALPHA8_ASTC_10x5_Format",(function(){return Ut})),n.d(t,"SRGB8_ALPHA8_ASTC_10x6_Format",(function(){return zt})),n.d(t,"SRGB8_ALPHA8_ASTC_10x8_Format",(function(){return Ht})),n.d(t,"SRGB8_ALPHA8_ASTC_12x10_Format",(function(){return jt})),n.d(t,"SRGB8_ALPHA8_ASTC_12x12_Format",(function(){return Wt})),n.d(t,"SRGB8_ALPHA8_ASTC_4x4_Format",(function(){return Bt})),n.d(t,"SRGB8_ALPHA8_ASTC_5x4_Format",(function(){return Dt})),n.d(t,"SRGB8_ALPHA8_ASTC_5x5_Format",(function(){return Gt})),n.d(t,"SRGB8_ALPHA8_ASTC_6x5_Format",(function(){return It})),n.d(t,"SRGB8_ALPHA8_ASTC_6x6_Format",(function(){return Ot})),n.d(t,"SRGB8_ALPHA8_ASTC_8x5_Format",(function(){return Vt})),n.d(t,"SRGB8_ALPHA8_ASTC_8x6_Format",(function(){return Nt})),n.d(t,"SRGB8_ALPHA8_ASTC_8x8_Format",(function(){return Ft})),n.d(t,"Scene",(function(){return Scene})),n.d(t,"SceneUtils",(function(){return Bl})),n.d(t,"ShaderChunk",(function(){return ss})),n.d(t,"ShaderLib",(function(){return cs})),n.d(t,"ShaderMaterial",(function(){return ShaderMaterial})),n.d(t,"ShadowMaterial",(function(){return ShadowMaterial})),n.d(t,"Shape",(function(){return Shape})),n.d(t,"ShapeBufferGeometry",(function(){return ShapeBufferGeometry})),n.d(t,"ShapeGeometry",(function(){return ShapeGeometry})),n.d(t,"ShapePath",(function(){return ShapePath})),n.d(t,"ShapeUtils",(function(){return ac})),n.d(t,"ShortType",(function(){return Oe})),n.d(t,"Skeleton",(function(){return Skeleton})),n.d(t,"SkeletonHelper",(function(){return SkeletonHelper})),n.d(t,"SkinnedMesh",(function(){return SkinnedMesh})),n.d(t,"SmoothShading",(function(){return A})),n.d(t,"Sphere",(function(){return Sphere})),n.d(t,"SphereBufferGeometry",(function(){return SphereBufferGeometry})),n.d(t,"SphereGeometry",(function(){return SphereGeometry})),n.d(t,"Spherical",(function(){return Spherical})),n.d(t,"SphericalHarmonics3",(function(){return SphericalHarmonics3})),n.d(t,"Spline",(function(){return Spline})),n.d(t,"SplineCurve",(function(){return SplineCurve})),n.d(t,"SplineCurve3",(function(){return SplineCurve3})),n.d(t,"SpotLight",(function(){return SpotLight})),n.d(t,"SpotLightHelper",(function(){return SpotLightHelper})),n.d(t,"SpotLightShadow",(function(){return SpotLightShadow})),n.d(t,"Sprite",(function(){return Sprite})),n.d(t,"SpriteMaterial",(function(){return SpriteMaterial})),n.d(t,"SrcAlphaFactor",(function(){return j})),n.d(t,"SrcAlphaSaturateFactor",(function(){return J})),n.d(t,"SrcColorFactor",(function(){return H})),n.d(t,"StaticCopyUsage",(function(){return zn})),n.d(t,"StaticDrawUsage",(function(){return In})),n.d(t,"StaticReadUsage",(function(){return Nn})),n.d(t,"StereoCamera",(function(){return StereoCamera})),n.d(t,"StreamCopyUsage",(function(){return kn})),n.d(t,"StreamDrawUsage",(function(){return Vn})),n.d(t,"StreamReadUsage",(function(){return Un})),n.d(t,"StringKeyframeTrack",(function(){return StringKeyframeTrack})),n.d(t,"SubtractEquation",(function(){return O})),n.d(t,"SubtractiveBlending",(function(){return B})),n.d(t,"TOUCH",(function(){return h})),n.d(t,"TangentSpaceNormalMap",(function(){return yn})),n.d(t,"TetrahedronBufferGeometry",(function(){return TetrahedronBufferGeometry})),n.d(t,"TetrahedronGeometry",(function(){return TetrahedronGeometry})),n.d(t,"TextBufferGeometry",(function(){return TextBufferGeometry})),n.d(t,"TextGeometry",(function(){return TextGeometry})),n.d(t,"Texture",(function(){return Texture})),n.d(t,"TextureLoader",(function(){return TextureLoader})),n.d(t,"TorusBufferGeometry",(function(){return TorusBufferGeometry})),n.d(t,"TorusGeometry",(function(){return TorusGeometry})),n.d(t,"TorusKnotBufferGeometry",(function(){return TorusKnotBufferGeometry})),n.d(t,"TorusKnotGeometry",(function(){return TorusKnotGeometry})),n.d(t,"Triangle",(function(){return Triangle})),n.d(t,"TriangleFanDrawMode",(function(){return an})),n.d(t,"TriangleStripDrawMode",(function(){return on})),n.d(t,"TrianglesDrawMode",(function(){return rn})),n.d(t,"TubeBufferGeometry",(function(){return TubeBufferGeometry})),n.d(t,"TubeGeometry",(function(){return TubeGeometry})),n.d(t,"UVMapping",(function(){return fe})),n.d(t,"Uint16Attribute",(function(){return Uint16Attribute})),n.d(t,"Uint16BufferAttribute",(function(){return Uint16BufferAttribute})),n.d(t,"Uint32Attribute",(function(){return Uint32Attribute})),n.d(t,"Uint32BufferAttribute",(function(){return Uint32BufferAttribute})),n.d(t,"Uint8Attribute",(function(){return Uint8Attribute})),n.d(t,"Uint8BufferAttribute",(function(){return Uint8BufferAttribute})),n.d(t,"Uint8ClampedAttribute",(function(){return Uint8ClampedAttribute})),n.d(t,"Uint8ClampedBufferAttribute",(function(){return Uint8ClampedBufferAttribute})),n.d(t,"Uniform",(function(){return Uniform})),n.d(t,"UniformsLib",(function(){return Ui})),n.d(t,"UniformsUtils",(function(){return Di})),n.d(t,"UnsignedByteType",(function(){return Ge})),n.d(t,"UnsignedInt248Type",(function(){return We})),n.d(t,"UnsignedIntType",(function(){return Fe})),n.d(t,"UnsignedShort4444Type",(function(){return He})),n.d(t,"UnsignedShort5551Type",(function(){return ke})),n.d(t,"UnsignedShort565Type",(function(){return je})),n.d(t,"UnsignedShortType",(function(){return Ve})),n.d(t,"VSMShadowMap",(function(){return w})),n.d(t,"Vector2",(function(){return Vector2})),n.d(t,"Vector3",(function(){return Vector3})),n.d(t,"Vector4",(function(){return Vector4})),n.d(t,"VectorKeyframeTrack",(function(){return VectorKeyframeTrack})),n.d(t,"Vertex",(function(){return Vertex})),n.d(t,"VertexColors",(function(){return Pl})),n.d(t,"VideoTexture",(function(){return VideoTexture})),n.d(t,"WebGL1Renderer",(function(){return WebGL1Renderer})),n.d(t,"WebGLCubeRenderTarget",(function(){return WebGLCubeRenderTarget})),n.d(t,"WebGLMultisampleRenderTarget",(function(){return WebGLMultisampleRenderTarget})),n.d(t,"WebGLRenderTarget",(function(){return WebGLRenderTarget})),n.d(t,"WebGLRenderTargetCube",(function(){return WebGLRenderTargetCube})),n.d(t,"WebGLRenderer",(function(){return WebGLRenderer})),n.d(t,"WebGLUtils",(function(){return WebGLUtils})),n.d(t,"WireframeGeometry",(function(){return WireframeGeometry})),n.d(t,"WireframeHelper",(function(){return WireframeHelper})),n.d(t,"WrapAroundEnding",(function(){return en})),n.d(t,"XHRLoader",(function(){return XHRLoader})),n.d(t,"ZeroCurvatureEnding",(function(){return Kt})),n.d(t,"ZeroFactor",(function(){return U})),n.d(t,"ZeroSlopeEnding",(function(){return $t})),n.d(t,"ZeroStencilOp",(function(){return xn})),n.d(t,"sRGBEncoding",(function(){return cn})),void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Number.isInteger&&(Number.isInteger=function(e){return"number"===typeof e&&isFinite(e)&&Math.floor(e)===e}),void 0===Math.sign&&(Math.sign=function(e){return e<0?-1:e>0?1:+e}),"name"in Function.prototype===!1&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),void 0===Object.assign&&(Object.assign=function(e){if(void 0===e||null===e)throw new TypeError("Cannot convert undefined or null to object");const t=Object(e);for(let n=1;n<arguments.length;n++){const e=arguments[n];if(void 0!==e&&null!==e)for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])}return t});const o="118",c={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},h={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},d=0,p=1,m=2,g=3,y=0,x=1,b=0,M=1,_=2,w=3,S=0,T=1,E=2,L=1,A=2,C=0,P=1,R=2,B=3,D=4,G=5,I=100,O=101,V=102,N=103,F=104,U=200,z=201,H=202,k=203,j=204,W=205,q=206,X=207,Y=208,Z=209,J=210,Q=0,K=1,$=2,ee=3,te=4,ne=5,re=6,ie=7,oe=0,ae=1,se=2,ce=0,le=1,ue=2,he=3,de=4,pe=5,fe=300,me=301,ge=302,ye=303,ve=304,xe=306,be=307,Me=1e3,_e=1001,we=1002,Se=1003,Te=1004,Ee=1004,Le=1005,Ae=1005,Ce=1006,Pe=1007,Re=1007,Be=1008,De=1008,Ge=1009,Ie=1010,Oe=1011,Ve=1012,Ne=1013,Fe=1014,Ue=1015,ze=1016,He=1017,ke=1018,je=1019,We=1020,qe=1021,Xe=1022,Ye=1023,Ze=1024,Je=1025,Qe=Ye,Ke=1026,$e=1027,et=1028,tt=1029,nt=1030,rt=1031,it=1032,ot=1033,at=33776,st=33777,ct=33778,lt=33779,ut=35840,ht=35841,dt=35842,pt=35843,ft=36196,mt=37492,gt=37496,yt=37808,vt=37809,xt=37810,bt=37811,Mt=37812,_t=37813,wt=37814,St=37815,Tt=37816,Et=37817,Lt=37818,At=37819,Ct=37820,Pt=37821,Rt=36492,Bt=37840,Dt=37841,Gt=37842,It=37843,Ot=37844,Vt=37845,Nt=37846,Ft=37847,Ut=37848,zt=37849,Ht=37850,kt=37851,jt=37852,Wt=37853,qt=2200,Xt=2201,Yt=2202,Zt=2300,Jt=2301,Qt=2302,Kt=2400,$t=2401,en=2402,tn=2500,nn=2501,rn=0,on=1,an=2,sn=3e3,cn=3001,ln=3007,un=3002,hn=3003,dn=3004,pn=3005,fn=3006,mn=3200,gn=3201,yn=0,vn=1,xn=0,bn=7680,Mn=7681,_n=7682,wn=7683,Sn=34055,Tn=34056,En=5386,Ln=512,An=513,Cn=514,Pn=515,Rn=516,Bn=517,Dn=518,Gn=519,In=35044,On=35048,Vn=35040,Nn=35045,Fn=35049,Un=35041,zn=35046,Hn=35050,kn=35042;function EventDispatcher(){}Object.assign(EventDispatcher.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)},removeEventListener:function(e,t){if(void 0===this._listeners)return;const n=this._listeners,o=n[e];if(void 0!==o){const e=o.indexOf(t);-1!==e&&o.splice(e,1)}},dispatchEvent:function(e){if(void 0===this._listeners)return;const t=this._listeners,n=t[e.type];if(void 0!==n){e.target=this;const t=n.slice(0);for(let n=0,o=t.length;n<o;n++)t[n].call(this,e)}}});const jn=[];for(let Dl=0;Dl<256;Dl++)jn[Dl]=(Dl<16?"0":"")+Dl.toString(16);const Wn={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,o=4294967295*Math.random()|0,c=jn[255&e]+jn[e>>8&255]+jn[e>>16&255]+jn[e>>24&255]+"-"+jn[255&t]+jn[t>>8&255]+"-"+jn[t>>16&15|64]+jn[t>>24&255]+"-"+jn[63&n|128]+jn[n>>8&255]+"-"+jn[n>>16&255]+jn[n>>24&255]+jn[255&o]+jn[o>>8&255]+jn[o>>16&255]+jn[o>>24&255];return c.toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,o,c){return o+(e-t)*(c-o)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*(3-2*e))},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*e*(e*(6*e-15)+10))},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},degToRad:function(e){return e*Wn.DEG2RAD},radToDeg:function(e){return e*Wn.RAD2DEG},isPowerOfTwo:function(e){return 0===(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,o,c){const h=Math.cos,d=Math.sin,p=h(n/2),m=d(n/2),g=h((t+o)/2),y=d((t+o)/2),x=h((t-o)/2),b=d((t-o)/2),M=h((o-t)/2),_=d((o-t)/2);switch(c){case"XYX":e.set(p*y,m*x,m*b,p*g);break;case"YZY":e.set(m*b,p*y,m*x,p*g);break;case"ZXZ":e.set(m*x,m*b,p*y,p*g);break;case"XZX":e.set(p*y,m*_,m*M,p*g);break;case"YXY":e.set(m*M,p*y,m*_,p*g);break;case"ZYZ":e.set(m*_,m*M,p*y,p*g);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+c)}}};function Vector2(e=0,t=0){this.x=e,this.y=t}function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}let qn;Object.defineProperties(Vector2.prototype,{width:{get:function(){return this.x},set:function(e){this.x=e}},height:{get:function(){return this.y},set:function(e){this.y=e}}}),Object.assign(Vector2.prototype,{isVector2:!0,set:function(e,t){return this.x=e,this.y=t,this},setScalar:function(e){return this.x=e,this.y=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(e){return this.x=e.x,this.y=e.y,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)},addScalar:function(e){return this.x+=e,this.y+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)},subScalar:function(e){return this.x-=e,this.y-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this},multiply:function(e){return this.x*=e.x,this.y*=e.y,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this},divide:function(e){return this.x/=e.x,this.y/=e.y,this},divideScalar:function(e){return this.multiplyScalar(1/e)},applyMatrix3:function(e){const t=this.x,n=this.y,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6],this.y=o[1]*t+o[4]*n+o[7],this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this},clampLength:function(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this},negate:function(){return this.x=-this.x,this.y=-this.y,this},dot:function(e){return this.x*e.x+this.y*e.y},cross:function(e){return this.x*e.y-this.y*e.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){const e=Math.atan2(-this.y,-this.x)+Math.PI;return e},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this},lerpVectors:function(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this},equals:function(e){return e.x===this.x&&e.y===this.y},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e},fromBufferAttribute:function(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this},rotateAround:function(e,t){const n=Math.cos(t),o=Math.sin(t),c=this.x-e.x,h=this.y-e.y;return this.x=c*n-h*o+e.x,this.y=c*o+h*n+e.y,this},random:function(){return this.x=Math.random(),this.y=Math.random(),this}}),Object.assign(Matrix3.prototype,{isMatrix3:!0,set:function(e,t,n,o,c,h,d,p,m){const g=this.elements;return g[0]=e,g[1]=o,g[2]=d,g[3]=t,g[4]=c,g[5]=p,g[6]=n,g[7]=h,g[8]=m,this},identity:function(){return this.set(1,0,0,0,1,0,0,0,1),this},clone:function(){return(new this.constructor).fromArray(this.elements)},copy:function(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this},extractBasis:function(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this},setFromMatrix4:function(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this},multiply:function(e){return this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,t){const n=e.elements,o=t.elements,c=this.elements,h=n[0],d=n[3],p=n[6],m=n[1],g=n[4],y=n[7],x=n[2],b=n[5],M=n[8],_=o[0],w=o[3],S=o[6],T=o[1],E=o[4],L=o[7],A=o[2],C=o[5],P=o[8];return c[0]=h*_+d*T+p*A,c[3]=h*w+d*E+p*C,c[6]=h*S+d*L+p*P,c[1]=m*_+g*T+y*A,c[4]=m*w+g*E+y*C,c[7]=m*S+g*L+y*P,c[2]=x*_+b*T+M*A,c[5]=x*w+b*E+M*C,c[8]=x*S+b*L+M*P,this},multiplyScalar:function(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this},determinant:function(){const e=this.elements,t=e[0],n=e[1],o=e[2],c=e[3],h=e[4],d=e[5],p=e[6],m=e[7],g=e[8];return t*h*g-t*d*m-n*c*g+n*d*p+o*c*m-o*h*p},getInverse:function(e,t){void 0!==t&&console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");const n=e.elements,o=this.elements,c=n[0],h=n[1],d=n[2],p=n[3],m=n[4],g=n[5],y=n[6],x=n[7],b=n[8],M=b*m-g*x,_=g*y-b*p,w=x*p-m*y,S=c*M+h*_+d*w;if(0===S)return this.set(0,0,0,0,0,0,0,0,0);const T=1/S;return o[0]=M*T,o[1]=(d*x-b*h)*T,o[2]=(g*h-d*m)*T,o[3]=_*T,o[4]=(b*c-d*y)*T,o[5]=(d*p-g*c)*T,o[6]=w*T,o[7]=(h*y-x*c)*T,o[8]=(m*c-h*p)*T,this},transpose:function(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this},getNormalMatrix:function(e){return this.setFromMatrix4(e).getInverse(this).transpose()},transposeIntoArray:function(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this},setUvTransform:function(e,t,n,o,c,h,d){const p=Math.cos(c),m=Math.sin(c);this.set(n*p,n*m,-n*(p*h+m*d)+h+e,-o*m,o*p,-o*(-m*h+p*d)+d+t,0,0,1)},scale:function(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this},rotate:function(e){const t=Math.cos(e),n=Math.sin(e),o=this.elements,c=o[0],h=o[3],d=o[6],p=o[1],m=o[4],g=o[7];return o[0]=t*c+n*p,o[3]=t*h+n*m,o[6]=t*d+n*g,o[1]=-n*c+t*p,o[4]=-n*h+t*m,o[7]=-n*d+t*g,this},translate:function(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this},equals:function(e){const t=this.elements,n=e.elements;for(let o=0;o<9;o++)if(t[o]!==n[o])return!1;return!0},fromArray:function(e,t){void 0===t&&(t=0);for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}});const Xn={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===qn&&(qn=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),qn.width=e.width,qn.height=e.height;const n=qn.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=qn}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let Yn=0;function Texture(e,t,n,o,c,h,d,p,m,g){Object.defineProperty(this,"id",{value:Yn++}),this.uuid=Wn.generateUUID(),this.name="",this.image=void 0!==e?e:Texture.DEFAULT_IMAGE,this.mipmaps=[],this.mapping=void 0!==t?t:Texture.DEFAULT_MAPPING,this.wrapS=void 0!==n?n:_e,this.wrapT=void 0!==o?o:_e,this.magFilter=void 0!==c?c:Ce,this.minFilter=void 0!==h?h:Be,this.anisotropy=void 0!==m?m:1,this.format=void 0!==d?d:Ye,this.internalFormat=null,this.type=void 0!==p?p:Ge,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=void 0!==g?g:sn,this.version=0,this.onUpdate=null}function Vector4(e=0,t=0,n=0,o=1){this.x=e,this.y=t,this.z=n,this.w=o}function WebGLRenderTarget(e,t,n){this.width=e,this.height=t,this.scissor=new Vector4(0,0,e,t),this.scissorTest=!1,this.viewport=new Vector4(0,0,e,t),n=n||{},this.texture=new Texture(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Ce,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0===n.stencilBuffer||n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}function WebGLMultisampleRenderTarget(e,t,n){WebGLRenderTarget.call(this,e,t,n),this.samples=4}function Quaternion(e=0,t=0,n=0,o=1){this._x=e,this._y=t,this._z=n,this._w=o}Texture.DEFAULT_IMAGE=void 0,Texture.DEFAULT_MAPPING=fe,Texture.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Texture,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=void 0===e||"string"===typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const o=this.image;if(void 0===o.uuid&&(o.uuid=Wn.generateUUID()),!t&&void 0===e.images[o.uuid]){let t;if(Array.isArray(o)){t=[];for(let e=0,n=o.length;e<n;e++)t.push(Xn.getDataURL(o[e]))}else t=Xn.getDataURL(o);e.images[o.uuid]={uuid:o.uuid,url:t}}n.image=o.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==fe)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Me:e.x=e.x-Math.floor(e.x);break;case _e:e.x=e.x<0?0:1;break;case we:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Me:e.y=e.y-Math.floor(e.y);break;case _e:e.y=e.y<0?0:1;break;case we:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(Texture.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.defineProperties(Vector4.prototype,{width:{get:function(){return this.z},set:function(e){this.z=e}},height:{get:function(){return this.w},set:function(e){this.w=e}}}),Object.assign(Vector4.prototype,{isVector4:!0,set:function(e,t,n,o){return this.x=e,this.y=t,this.z=n,this.w=o,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this.w=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setW:function(e){return this.w=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this},applyMatrix4:function(e){const t=this.x,n=this.y,o=this.z,c=this.w,h=e.elements;return this.x=h[0]*t+h[4]*n+h[8]*o+h[12]*c,this.y=h[1]*t+h[5]*n+h[9]*o+h[13]*c,this.z=h[2]*t+h[6]*n+h[10]*o+h[14]*c,this.w=h[3]*t+h[7]*n+h[11]*o+h[15]*c,this},divideScalar:function(e){return this.multiplyScalar(1/e)},setAxisAngleFromQuaternion:function(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this},setAxisAngleFromRotationMatrix:function(e){let t,n,o,c;const h=.01,d=.1,p=e.elements,m=p[0],g=p[4],y=p[8],x=p[1],b=p[5],M=p[9],_=p[2],w=p[6],S=p[10];if(Math.abs(g-x)<h&&Math.abs(y-_)<h&&Math.abs(M-w)<h){if(Math.abs(g+x)<d&&Math.abs(y+_)<d&&Math.abs(M+w)<d&&Math.abs(m+b+S-3)<d)return this.set(1,0,0,0),this;t=Math.PI;const e=(m+1)/2,p=(b+1)/2,T=(S+1)/2,E=(g+x)/4,L=(y+_)/4,A=(M+w)/4;return e>p&&e>T?e<h?(n=0,o=.707106781,c=.707106781):(n=Math.sqrt(e),o=E/n,c=L/n):p>T?p<h?(n=.707106781,o=0,c=.707106781):(o=Math.sqrt(p),n=E/o,c=A/o):T<h?(n=.707106781,o=.707106781,c=0):(c=Math.sqrt(T),n=L/c,o=A/c),this.set(n,o,c,t),this}let T=Math.sqrt((w-M)*(w-M)+(y-_)*(y-_)+(x-g)*(x-g));return Math.abs(T)<.001&&(T=1),this.x=(w-M)/T,this.y=(y-_)/T,this.z=(x-g)/T,this.w=Math.acos((m+b+S-1)/2),this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this},clampLength:function(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this},lerpVectors:function(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e},fromBufferAttribute:function(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}),WebGLRenderTarget.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:WebGLRenderTarget,isWebGLRenderTarget:!0,setSize:function(e,t){this.width===e&&this.height===t||(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),WebGLMultisampleRenderTarget.prototype=Object.assign(Object.create(WebGLRenderTarget.prototype),{constructor:WebGLMultisampleRenderTarget,isWebGLMultisampleRenderTarget:!0,copy:function(e){return WebGLRenderTarget.prototype.copy.call(this,e),this.samples=e.samples,this}}),Object.assign(Quaternion,{slerp:function(e,t,n,o){return n.copy(e).slerp(t,o)},slerpFlat:function(e,t,n,o,c,h,d){let p=n[o+0],m=n[o+1],g=n[o+2],y=n[o+3];const x=c[h+0],b=c[h+1],M=c[h+2],_=c[h+3];if(y!==_||p!==x||m!==b||g!==M){let e=1-d,t=p*x+m*b+g*M+y*_,n=t>=0?1:-1,o=1-t*t;if(o>Number.EPSILON){const c=Math.sqrt(o),h=Math.atan2(c,t*n);e=Math.sin(e*h)/c,d=Math.sin(d*h)/c}const c=d*n;if(p=p*e+x*c,m=m*e+b*c,g=g*e+M*c,y=y*e+_*c,e===1-d){const e=1/Math.sqrt(p*p+m*m+g*g+y*y);p*=e,m*=e,g*=e,y*=e}}e[t]=p,e[t+1]=m,e[t+2]=g,e[t+3]=y},multiplyQuaternionsFlat:function(e,t,n,o,c,h){const d=n[o],p=n[o+1],m=n[o+2],g=n[o+3],y=c[h],x=c[h+1],b=c[h+2],M=c[h+3];return e[t]=d*M+g*y+p*b-m*x,e[t+1]=p*M+g*x+m*y-d*b,e[t+2]=m*M+g*b+d*x-p*y,e[t+3]=g*M-d*y-p*x-m*b,e}}),Object.defineProperties(Quaternion.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},w:{get:function(){return this._w},set:function(e){this._w=e,this._onChangeCallback()}}}),Object.assign(Quaternion.prototype,{isQuaternion:!0,set:function(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._w=o,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this},setFromEuler:function(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,o=e._y,c=e._z,h=e.order,d=Math.cos,p=Math.sin,m=d(n/2),g=d(o/2),y=d(c/2),x=p(n/2),b=p(o/2),M=p(c/2);switch(h){case"XYZ":this._x=x*g*y+m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y-x*b*M;break;case"YXZ":this._x=x*g*y+m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y+x*b*M;break;case"ZXY":this._x=x*g*y-m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y-x*b*M;break;case"ZYX":this._x=x*g*y-m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y+x*b*M;break;case"YZX":this._x=x*g*y+m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y-x*b*M;break;case"XZY":this._x=x*g*y-m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y+x*b*M;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+h)}return!1!==t&&this._onChangeCallback(),this},setFromAxisAngle:function(e,t){const n=t/2,o=Math.sin(n);return this._x=e.x*o,this._y=e.y*o,this._z=e.z*o,this._w=Math.cos(n),this._onChangeCallback(),this},setFromRotationMatrix:function(e){const t=e.elements,n=t[0],o=t[4],c=t[8],h=t[1],d=t[5],p=t[9],m=t[2],g=t[6],y=t[10],x=n+d+y;if(x>0){const e=.5/Math.sqrt(x+1);this._w=.25/e,this._x=(g-p)*e,this._y=(c-m)*e,this._z=(h-o)*e}else if(n>d&&n>y){const e=2*Math.sqrt(1+n-d-y);this._w=(g-p)/e,this._x=.25*e,this._y=(o+h)/e,this._z=(c+m)/e}else if(d>y){const e=2*Math.sqrt(1+d-n-y);this._w=(c-m)/e,this._x=(o+h)/e,this._y=.25*e,this._z=(p+g)/e}else{const e=2*Math.sqrt(1+y-n-d);this._w=(h-o)/e,this._x=(c+m)/e,this._y=(p+g)/e,this._z=.25*e}return this._onChangeCallback(),this},setFromUnitVectors:function(e,t){const n=1e-6;let o=e.dot(t)+1;return o<n?(o=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=o):(this._x=0,this._y=-e.z,this._z=e.y,this._w=o)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=o),this.normalize()},angleTo:function(e){return 2*Math.acos(Math.abs(Wn.clamp(this.dot(e),-1,1)))},rotateTowards:function(e,t){const n=this.angleTo(e);if(0===n)return this;const o=Math.min(1,t/n);return this.slerp(e,o),this},inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this},dot:function(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)},premultiply:function(e){return this.multiplyQuaternions(e,this)},multiplyQuaternions:function(e,t){const n=e._x,o=e._y,c=e._z,h=e._w,d=t._x,p=t._y,m=t._z,g=t._w;return this._x=n*g+h*d+o*m-c*p,this._y=o*g+h*p+c*d-n*m,this._z=c*g+h*m+n*p-o*d,this._w=h*g-n*d-o*p-c*m,this._onChangeCallback(),this},slerp:function(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,o=this._y,c=this._z,h=this._w;let d=h*e._w+n*e._x+o*e._y+c*e._z;if(d<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,d=-d):this.copy(e),d>=1)return this._w=h,this._x=n,this._y=o,this._z=c,this;const p=1-d*d;if(p<=Number.EPSILON){const e=1-t;return this._w=e*h+t*this._w,this._x=e*n+t*this._x,this._y=e*o+t*this._y,this._z=e*c+t*this._z,this.normalize(),this._onChangeCallback(),this}const m=Math.sqrt(p),g=Math.atan2(m,d),y=Math.sin((1-t)*g)/m,x=Math.sin(t*g)/m;return this._w=h*y+this._w*x,this._x=n*y+this._x*x,this._y=o*y+this._y*x,this._z=c*y+this._z*x,this._onChangeCallback(),this},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w},fromArray:function(e,t){return void 0===t&&(t=0),this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e},fromBufferAttribute:function(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}});const Zn=new Vector3,Jn=new Quaternion;function Vector3(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}Object.assign(Vector3.prototype,{isVector3:!0,set:function(e,t,n){return this.x=e,this.y=t,this.z=n,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this},multiplyVectors:function(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this},applyEuler:function(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Jn.setFromEuler(e))},applyAxisAngle:function(e,t){return this.applyQuaternion(Jn.setFromAxisAngle(e,t))},applyMatrix3:function(e){const t=this.x,n=this.y,o=this.z,c=e.elements;return this.x=c[0]*t+c[3]*n+c[6]*o,this.y=c[1]*t+c[4]*n+c[7]*o,this.z=c[2]*t+c[5]*n+c[8]*o,this},applyNormalMatrix:function(e){return this.applyMatrix3(e).normalize()},applyMatrix4:function(e){const t=this.x,n=this.y,o=this.z,c=e.elements,h=1/(c[3]*t+c[7]*n+c[11]*o+c[15]);return this.x=(c[0]*t+c[4]*n+c[8]*o+c[12])*h,this.y=(c[1]*t+c[5]*n+c[9]*o+c[13])*h,this.z=(c[2]*t+c[6]*n+c[10]*o+c[14])*h,this},applyQuaternion:function(e){const t=this.x,n=this.y,o=this.z,c=e.x,h=e.y,d=e.z,p=e.w,m=p*t+h*o-d*n,g=p*n+d*t-c*o,y=p*o+c*n-h*t,x=-c*t-h*n-d*o;return this.x=m*p+x*-c+g*-d-y*-h,this.y=g*p+x*-h+y*-c-m*-d,this.z=y*p+x*-d+m*-h-g*-c,this},project:function(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)},unproject:function(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)},transformDirection:function(e){const t=this.x,n=this.y,o=this.z,c=e.elements;return this.x=c[0]*t+c[4]*n+c[8]*o,this.y=c[1]*t+c[5]*n+c[9]*o,this.z=c[2]*t+c[6]*n+c[10]*o,this.normalize()},divide:function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this},divideScalar:function(e){return this.multiplyScalar(1/e)},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this},clampLength:function(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this},lerpVectors:function(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this},cross:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)},crossVectors:function(e,t){const n=e.x,o=e.y,c=e.z,h=t.x,d=t.y,p=t.z;return this.x=o*p-c*d,this.y=c*h-n*p,this.z=n*d-o*h,this},projectOnVector:function(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)},projectOnPlane:function(e){return Zn.copy(this).projectOnVector(e),this.sub(Zn)},reflect:function(e){return this.sub(Zn.copy(e).multiplyScalar(2*this.dot(e)))},angleTo:function(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Wn.clamp(n,-1,1))},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){const t=this.x-e.x,n=this.y-e.y,o=this.z-e.z;return t*t+n*n+o*o},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)},setFromSpherical:function(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)},setFromSphericalCoords:function(e,t,n){const o=Math.sin(t)*e;return this.x=o*Math.sin(n),this.y=Math.cos(t)*e,this.z=o*Math.cos(n),this},setFromCylindrical:function(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)},setFromCylindricalCoords:function(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this},setFromMatrixPosition:function(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this},setFromMatrixScale:function(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),o=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=o,this},setFromMatrixColumn:function(e,t){return this.fromArray(e.elements,4*t)},setFromMatrix3Column:function(e,t){return this.fromArray(e.elements,3*t)},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e},fromBufferAttribute:function(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}});const Qn=new Vector3,Kn=new Matrix4,$n=new Vector3(0,0,0),er=new Vector3(1,1,1),tr=new Vector3,nr=new Vector3,rr=new Vector3;function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}Object.assign(Matrix4.prototype,{isMatrix4:!0,set:function(e,t,n,o,c,h,d,p,m,g,y,x,b,M,_,w){const S=this.elements;return S[0]=e,S[4]=t,S[8]=n,S[12]=o,S[1]=c,S[5]=h,S[9]=d,S[13]=p,S[2]=m,S[6]=g,S[10]=y,S[14]=x,S[3]=b,S[7]=M,S[11]=_,S[15]=w,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return(new Matrix4).fromArray(this.elements)},copy:function(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this},copyPosition:function(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this},extractBasis:function(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this},makeBasis:function(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this},extractRotation:function(e){const t=this.elements,n=e.elements,o=1/Qn.setFromMatrixColumn(e,0).length(),c=1/Qn.setFromMatrixColumn(e,1).length(),h=1/Qn.setFromMatrixColumn(e,2).length();return t[0]=n[0]*o,t[1]=n[1]*o,t[2]=n[2]*o,t[3]=0,t[4]=n[4]*c,t[5]=n[5]*c,t[6]=n[6]*c,t[7]=0,t[8]=n[8]*h,t[9]=n[9]*h,t[10]=n[10]*h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},makeRotationFromEuler:function(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,o=e.y,c=e.z,h=Math.cos(n),d=Math.sin(n),p=Math.cos(o),m=Math.sin(o),g=Math.cos(c),y=Math.sin(c);if("XYZ"===e.order){const e=h*g,n=h*y,o=d*g,c=d*y;t[0]=p*g,t[4]=-p*y,t[8]=m,t[1]=n+o*m,t[5]=e-c*m,t[9]=-d*p,t[2]=c-e*m,t[6]=o+n*m,t[10]=h*p}else if("YXZ"===e.order){const e=p*g,n=p*y,o=m*g,c=m*y;t[0]=e+c*d,t[4]=o*d-n,t[8]=h*m,t[1]=h*y,t[5]=h*g,t[9]=-d,t[2]=n*d-o,t[6]=c+e*d,t[10]=h*p}else if("ZXY"===e.order){const e=p*g,n=p*y,o=m*g,c=m*y;t[0]=e-c*d,t[4]=-h*y,t[8]=o+n*d,t[1]=n+o*d,t[5]=h*g,t[9]=c-e*d,t[2]=-h*m,t[6]=d,t[10]=h*p}else if("ZYX"===e.order){const e=h*g,n=h*y,o=d*g,c=d*y;t[0]=p*g,t[4]=o*m-n,t[8]=e*m+c,t[1]=p*y,t[5]=c*m+e,t[9]=n*m-o,t[2]=-m,t[6]=d*p,t[10]=h*p}else if("YZX"===e.order){const e=h*p,n=h*m,o=d*p,c=d*m;t[0]=p*g,t[4]=c-e*y,t[8]=o*y+n,t[1]=y,t[5]=h*g,t[9]=-d*g,t[2]=-m*g,t[6]=n*y+o,t[10]=e-c*y}else if("XZY"===e.order){const e=h*p,n=h*m,o=d*p,c=d*m;t[0]=p*g,t[4]=-y,t[8]=m*g,t[1]=e*y+c,t[5]=h*g,t[9]=n*y-o,t[2]=o*y-n,t[6]=d*g,t[10]=c*y+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},makeRotationFromQuaternion:function(e){return this.compose($n,e,er)},lookAt:function(e,t,n){const o=this.elements;return rr.subVectors(e,t),0===rr.lengthSq()&&(rr.z=1),rr.normalize(),tr.crossVectors(n,rr),0===tr.lengthSq()&&(1===Math.abs(n.z)?rr.x+=1e-4:rr.z+=1e-4,rr.normalize(),tr.crossVectors(n,rr)),tr.normalize(),nr.crossVectors(rr,tr),o[0]=tr.x,o[4]=nr.x,o[8]=rr.x,o[1]=tr.y,o[5]=nr.y,o[9]=rr.y,o[2]=tr.z,o[6]=nr.z,o[10]=rr.z,this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,t){const n=e.elements,o=t.elements,c=this.elements,h=n[0],d=n[4],p=n[8],m=n[12],g=n[1],y=n[5],x=n[9],b=n[13],M=n[2],_=n[6],w=n[10],S=n[14],T=n[3],E=n[7],L=n[11],A=n[15],C=o[0],P=o[4],R=o[8],B=o[12],D=o[1],G=o[5],I=o[9],O=o[13],V=o[2],N=o[6],F=o[10],U=o[14],z=o[3],H=o[7],k=o[11],j=o[15];return c[0]=h*C+d*D+p*V+m*z,c[4]=h*P+d*G+p*N+m*H,c[8]=h*R+d*I+p*F+m*k,c[12]=h*B+d*O+p*U+m*j,c[1]=g*C+y*D+x*V+b*z,c[5]=g*P+y*G+x*N+b*H,c[9]=g*R+y*I+x*F+b*k,c[13]=g*B+y*O+x*U+b*j,c[2]=M*C+_*D+w*V+S*z,c[6]=M*P+_*G+w*N+S*H,c[10]=M*R+_*I+w*F+S*k,c[14]=M*B+_*O+w*U+S*j,c[3]=T*C+E*D+L*V+A*z,c[7]=T*P+E*G+L*N+A*H,c[11]=T*R+E*I+L*F+A*k,c[15]=T*B+E*O+L*U+A*j,this},multiplyScalar:function(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this},determinant:function(){const e=this.elements,t=e[0],n=e[4],o=e[8],c=e[12],h=e[1],d=e[5],p=e[9],m=e[13],g=e[2],y=e[6],x=e[10],b=e[14],M=e[3],_=e[7],w=e[11],S=e[15];return M*(+c*p*y-o*m*y-c*d*x+n*m*x+o*d*b-n*p*b)+_*(+t*p*b-t*m*x+c*h*x-o*h*b+o*m*g-c*p*g)+w*(+t*m*y-t*d*b-c*h*y+n*h*b+c*d*g-n*m*g)+S*(-o*d*g-t*p*y+t*d*x+o*h*y-n*h*x+n*p*g)},transpose:function(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this},setPosition:function(e,t,n){const o=this.elements;return e.isVector3?(o[12]=e.x,o[13]=e.y,o[14]=e.z):(o[12]=e,o[13]=t,o[14]=n),this},getInverse:function(e,t){void 0!==t&&console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");const n=this.elements,o=e.elements,c=o[0],h=o[1],d=o[2],p=o[3],m=o[4],g=o[5],y=o[6],x=o[7],b=o[8],M=o[9],_=o[10],w=o[11],S=o[12],T=o[13],E=o[14],L=o[15],A=M*E*x-T*_*x+T*y*w-g*E*w-M*y*L+g*_*L,C=S*_*x-b*E*x-S*y*w+m*E*w+b*y*L-m*_*L,P=b*T*x-S*M*x+S*g*w-m*T*w-b*g*L+m*M*L,R=S*M*y-b*T*y-S*g*_+m*T*_+b*g*E-m*M*E,B=c*A+h*C+d*P+p*R;if(0===B)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/B;return n[0]=A*D,n[1]=(T*_*p-M*E*p-T*d*w+h*E*w+M*d*L-h*_*L)*D,n[2]=(g*E*p-T*y*p+T*d*x-h*E*x-g*d*L+h*y*L)*D,n[3]=(M*y*p-g*_*p-M*d*x+h*_*x+g*d*w-h*y*w)*D,n[4]=C*D,n[5]=(b*E*p-S*_*p+S*d*w-c*E*w-b*d*L+c*_*L)*D,n[6]=(S*y*p-m*E*p-S*d*x+c*E*x+m*d*L-c*y*L)*D,n[7]=(m*_*p-b*y*p+b*d*x-c*_*x-m*d*w+c*y*w)*D,n[8]=P*D,n[9]=(S*M*p-b*T*p-S*h*w+c*T*w+b*h*L-c*M*L)*D,n[10]=(m*T*p-S*g*p+S*h*x-c*T*x-m*h*L+c*g*L)*D,n[11]=(b*g*p-m*M*p-b*h*x+c*M*x+m*h*w-c*g*w)*D,n[12]=R*D,n[13]=(b*T*d-S*M*d+S*h*_-c*T*_-b*h*E+c*M*E)*D,n[14]=(S*g*d-m*T*d-S*h*y+c*T*y+m*h*E-c*g*E)*D,n[15]=(m*M*d-b*g*d+b*h*y-c*M*y-m*h*_+c*g*_)*D,this},scale:function(e){const t=this.elements,n=e.x,o=e.y,c=e.z;return t[0]*=n,t[4]*=o,t[8]*=c,t[1]*=n,t[5]*=o,t[9]*=c,t[2]*=n,t[6]*=o,t[10]*=c,t[3]*=n,t[7]*=o,t[11]*=c,this},getMaxScaleOnAxis:function(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],o=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,o))},makeTranslation:function(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this},makeRotationX:function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this},makeRotationY:function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this},makeRotationZ:function(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(e,t){const n=Math.cos(t),o=Math.sin(t),c=1-n,h=e.x,d=e.y,p=e.z,m=c*h,g=c*d;return this.set(m*h+n,m*d-o*p,m*p+o*d,0,m*d+o*p,g*d+n,g*p-o*h,0,m*p-o*d,g*p+o*h,c*p*p+n,0,0,0,0,1),this},makeScale:function(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this},makeShear:function(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this},compose:function(e,t,n){const o=this.elements,c=t._x,h=t._y,d=t._z,p=t._w,m=c+c,g=h+h,y=d+d,x=c*m,b=c*g,M=c*y,_=h*g,w=h*y,S=d*y,T=p*m,E=p*g,L=p*y,A=n.x,C=n.y,P=n.z;return o[0]=(1-(_+S))*A,o[1]=(b+L)*A,o[2]=(M-E)*A,o[3]=0,o[4]=(b-L)*C,o[5]=(1-(x+S))*C,o[6]=(w+T)*C,o[7]=0,o[8]=(M+E)*P,o[9]=(w-T)*P,o[10]=(1-(x+_))*P,o[11]=0,o[12]=e.x,o[13]=e.y,o[14]=e.z,o[15]=1,this},decompose:function(e,t,n){const o=this.elements;let c=Qn.set(o[0],o[1],o[2]).length(),h=Qn.set(o[4],o[5],o[6]).length(),d=Qn.set(o[8],o[9],o[10]).length();const p=this.determinant();p<0&&(c=-c),e.x=o[12],e.y=o[13],e.z=o[14],Kn.copy(this);const m=1/c,g=1/h,y=1/d;return Kn.elements[0]*=m,Kn.elements[1]*=m,Kn.elements[2]*=m,Kn.elements[4]*=g,Kn.elements[5]*=g,Kn.elements[6]*=g,Kn.elements[8]*=y,Kn.elements[9]*=y,Kn.elements[10]*=y,t.setFromRotationMatrix(Kn),n.x=c,n.y=h,n.z=d,this},makePerspective:function(e,t,n,o,c,h){void 0===h&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const d=this.elements,p=2*c/(t-e),m=2*c/(n-o),g=(t+e)/(t-e),y=(n+o)/(n-o),x=-(h+c)/(h-c),b=-2*h*c/(h-c);return d[0]=p,d[4]=0,d[8]=g,d[12]=0,d[1]=0,d[5]=m,d[9]=y,d[13]=0,d[2]=0,d[6]=0,d[10]=x,d[14]=b,d[3]=0,d[7]=0,d[11]=-1,d[15]=0,this},makeOrthographic:function(e,t,n,o,c,h){const d=this.elements,p=1/(t-e),m=1/(n-o),g=1/(h-c),y=(t+e)*p,x=(n+o)*m,b=(h+c)*g;return d[0]=2*p,d[4]=0,d[8]=0,d[12]=-y,d[1]=0,d[5]=2*m,d[9]=0,d[13]=-x,d[2]=0,d[6]=0,d[10]=-2*g,d[14]=-b,d[3]=0,d[7]=0,d[11]=0,d[15]=1,this},equals:function(e){const t=this.elements,n=e.elements;for(let o=0;o<16;o++)if(t[o]!==n[o])return!1;return!0},fromArray:function(e,t){void 0===t&&(t=0);for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}});const ir=new Matrix4,or=new Quaternion;function Euler(e=0,t=0,n=0,o=Euler.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=o}function Layers(){this.mask=1}Euler.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],Euler.DefaultOrder="XYZ",Object.defineProperties(Euler.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},order:{get:function(){return this._order},set:function(e){this._order=e,this._onChangeCallback()}}}),Object.assign(Euler.prototype,{isEuler:!0,set:function(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._order=o||this._order,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this},setFromRotationMatrix:function(e,t,n){const o=Wn.clamp,c=e.elements,h=c[0],d=c[4],p=c[8],m=c[1],g=c[5],y=c[9],x=c[2],b=c[6],M=c[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(o(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(-y,M),this._z=Math.atan2(-d,h)):(this._x=Math.atan2(b,g),this._z=0);break;case"YXZ":this._x=Math.asin(-o(y,-1,1)),Math.abs(y)<.9999999?(this._y=Math.atan2(p,M),this._z=Math.atan2(m,g)):(this._y=Math.atan2(-x,h),this._z=0);break;case"ZXY":this._x=Math.asin(o(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(-x,M),this._z=Math.atan2(-d,g)):(this._y=0,this._z=Math.atan2(m,h));break;case"ZYX":this._y=Math.asin(-o(x,-1,1)),Math.abs(x)<.9999999?(this._x=Math.atan2(b,M),this._z=Math.atan2(m,h)):(this._x=0,this._z=Math.atan2(-d,g));break;case"YZX":this._z=Math.asin(o(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(-y,g),this._y=Math.atan2(-x,h)):(this._x=0,this._y=Math.atan2(p,M));break;case"XZY":this._z=Math.asin(-o(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(b,g),this._y=Math.atan2(p,h)):(this._x=Math.atan2(-y,M),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==n&&this._onChangeCallback(),this},setFromQuaternion:function(e,t,n){return ir.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ir,t,n)},setFromVector3:function(e,t){return this.set(e.x,e.y,e.z,t||this._order)},reorder:function(e){return or.setFromEuler(this),this.setFromQuaternion(or,e)},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order},fromArray:function(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e},toVector3:function(e){return e?e.set(this._x,this._y,this._z):new Vector3(this._x,this._y,this._z)},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}}),Object.assign(Layers.prototype,{set:function(e){this.mask=1<<e|0},enable:function(e){this.mask|=1<<e|0},enableAll:function(){this.mask=-1},toggle:function(e){this.mask^=1<<e|0},disable:function(e){this.mask&=~(1<<e|0)},disableAll:function(){this.mask=0},test:function(e){return 0!==(this.mask&e.mask)}});let ar=0;const sr=new Vector3,cr=new Quaternion,lr=new Matrix4,ur=new Vector3,hr=new Vector3,dr=new Vector3,pr=new Quaternion,fr=new Vector3(1,0,0),mr=new Vector3(0,1,0),gr=new Vector3(0,0,1),yr={type:"added"},vr={type:"removed"};function Object3D(){Object.defineProperty(this,"id",{value:ar++}),this.uuid=Wn.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DefaultUp.clone();const e=new Vector3,t=new Euler,n=new Quaternion,o=new Vector3(1,1,1);function onRotationChange(){n.setFromEuler(t,!1)}function onQuaternionChange(){t.setFromQuaternion(n,void 0,!1)}t._onChange(onRotationChange),n._onChange(onQuaternionChange),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:o},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}function Scene(){Object3D.call(this),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Object3D.DefaultUp=new Vector3(0,1,0),Object3D.DefaultMatrixAutoUpdate=!0,Object3D.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Object3D,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return cr.setFromAxisAngle(e,t),this.quaternion.multiply(cr),this},rotateOnWorldAxis:function(e,t){return cr.setFromAxisAngle(e,t),this.quaternion.premultiply(cr),this},rotateX:function(e){return this.rotateOnAxis(fr,e)},rotateY:function(e){return this.rotateOnAxis(mr,e)},rotateZ:function(e){return this.rotateOnAxis(gr,e)},translateOnAxis:function(e,t){return sr.copy(e).applyQuaternion(this.quaternion),this.position.add(sr.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(fr,e)},translateY:function(e){return this.translateOnAxis(mr,e)},translateZ:function(e){return this.translateOnAxis(gr,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(lr.getInverse(this.matrixWorld))},lookAt:function(e,t,n){e.isVector3?ur.copy(e):ur.set(e,t,n);const o=this.parent;this.updateWorldMatrix(!0,!1),hr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?lr.lookAt(hr,ur,this.up):lr.lookAt(ur,hr,this.up),this.quaternion.setFromRotationMatrix(lr),o&&(lr.extractRotation(o.matrixWorld),cr.setFromRotationMatrix(lr),this.quaternion.premultiply(cr.inverse()))},add:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(yr)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(vr)),this},attach:function(e){return this.updateWorldMatrix(!0,!1),lr.getInverse(this.matrixWorld),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),lr.multiply(e.parent.matrixWorld)),e.applyMatrix4(lr),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,o=this.children.length;n<o;n++){const o=this.children[n],c=o.getObjectByProperty(e,t);if(void 0!==c)return c}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new Vector3),this.updateMatrixWorld(!0),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Quaternion),this.updateMatrixWorld(!0),this.matrixWorld.decompose(hr,e,dr),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new Vector3),this.updateMatrixWorld(!0),this.matrixWorld.decompose(hr,pr,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new Vector3),this.updateMatrixWorld(!0);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverse(e)},traverseVisible:function(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=void 0===e||"string"===typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const o={};function serialize(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(o.uuid=this.uuid,o.type=this.type,""!==this.name&&(o.name=this.name),!0===this.castShadow&&(o.castShadow=!0),!0===this.receiveShadow&&(o.receiveShadow=!0),!1===this.visible&&(o.visible=!1),!1===this.frustumCulled&&(o.frustumCulled=!1),0!==this.renderOrder&&(o.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){o.geometry=serialize(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,o=n.length;t<o;t++){const o=n[t];serialize(e.shapes,o)}else serialize(e.shapes,n)}}if(void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,o=this.material.length;n<o;n++)t.push(serialize(e.materials,this.material[n]));o.material=t}else o.material=serialize(e.materials,this.material);if(this.children.length>0){o.children=[];for(let t=0;t<this.children.length;t++)o.children.push(this.children[t].toJSON(e).object)}if(t){const t=extractFromCache(e.geometries),o=extractFromCache(e.materials),c=extractFromCache(e.textures),h=extractFromCache(e.images),d=extractFromCache(e.shapes);t.length>0&&(n.geometries=t),o.length>0&&(n.materials=o),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),d.length>0&&(n.shapes=d)}return n.object=o,n;function extractFromCache(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t){if(void 0===t&&(t=!0),this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let n=0;n<e.children.length;n++){const t=e.children[n];this.add(t.clone())}return this}}),Scene.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Scene,isScene:!0,copy:function(e,t){return Object3D.prototype.copy.call(this,e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t},dispose:function(){this.dispatchEvent({type:"dispose"})}});const xr=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],br=new Vector3,Mr=new Box3,_r=new Vector3,wr=new Vector3,Sr=new Vector3,Tr=new Vector3,Er=new Vector3,Lr=new Vector3,Ar=new Vector3,Cr=new Vector3,Pr=new Vector3,Rr=new Vector3;function Box3(e,t){this.min=void 0!==e?e:new Vector3(1/0,1/0,1/0),this.max=void 0!==t?t:new Vector3(-1/0,-1/0,-1/0)}function satForAxes(e,t,n,o,c){for(let h=0,d=e.length-3;h<=d;h+=3){Rr.fromArray(e,h);const d=c.x*Math.abs(Rr.x)+c.y*Math.abs(Rr.y)+c.z*Math.abs(Rr.z),p=t.dot(Rr),m=n.dot(Rr),g=o.dot(Rr);if(Math.max(-Math.max(p,m,g),Math.min(p,m,g))>d)return!1}return!0}Object.assign(Box3.prototype,{isBox3:!0,set:function(e,t){return this.min.copy(e),this.max.copy(t),this},setFromArray:function(e){let t=1/0,n=1/0,o=1/0,c=-1/0,h=-1/0,d=-1/0;for(let p=0,m=e.length;p<m;p+=3){const m=e[p],g=e[p+1],y=e[p+2];m<t&&(t=m),g<n&&(n=g),y<o&&(o=y),m>c&&(c=m),g>h&&(h=g),y>d&&(d=y)}return this.min.set(t,n,o),this.max.set(c,h,d),this},setFromBufferAttribute:function(e){let t=1/0,n=1/0,o=1/0,c=-1/0,h=-1/0,d=-1/0;for(let p=0,m=e.count;p<m;p++){const m=e.getX(p),g=e.getY(p),y=e.getZ(p);m<t&&(t=m),g<n&&(n=g),y<o&&(o=y),m>c&&(c=m),g>h&&(h=g),y>d&&(d=y)}return this.min.set(t,n,o),this.max.set(c,h,d),this},setFromPoints:function(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this},setFromCenterAndSize:function(e,t){const n=br.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this},setFromObject:function(e){return this.makeEmpty(),this.expandByObject(e)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Vector3),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Vector3),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},expandByObject:function(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),Mr.copy(t.boundingBox),Mr.applyMatrix4(e.matrixWorld),this.union(Mr));const n=e.children;for(let o=0,c=n.length;o<c;o++)this.expandByObject(n[o]);return this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z},getParameter:function(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Vector3),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)},intersectsSphere:function(e){return this.clampPoint(e.center,br),br.distanceToSquared(e.center)<=e.radius*e.radius},intersectsPlane:function(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant},intersectsTriangle:function(e){if(this.isEmpty())return!1;this.getCenter(Ar),Cr.subVectors(this.max,Ar),_r.subVectors(e.a,Ar),wr.subVectors(e.b,Ar),Sr.subVectors(e.c,Ar),Tr.subVectors(wr,_r),Er.subVectors(Sr,wr),Lr.subVectors(_r,Sr);let t=[0,-Tr.z,Tr.y,0,-Er.z,Er.y,0,-Lr.z,Lr.y,Tr.z,0,-Tr.x,Er.z,0,-Er.x,Lr.z,0,-Lr.x,-Tr.y,Tr.x,0,-Er.y,Er.x,0,-Lr.y,Lr.x,0];return!!satForAxes(t,_r,wr,Sr,Cr)&&(t=[1,0,0,0,1,0,0,0,1],!!satForAxes(t,_r,wr,Sr,Cr)&&(Pr.crossVectors(Tr,Er),t=[Pr.x,Pr.y,Pr.z],satForAxes(t,_r,wr,Sr,Cr)))},clampPoint:function(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Vector3),t.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){const t=br.copy(e).clamp(this.min,this.max);return t.sub(e).length()},getBoundingSphere:function(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(br).length(),e},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},applyMatrix4:function(e){return this.isEmpty()||(xr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),xr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),xr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),xr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),xr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),xr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),xr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),xr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(xr)),this},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});const Br=new Box3;function Sphere(e,t){this.center=void 0!==e?e:new Vector3,this.radius=void 0!==t?t:-1}Object.assign(Sphere.prototype,{set:function(e,t){return this.center.copy(e),this.radius=t,this},setFromPoints:function(e,t){const n=this.center;void 0!==t?n.copy(t):Br.setFromPoints(e).getCenter(n);let o=0;for(let c=0,h=e.length;c<h;c++)o=Math.max(o,n.distanceToSquared(e[c]));return this.radius=Math.sqrt(o),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.center.copy(e.center),this.radius=e.radius,this},isEmpty:function(){return this.radius<0},makeEmpty:function(){return this.center.set(0,0,0),this.radius=-1,this},containsPoint:function(e){return e.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(e){return e.distanceTo(this.center)-this.radius},intersectsSphere:function(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t},intersectsBox:function(e){return e.intersectsSphere(this)},intersectsPlane:function(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius},clampPoint:function(e,t){const n=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Vector3),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t},getBoundingBox:function(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Box3),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)},applyMatrix4:function(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this},translate:function(e){return this.center.add(e),this},equals:function(e){return e.center.equals(this.center)&&e.radius===this.radius}});const Dr=new Vector3,Gr=new Vector3,Ir=new Vector3,Or=new Vector3,Vr=new Vector3,Nr=new Vector3,Fr=new Vector3;function Ray(e,t){this.origin=void 0!==e?e:new Vector3,this.direction=void 0!==t?t:new Vector3(0,0,-1)}Object.assign(Ray.prototype,{set:function(e,t){return this.origin.copy(e),this.direction.copy(t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this},at:function(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new Vector3),t.copy(this.direction).multiplyScalar(e).add(this.origin)},lookAt:function(e){return this.direction.copy(e).sub(this.origin).normalize(),this},recast:function(e){return this.origin.copy(this.at(e,Dr)),this},closestPointToPoint:function(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Vector3),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)},distanceToPoint:function(e){return Math.sqrt(this.distanceSqToPoint(e))},distanceSqToPoint:function(e){const t=Dr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Dr.copy(this.direction).multiplyScalar(t).add(this.origin),Dr.distanceToSquared(e))},distanceSqToSegment:function(e,t,n,o){Gr.copy(e).add(t).multiplyScalar(.5),Ir.copy(t).sub(e).normalize(),Or.copy(this.origin).sub(Gr);const c=.5*e.distanceTo(t),h=-this.direction.dot(Ir),d=Or.dot(this.direction),p=-Or.dot(Ir),m=Or.lengthSq(),g=Math.abs(1-h*h);let y,x,b,M;if(g>0)if(y=h*p-d,x=h*d-p,M=c*g,y>=0)if(x>=-M)if(x<=M){const e=1/g;y*=e,x*=e,b=y*(y+h*x+2*d)+x*(h*y+x+2*p)+m}else x=c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;else x=-c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;else x<=-M?(y=Math.max(0,-(-h*c+d)),x=y>0?-c:Math.min(Math.max(-c,-p),c),b=-y*y+x*(x+2*p)+m):x<=M?(y=0,x=Math.min(Math.max(-c,-p),c),b=x*(x+2*p)+m):(y=Math.max(0,-(h*c+d)),x=y>0?c:Math.min(Math.max(-c,-p),c),b=-y*y+x*(x+2*p)+m);else x=h>0?-c:c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;return n&&n.copy(this.direction).multiplyScalar(y).add(this.origin),o&&o.copy(Ir).multiplyScalar(x).add(Gr),b},intersectSphere:function(e,t){Dr.subVectors(e.center,this.origin);const n=Dr.dot(this.direction),o=Dr.dot(Dr)-n*n,c=e.radius*e.radius;if(o>c)return null;const h=Math.sqrt(c-o),d=n-h,p=n+h;return d<0&&p<0?null:d<0?this.at(p,t):this.at(d,t)},intersectsSphere:function(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius},distanceToPlane:function(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null},intersectPlane:function(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)},intersectsPlane:function(e){const t=e.distanceToPoint(this.origin);if(0===t)return!0;const n=e.normal.dot(this.direction);return n*t<0},intersectBox:function(e,t){let n,o,c,h,d,p;const m=1/this.direction.x,g=1/this.direction.y,y=1/this.direction.z,x=this.origin;return m>=0?(n=(e.min.x-x.x)*m,o=(e.max.x-x.x)*m):(n=(e.max.x-x.x)*m,o=(e.min.x-x.x)*m),g>=0?(c=(e.min.y-x.y)*g,h=(e.max.y-x.y)*g):(c=(e.max.y-x.y)*g,h=(e.min.y-x.y)*g),n>h||c>o?null:((c>n||n!==n)&&(n=c),(h<o||o!==o)&&(o=h),y>=0?(d=(e.min.z-x.z)*y,p=(e.max.z-x.z)*y):(d=(e.max.z-x.z)*y,p=(e.min.z-x.z)*y),n>p||d>o?null:((d>n||n!==n)&&(n=d),(p<o||o!==o)&&(o=p),o<0?null:this.at(n>=0?n:o,t)))},intersectsBox:function(e){return null!==this.intersectBox(e,Dr)},intersectTriangle:function(e,t,n,o,c){Vr.subVectors(t,e),Nr.subVectors(n,e),Fr.crossVectors(Vr,Nr);let h,d=this.direction.dot(Fr);if(d>0){if(o)return null;h=1}else{if(!(d<0))return null;h=-1,d=-d}Or.subVectors(this.origin,e);const p=h*this.direction.dot(Nr.crossVectors(Or,Nr));if(p<0)return null;const m=h*this.direction.dot(Vr.cross(Or));if(m<0)return null;if(p+m>d)return null;const g=-h*Or.dot(Fr);return g<0?null:this.at(g/d,c)},applyMatrix4:function(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this},equals:function(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}});const Ur=new Vector3,zr=new Vector3,Hr=new Matrix3;function Plane(e,t){this.normal=void 0!==e?e:new Vector3(1,0,0),this.constant=void 0!==t?t:0}Object.assign(Plane.prototype,{isPlane:!0,set:function(e,t){return this.normal.copy(e),this.constant=t,this},setComponents:function(e,t,n,o){return this.normal.set(e,t,n),this.constant=o,this},setFromNormalAndCoplanarPoint:function(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this},setFromCoplanarPoints:function(e,t,n){const o=Ur.subVectors(n,t).cross(zr.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(o,e),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.normal.copy(e.normal),this.constant=e.constant,this},normalize:function(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(e){return this.normal.dot(e)+this.constant},distanceToSphere:function(e){return this.distanceToPoint(e.center)-e.radius},projectPoint:function(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Vector3),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)},intersectLine:function(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Vector3);const n=e.delta(Ur),o=this.normal.dot(n);if(0===o)return 0===this.distanceToPoint(e.start)?t.copy(e.start):void 0;const c=-(e.start.dot(this.normal)+this.constant)/o;return c<0||c>1?void 0:t.copy(n).multiplyScalar(c).add(e.start)},intersectsLine:function(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0},intersectsBox:function(e){return e.intersectsPlane(this)},intersectsSphere:function(e){return e.intersectsPlane(this)},coplanarPoint:function(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Vector3),e.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(e,t){const n=t||Hr.getNormalMatrix(e),o=this.coplanarPoint(Ur).applyMatrix4(e),c=this.normal.applyMatrix3(n).normalize();return this.constant=-o.dot(c),this},translate:function(e){return this.constant-=e.dot(this.normal),this},equals:function(e){return e.normal.equals(this.normal)&&e.constant===this.constant}});const kr=new Vector3,jr=new Vector3,Wr=new Vector3,qr=new Vector3,Xr=new Vector3,Yr=new Vector3,Zr=new Vector3,Jr=new Vector3,Qr=new Vector3,Kr=new Vector3;function Triangle(e,t,n){this.a=void 0!==e?e:new Vector3,this.b=void 0!==t?t:new Vector3,this.c=void 0!==n?n:new Vector3}Object.assign(Triangle,{getNormal:function(e,t,n,o){void 0===o&&(console.warn("THREE.Triangle: .getNormal() target is now required"),o=new Vector3),o.subVectors(n,t),kr.subVectors(e,t),o.cross(kr);const c=o.lengthSq();return c>0?o.multiplyScalar(1/Math.sqrt(c)):o.set(0,0,0)},getBarycoord:function(e,t,n,o,c){kr.subVectors(o,t),jr.subVectors(n,t),Wr.subVectors(e,t);const h=kr.dot(kr),d=kr.dot(jr),p=kr.dot(Wr),m=jr.dot(jr),g=jr.dot(Wr),y=h*m-d*d;if(void 0===c&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),c=new Vector3),0===y)return c.set(-2,-1,-1);const x=1/y,b=(m*p-d*g)*x,M=(h*g-d*p)*x;return c.set(1-b-M,M,b)},containsPoint:function(e,t,n,o){return Triangle.getBarycoord(e,t,n,o,qr),qr.x>=0&&qr.y>=0&&qr.x+qr.y<=1},getUV:function(e,t,n,o,c,h,d,p){return this.getBarycoord(e,t,n,o,qr),p.set(0,0),p.addScaledVector(c,qr.x),p.addScaledVector(h,qr.y),p.addScaledVector(d,qr.z),p},isFrontFacing:function(e,t,n,o){return kr.subVectors(n,t),jr.subVectors(e,t),kr.cross(jr).dot(o)<0}}),Object.assign(Triangle.prototype,{set:function(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this},setFromPointsAndIndices:function(e,t,n,o){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[o]),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this},getArea:function(){return kr.subVectors(this.c,this.b),jr.subVectors(this.a,this.b),.5*kr.cross(jr).length()},getMidpoint:function(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Vector3),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(e){return Triangle.getNormal(this.a,this.b,this.c,e)},getPlane:function(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Plane),e.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(e,t){return Triangle.getBarycoord(e,this.a,this.b,this.c,t)},getUV:function(e,t,n,o,c){return Triangle.getUV(e,this.a,this.b,this.c,t,n,o,c)},containsPoint:function(e){return Triangle.containsPoint(e,this.a,this.b,this.c)},isFrontFacing:function(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)},intersectsBox:function(e){return e.intersectsTriangle(this)},closestPointToPoint:function(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Vector3);const n=this.a,o=this.b,c=this.c;let h,d;Xr.subVectors(o,n),Yr.subVectors(c,n),Jr.subVectors(e,n);const p=Xr.dot(Jr),m=Yr.dot(Jr);if(p<=0&&m<=0)return t.copy(n);Qr.subVectors(e,o);const g=Xr.dot(Qr),y=Yr.dot(Qr);if(g>=0&&y<=g)return t.copy(o);const x=p*y-g*m;if(x<=0&&p>=0&&g<=0)return h=p/(p-g),t.copy(n).addScaledVector(Xr,h);Kr.subVectors(e,c);const b=Xr.dot(Kr),M=Yr.dot(Kr);if(M>=0&&b<=M)return t.copy(c);const _=b*m-p*M;if(_<=0&&m>=0&&M<=0)return d=m/(m-M),t.copy(n).addScaledVector(Yr,d);const w=g*M-b*y;if(w<=0&&y-g>=0&&b-M>=0)return Zr.subVectors(c,o),d=(y-g)/(y-g+(b-M)),t.copy(o).addScaledVector(Zr,d);const S=1/(w+_+x);return h=_*S,d=x*S,t.copy(n).addScaledVector(Xr,h).addScaledVector(Yr,d)},equals:function(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}});const $r={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ei={h:0,s:0,l:0},ti={h:0,s:0,l:0};function Color(e,t,n){return void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}function hue2rgb(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function SRGBToLinear(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function LinearToSRGB(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}function Face3(e,t,n,o,c,h){this.a=e,this.b=t,this.c=n,this.normal=o&&o.isVector3?o:new Vector3,this.vertexNormals=Array.isArray(o)?o:[],this.color=c&&c.isColor?c:new Color,this.vertexColors=Array.isArray(c)?c:[],this.materialIndex=void 0!==h?h:0}Object.assign(Color.prototype,{isColor:!0,r:1,g:1,b:1,set:function(e){return e&&e.isColor?this.copy(e):"number"===typeof e?this.setHex(e):"string"===typeof e&&this.setStyle(e),this},setScalar:function(e){return this.r=e,this.g=e,this.b=e,this},setHex:function(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this},setRGB:function(e,t,n){return this.r=e,this.g=t,this.b=n,this},setHSL:function(e,t,n){if(e=Wn.euclideanModulo(e,1),t=Wn.clamp(t,0,1),n=Wn.clamp(n,0,1),0===t)this.r=this.g=this.b=n;else{const o=n<=.5?n*(1+t):n+t-n*t,c=2*n-o;this.r=hue2rgb(c,o,e+1/3),this.g=hue2rgb(c,o,e),this.b=hue2rgb(c,o,e-1/3)}return this},setStyle:function(e){function handleAlpha(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let t;if(t=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){let e;const n=t[1],o=t[2];switch(n){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,handleAlpha(e[5]),this;if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,handleAlpha(e[5]),this;break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)){const t=parseFloat(e[1])/360,n=parseInt(e[2],10)/100,o=parseInt(e[3],10)/100;return handleAlpha(e[5]),this.setHSL(t,n,o)}break}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],n=e.length;if(3===n)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,this;if(6===n)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this},setColorName:function(e){const t=$r[e];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(e){return this.r=e.r,this.g=e.g,this.b=e.b,this},copyGammaToLinear:function(e,t){return void 0===t&&(t=2),this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this},copyLinearToGamma:function(e,t){void 0===t&&(t=2);const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this},convertGammaToLinear:function(e){return this.copyGammaToLinear(this,e),this},convertLinearToGamma:function(e){return this.copyLinearToGamma(this,e),this},copySRGBToLinear:function(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this},copyLinearToSRGB:function(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this},convertSRGBToLinear:function(){return this.copySRGBToLinear(this),this},convertLinearToSRGB:function(){return this.copyLinearToSRGB(this),this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,o=this.b,c=Math.max(t,n,o),h=Math.min(t,n,o);let d,p;const m=(h+c)/2;if(h===c)d=0,p=0;else{const e=c-h;switch(p=m<=.5?e/(c+h):e/(2-c-h),c){case t:d=(n-o)/e+(n<o?6:0);break;case n:d=(o-t)/e+2;break;case o:d=(t-n)/e+4;break}d/=6}return e.h=d,e.s=p,e.l=m,e},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(e,t,n){return this.getHSL(ei),ei.h+=e,ei.s+=t,ei.l+=n,this.setHSL(ei.h,ei.s,ei.l),this},add:function(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this},addColors:function(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this},addScalar:function(e){return this.r+=e,this.g+=e,this.b+=e,this},sub:function(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this},multiply:function(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this},multiplyScalar:function(e){return this.r*=e,this.g*=e,this.b*=e,this},lerp:function(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this},lerpHSL:function(e,t){this.getHSL(ei),e.getHSL(ti);const n=Wn.lerp(ei.h,ti.h,t),o=Wn.lerp(ei.s,ti.s,t),c=Wn.lerp(ei.l,ti.l,t);return this.setHSL(n,o,c),this},equals:function(e){return e.r===this.r&&e.g===this.g&&e.b===this.b},fromArray:function(e,t){return void 0===t&&(t=0),this.r=e[t],this.g=e[t+1],this.b=e[t+2],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e},fromBufferAttribute:function(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this},toJSON:function(){return this.getHex()}}),Color.NAMES=$r,Object.assign(Face3.prototype,{clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}});let ni=0;function Material(){Object.defineProperty(this,"id",{value:ni++}),this.uuid=Wn.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=P,this.side=S,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=j,this.blendDst=W,this.blendEquation=I,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=ee,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Gn,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=bn,this.stencilZFail=bn,this.stencilZPass=bn,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function MeshBasicMaterial(e){Material.call(this),this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oe,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Material.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Material,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===L;continue}const o=this[t];void 0!==o?o&&o.isColor?o.set(n):o&&o.isVector3&&n&&n.isVector3?o.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"===typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function extractFromCache(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==P&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),this.side!==S&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=extractFromCache(e.textures),o=extractFromCache(e.images);t.length>0&&(n.textures=t),o.length>0&&(n.images=o)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let o=0;o!==e;++o)n[o]=t[o].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Material.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),MeshBasicMaterial.prototype=Object.create(Material.prototype),MeshBasicMaterial.prototype.constructor=MeshBasicMaterial,MeshBasicMaterial.prototype.isMeshBasicMaterial=!0,MeshBasicMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const ri=new Vector3,ii=new Vector2;function BufferAttribute(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=In,this.updateRange={offset:0,count:-1},this.version=0}function Int8BufferAttribute(e,t,n){BufferAttribute.call(this,new Int8Array(e),t,n)}function Uint8BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint8Array(e),t,n)}function Uint8ClampedBufferAttribute(e,t,n){BufferAttribute.call(this,new Uint8ClampedArray(e),t,n)}function Int16BufferAttribute(e,t,n){BufferAttribute.call(this,new Int16Array(e),t,n)}function Uint16BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint16Array(e),t,n)}function Int32BufferAttribute(e,t,n){BufferAttribute.call(this,new Int32Array(e),t,n)}function Uint32BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint32Array(e),t,n)}function Float32BufferAttribute(e,t,n){BufferAttribute.call(this,new Float32Array(e),t,n)}function Float64BufferAttribute(e,t,n){BufferAttribute.call(this,new Float64Array(e),t,n)}function DirectGeometry(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}function arrayMax(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,o=e.length;n<o;++n)e[n]>t&&(t=e[n]);return t}Object.defineProperty(BufferAttribute.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(BufferAttribute.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let o=0,c=this.itemSize;o<c;o++)this.array[e+o]=t.array[n+o];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",o),c=new Color),t[n++]=c.r,t[n++]=c.g,t[n++]=c.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",o),c=new Vector2),t[n++]=c.x,t[n++]=c.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",o),c=new Vector3),t[n++]=c.x,t[n++]=c.y,t[n++]=c.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",o),c=new Vector4),t[n++]=c.x,t[n++]=c.y,t[n++]=c.z,t[n++]=c.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)ii.fromBufferAttribute(this,t),ii.applyMatrix3(e),this.setXY(t,ii.x,ii.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)ri.fromBufferAttribute(this,t),ri.applyMatrix3(e),this.setXYZ(t,ri.x,ri.y,ri.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)ri.x=this.getX(t),ri.y=this.getY(t),ri.z=this.getZ(t),ri.applyMatrix4(e),this.setXYZ(t,ri.x,ri.y,ri.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)ri.x=this.getX(t),ri.y=this.getY(t),ri.z=this.getZ(t),ri.applyNormalMatrix(e),this.setXYZ(t,ri.x,ri.y,ri.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)ri.x=this.getX(t),ri.y=this.getY(t),ri.z=this.getZ(t),ri.transformDirection(e),this.setXYZ(t,ri.x,ri.y,ri.z);return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this},setXYZW:function(e,t,n,o,c){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this.array[e+3]=c,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int8BufferAttribute.prototype.constructor=Int8BufferAttribute,Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute,Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute,Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int16BufferAttribute.prototype.constructor=Int16BufferAttribute,Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute,Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int32BufferAttribute.prototype.constructor=Int32BufferAttribute,Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute,Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Float32BufferAttribute.prototype.constructor=Float32BufferAttribute,Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Float64BufferAttribute.prototype.constructor=Float64BufferAttribute,Object.assign(DirectGeometry.prototype,{computeGroups:function(e){const t=[];let n,o,c=void 0;const h=e.faces;for(o=0;o<h.length;o++){const e=h[o];e.materialIndex!==c&&(c=e.materialIndex,void 0!==n&&(n.count=3*o-n.start,t.push(n)),n={start:3*o,materialIndex:c})}void 0!==n&&(n.count=3*o-n.start,t.push(n)),this.groups=t},fromGeometry:function(e){const t=e.faces,n=e.vertices,o=e.faceVertexUvs,c=o[0]&&o[0].length>0,h=o[1]&&o[1].length>0,d=e.morphTargets,p=d.length;let m;if(p>0){m=[];for(let e=0;e<p;e++)m[e]={name:d[e].name,data:[]};this.morphTargets.position=m}const g=e.morphNormals,y=g.length;let x;if(y>0){x=[];for(let e=0;e<y;e++)x[e]={name:g[e].name,data:[]};this.morphTargets.normal=x}const b=e.skinIndices,M=e.skinWeights,_=b.length===n.length,w=M.length===n.length;n.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let S=0;S<t.length;S++){const e=t[S];this.vertices.push(n[e.a],n[e.b],n[e.c]);const T=e.vertexNormals;if(3===T.length)this.normals.push(T[0],T[1],T[2]);else{const t=e.normal;this.normals.push(t,t,t)}const E=e.vertexColors;if(3===E.length)this.colors.push(E[0],E[1],E[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===c){const e=o[0][S];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",S),this.uvs.push(new Vector2,new Vector2,new Vector2))}if(!0===h){const e=o[1][S];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",S),this.uvs2.push(new Vector2,new Vector2,new Vector2))}for(let t=0;t<p;t++){const n=d[t].vertices;m[t].data.push(n[e.a],n[e.b],n[e.c])}for(let t=0;t<y;t++){const e=g[t].vertexNormals[S];x[t].data.push(e.a,e.b,e.c)}_&&this.skinIndices.push(b[e.a],b[e.b],b[e.c]),w&&this.skinWeights.push(M[e.a],M[e.b],M[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}});let oi=1;const ai=new Matrix4,si=new Object3D,ci=new Vector3,li=new Box3,ui=new Box3,hi=new Vector3;function BufferGeometry(){Object.defineProperty(this,"id",{value:oi+=2}),this.uuid=Wn.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}BufferGeometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:BufferGeometry,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){Array.isArray(e)?this.index=new(arrayMax(e)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},addGroup:function(e,t,n){this.groups.push({start:e,count:t,materialIndex:void 0!==n?n:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new Matrix3).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(e),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return ai.makeRotationX(e),this.applyMatrix4(ai),this},rotateY:function(e){return ai.makeRotationY(e),this.applyMatrix4(ai),this},rotateZ:function(e){return ai.makeRotationZ(e),this.applyMatrix4(ai),this},translate:function(e,t,n){return ai.makeTranslation(e,t,n),this.applyMatrix4(ai),this},scale:function(e,t,n){return ai.makeScale(e,t,n),this.applyMatrix4(ai),this},lookAt:function(e){return si.lookAt(e),si.updateMatrix(),this.applyMatrix4(si.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(ci).negate(),this.translate(ci.x,ci.y,ci.z),this},setFromObject:function(e){const t=e.geometry;if(e.isPoints||e.isLine){const e=new Float32BufferAttribute(3*t.vertices.length,3),n=new Float32BufferAttribute(3*t.colors.length,3);if(this.setAttribute("position",e.copyVector3sArray(t.vertices)),this.setAttribute("color",n.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){const e=new Float32BufferAttribute(t.lineDistances.length,1);this.setAttribute("lineDistance",e.copyArray(t.lineDistances))}null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n];t.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new Float32BufferAttribute(t,3)),this},updateFromObject:function(e){let t=e.geometry;if(e.isMesh){let e=t.__directGeometry;if(!0===t.elementsNeedUpdate&&(e=void 0,t.elementsNeedUpdate=!1),void 0===e)return this.fromGeometry(t);e.verticesNeedUpdate=t.verticesNeedUpdate,e.normalsNeedUpdate=t.normalsNeedUpdate,e.colorsNeedUpdate=t.colorsNeedUpdate,e.uvsNeedUpdate=t.uvsNeedUpdate,e.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=e}if(!0===t.verticesNeedUpdate){const e=this.attributes.position;void 0!==e&&(e.copyVector3sArray(t.vertices),e.needsUpdate=!0),t.verticesNeedUpdate=!1}if(!0===t.normalsNeedUpdate){const e=this.attributes.normal;void 0!==e&&(e.copyVector3sArray(t.normals),e.needsUpdate=!0),t.normalsNeedUpdate=!1}if(!0===t.colorsNeedUpdate){const e=this.attributes.color;void 0!==e&&(e.copyColorsArray(t.colors),e.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){const e=this.attributes.uv;void 0!==e&&(e.copyVector2sArray(t.uvs),e.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){const e=this.attributes.lineDistance;void 0!==e&&(e.copyArray(t.lineDistances),e.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=(new DirectGeometry).fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const t=new Float32Array(3*e.vertices.length);if(this.setAttribute("position",new BufferAttribute(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){const t=new Float32Array(3*e.normals.length);this.setAttribute("normal",new BufferAttribute(t,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const t=new Float32Array(3*e.colors.length);this.setAttribute("color",new BufferAttribute(t,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const t=new Float32Array(2*e.uvs.length);this.setAttribute("uv",new BufferAttribute(t,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const t=new Float32Array(2*e.uvs2.length);this.setAttribute("uv2",new BufferAttribute(t,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const n in e.morphTargets){const t=[],o=e.morphTargets[n];for(let e=0,n=o.length;e<n;e++){const n=o[e],c=new Float32BufferAttribute(3*n.data.length,3);c.name=n.name,t.push(c.copyVector3sArray(n.data))}this.morphAttributes[n]=t}if(e.skinIndices.length>0){const t=new Float32BufferAttribute(4*e.skinIndices.length,4);this.setAttribute("skinIndex",t.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const t=new Float32BufferAttribute(4*e.skinWeights.length,4);this.setAttribute("skinWeight",t.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3);const e=this.attributes.position,t=this.morphAttributes.position;if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,o=t.length;n<o;n++){const e=t[n];li.setFromBufferAttribute(e),this.morphTargetsRelative?(hi.addVectors(this.boundingBox.min,li.min),this.boundingBox.expandByPoint(hi),hi.addVectors(this.boundingBox.max,li.max),this.boundingBox.expandByPoint(hi)):(this.boundingBox.expandByPoint(li.min),this.boundingBox.expandByPoint(li.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const e=this.attributes.position,t=this.morphAttributes.position;if(e){const n=this.boundingSphere.center;if(li.setFromBufferAttribute(e),t)for(let e=0,c=t.length;e<c;e++){const n=t[e];ui.setFromBufferAttribute(n),this.morphTargetsRelative?(hi.addVectors(li.min,ui.min),li.expandByPoint(hi),hi.addVectors(li.max,ui.max),li.expandByPoint(hi)):(li.expandByPoint(ui.min),li.expandByPoint(ui.max))}li.getCenter(n);let o=0;for(let t=0,c=e.count;t<c;t++)hi.fromBufferAttribute(e,t),o=Math.max(o,n.distanceToSquared(hi));if(t)for(let c=0,h=t.length;c<h;c++){const h=t[c],d=this.morphTargetsRelative;for(let t=0,c=h.count;t<c;t++)hi.fromBufferAttribute(h,t),d&&(ci.fromBufferAttribute(e,t),hi.add(ci)),o=Math.max(o,n.distanceToSquared(hi))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new BufferAttribute(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const o=new Vector3,c=new Vector3,h=new Vector3,d=new Vector3,p=new Vector3,m=new Vector3,g=new Vector3,y=new Vector3;if(e)for(let x=0,b=e.count;x<b;x+=3){const b=e.getX(x+0),M=e.getX(x+1),_=e.getX(x+2);o.fromBufferAttribute(t,b),c.fromBufferAttribute(t,M),h.fromBufferAttribute(t,_),g.subVectors(h,c),y.subVectors(o,c),g.cross(y),d.fromBufferAttribute(n,b),p.fromBufferAttribute(n,M),m.fromBufferAttribute(n,_),d.add(g),p.add(g),m.add(g),n.setXYZ(b,d.x,d.y,d.z),n.setXYZ(M,p.x,p.y,p.z),n.setXYZ(_,m.x,m.y,m.z)}else for(let e=0,x=t.count;e<x;e+=3)o.fromBufferAttribute(t,e+0),c.fromBufferAttribute(t,e+1),h.fromBufferAttribute(t,e+2),g.subVectors(h,c),y.subVectors(o,c),g.cross(y),n.setXYZ(e+0,g.x,g.y,g.z),n.setXYZ(e+1,g.x,g.y,g.z),n.setXYZ(e+2,g.x,g.y,g.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===e.attributes[o])continue;const c=n[o],h=c.array,d=e.attributes[o],p=d.array,m=d.itemSize*t,g=Math.min(p.length,h.length-m);for(let e=0,t=m;e<g;e++,t++)h[t]=p[e]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)hi.fromBufferAttribute(e,t),hi.normalize(),e.setXYZ(t,hi.x,hi.y,hi.z)},toNonIndexed:function(){function convertBufferAttribute(e,t){const n=e.array,o=e.itemSize,c=e.normalized,h=new n.constructor(t.length*o);let d=0,p=0;for(let m=0,g=t.length;m<g;m++){d=t[m]*o;for(let e=0;e<o;e++)h[p++]=n[d++]}return new BufferAttribute(h,o,c)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const e=new BufferGeometry,t=this.index.array,n=this.attributes;for(const h in n){const o=n[h],c=convertBufferAttribute(o,t);e.setAttribute(h,c)}const o=this.morphAttributes;for(const h in o){const n=[],c=o[h];for(let e=0,o=c.length;e<o;e++){const o=c[e],h=convertBufferAttribute(o,t);n.push(h)}e.morphAttributes[h]=n}e.morphTargetsRelative=this.morphTargetsRelative;const c=this.groups;for(let h=0,d=c.length;h<d;h++){const t=c[h];e.addGroup(t.start,t.count,t.materialIndex)}return e},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const p in n){const t=n[p],o=t.toJSON(e.data);""!==t.name&&(o.name=t.name),e.data.attributes[p]=o}const o={};let c=!1;for(const p in this.morphAttributes){const t=this.morphAttributes[p],n=[];for(let o=0,c=t.length;o<c;o++){const c=t[o],h=c.toJSON(e.data);""!==c.name&&(h.name=c.name),n.push(h)}n.length>0&&(o[p]=n,c=!0)}c&&(e.data.morphAttributes=o,e.data.morphTargetsRelative=this.morphTargetsRelative);const h=this.groups;h.length>0&&(e.data.groups=JSON.parse(JSON.stringify(h)));const d=this.boundingSphere;return null!==d&&(e.data.boundingSphere={center:d.center.toArray(),radius:d.radius}),e},clone:function(){return(new BufferGeometry).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const o=e.attributes;for(const m in o){const e=o[m];this.setAttribute(m,e.clone(t))}const c=e.morphAttributes;for(const m in c){const e=[],n=c[m];for(let o=0,c=n.length;o<c;o++)e.push(n[o].clone(t));this.morphAttributes[m]=e}this.morphTargetsRelative=e.morphTargetsRelative;const h=e.groups;for(let m=0,g=h.length;m<g;m++){const e=h[m];this.addGroup(e.start,e.count,e.materialIndex)}const d=e.boundingBox;null!==d&&(this.boundingBox=d.clone());const p=e.boundingSphere;return null!==p&&(this.boundingSphere=p.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const di=new Matrix4,pi=new Ray,fi=new Sphere,mi=new Vector3,gi=new Vector3,yi=new Vector3,vi=new Vector3,xi=new Vector3,bi=new Vector3,Mi=new Vector3,_i=new Vector3,wi=new Vector3,Si=new Vector2,Ti=new Vector2,Ei=new Vector2,Li=new Vector3,Ai=new Vector3;function Mesh(e,t){Object3D.call(this),this.type="Mesh",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new MeshBasicMaterial,this.updateMorphTargets()}function checkIntersection(e,t,n,o,c,h,d,p){let m;if(m=t.side===T?o.intersectTriangle(d,h,c,!0,p):o.intersectTriangle(c,h,d,t.side!==E,p),null===m)return null;Ai.copy(p),Ai.applyMatrix4(e.matrixWorld);const g=n.ray.origin.distanceTo(Ai);return g<n.near||g>n.far?null:{distance:g,point:Ai.clone(),object:e}}function checkBufferGeometryIntersection(e,t,n,o,c,h,d,p,m,g,y,x){mi.fromBufferAttribute(c,g),gi.fromBufferAttribute(c,y),yi.fromBufferAttribute(c,x);const b=e.morphTargetInfluences;if(t.morphTargets&&h&&b){Mi.set(0,0,0),_i.set(0,0,0),wi.set(0,0,0);for(let e=0,t=h.length;e<t;e++){const t=b[e],n=h[e];0!==t&&(vi.fromBufferAttribute(n,g),xi.fromBufferAttribute(n,y),bi.fromBufferAttribute(n,x),d?(Mi.addScaledVector(vi,t),_i.addScaledVector(xi,t),wi.addScaledVector(bi,t)):(Mi.addScaledVector(vi.sub(mi),t),_i.addScaledVector(xi.sub(gi),t),wi.addScaledVector(bi.sub(yi),t)))}mi.add(Mi),gi.add(_i),yi.add(wi)}e.isSkinnedMesh&&(e.boneTransform(g,mi),e.boneTransform(y,gi),e.boneTransform(x,yi));const M=checkIntersection(e,t,n,o,mi,gi,yi,Li);if(M){p&&(Si.fromBufferAttribute(p,g),Ti.fromBufferAttribute(p,y),Ei.fromBufferAttribute(p,x),M.uv=Triangle.getUV(Li,mi,gi,yi,Si,Ti,Ei,new Vector2)),m&&(Si.fromBufferAttribute(m,g),Ti.fromBufferAttribute(m,y),Ei.fromBufferAttribute(m,x),M.uv2=Triangle.getUV(Li,mi,gi,yi,Si,Ti,Ei,new Vector2));const e=new Face3(g,y,x);Triangle.getNormal(mi,gi,yi,e.normal),M.face=e}return M}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,o=this.material,c=this.matrixWorld;if(void 0===o)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),fi.copy(n.boundingSphere),fi.applyMatrix4(c),!1===e.ray.intersectsSphere(fi))return;if(di.getInverse(c),pi.copy(e.ray).applyMatrix4(di),null!==n.boundingBox&&!1===pi.intersectsBox(n.boundingBox))return;let h;if(n.isBufferGeometry){const c=n.index,d=n.attributes.position,p=n.morphAttributes.position,m=n.morphTargetsRelative,g=n.attributes.uv,y=n.attributes.uv2,x=n.groups,b=n.drawRange;if(null!==c)if(Array.isArray(o))for(let n=0,M=x.length;n<M;n++){const M=x[n],_=o[M.materialIndex],w=Math.max(M.start,b.start),S=Math.min(M.start+M.count,b.start+b.count);for(let n=w,o=S;n<o;n+=3){const o=c.getX(n),x=c.getX(n+1),b=c.getX(n+2);h=checkBufferGeometryIntersection(this,_,e,pi,d,p,m,g,y,o,x,b),h&&(h.faceIndex=Math.floor(n/3),h.face.materialIndex=M.materialIndex,t.push(h))}}else{const n=Math.max(0,b.start),x=Math.min(c.count,b.start+b.count);for(let b=n,M=x;b<M;b+=3){const n=c.getX(b),x=c.getX(b+1),M=c.getX(b+2);h=checkBufferGeometryIntersection(this,o,e,pi,d,p,m,g,y,n,x,M),h&&(h.faceIndex=Math.floor(b/3),t.push(h))}}else if(void 0!==d)if(Array.isArray(o))for(let n=0,M=x.length;n<M;n++){const c=x[n],M=o[c.materialIndex],_=Math.max(c.start,b.start),w=Math.min(c.start+c.count,b.start+b.count);for(let n=_,o=w;n<o;n+=3){const o=n,x=n+1,b=n+2;h=checkBufferGeometryIntersection(this,M,e,pi,d,p,m,g,y,o,x,b),h&&(h.faceIndex=Math.floor(n/3),h.face.materialIndex=c.materialIndex,t.push(h))}}else{const n=Math.max(0,b.start),c=Math.min(d.count,b.start+b.count);for(let x=n,b=c;x<b;x+=3){const n=x,c=x+1,b=x+2;h=checkBufferGeometryIntersection(this,o,e,pi,d,p,m,g,y,n,c,b),h&&(h.faceIndex=Math.floor(x/3),t.push(h))}}}else if(n.isGeometry){const c=Array.isArray(o),d=n.vertices,p=n.faces;let m;const g=n.faceVertexUvs[0];g.length>0&&(m=g);for(let n=0,y=p.length;n<y;n++){const g=p[n],y=c?o[g.materialIndex]:o;if(void 0===y)continue;const x=d[g.a],b=d[g.b],M=d[g.c];if(h=checkIntersection(this,y,e,pi,x,b,M,Li),h){if(m&&m[n]){const e=m[n];Si.copy(e[0]),Ti.copy(e[1]),Ei.copy(e[2]),h.uv=Triangle.getUV(Li,x,b,M,Si,Ti,Ei,new Vector2)}h.face=g,h.faceIndex=n,t.push(h)}}}}});let Ci=0;const Pi=new Matrix4,Ri=new Object3D,Bi=new Vector3;function Geometry(){Object.defineProperty(this,"id",{value:Ci+=2}),this.uuid=Wn.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Geometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Geometry,isGeometry:!0,applyMatrix4:function(e){const t=(new Matrix3).getNormalMatrix(e);for(let n=0,o=this.vertices.length;n<o;n++){const t=this.vertices[n];t.applyMatrix4(e)}for(let n=0,o=this.faces.length;n<o;n++){const e=this.faces[n];e.normal.applyMatrix3(t).normalize();for(let n=0,o=e.vertexNormals.length;n<o;n++)e.vertexNormals[n].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Pi.makeRotationX(e),this.applyMatrix4(Pi),this},rotateY:function(e){return Pi.makeRotationY(e),this.applyMatrix4(Pi),this},rotateZ:function(e){return Pi.makeRotationZ(e),this.applyMatrix4(Pi),this},translate:function(e,t,n){return Pi.makeTranslation(e,t,n),this.applyMatrix4(Pi),this},scale:function(e,t,n){return Pi.makeScale(e,t,n),this.applyMatrix4(Pi),this},lookAt:function(e){return Ri.lookAt(e),Ri.updateMatrix(),this.applyMatrix4(Ri.matrix),this},fromBufferGeometry:function(e){const t=this,n=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const c=o.position,h=o.normal,d=o.color,p=o.uv,m=o.uv2;void 0!==m&&(this.faceVertexUvs[1]=[]);for(let y=0;y<c.count;y++)t.vertices.push((new Vector3).fromBufferAttribute(c,y)),void 0!==d&&t.colors.push((new Color).fromBufferAttribute(d,y));function addFace(e,n,o,c){const g=void 0===d?[]:[t.colors[e].clone(),t.colors[n].clone(),t.colors[o].clone()],y=void 0===h?[]:[(new Vector3).fromBufferAttribute(h,e),(new Vector3).fromBufferAttribute(h,n),(new Vector3).fromBufferAttribute(h,o)],x=new Face3(e,n,o,y,g,c);t.faces.push(x),void 0!==p&&t.faceVertexUvs[0].push([(new Vector2).fromBufferAttribute(p,e),(new Vector2).fromBufferAttribute(p,n),(new Vector2).fromBufferAttribute(p,o)]),void 0!==m&&t.faceVertexUvs[1].push([(new Vector2).fromBufferAttribute(m,e),(new Vector2).fromBufferAttribute(m,n),(new Vector2).fromBufferAttribute(m,o)])}const g=e.groups;if(g.length>0)for(let y=0;y<g.length;y++){const e=g[y],t=e.start,o=e.count;for(let c=t,h=t+o;c<h;c+=3)void 0!==n?addFace(n.getX(c),n.getX(c+1),n.getX(c+2),e.materialIndex):addFace(c,c+1,c+2,e.materialIndex)}else if(void 0!==n)for(let y=0;y<n.count;y+=3)addFace(n.getX(y),n.getX(y+1),n.getX(y+2));else for(let y=0;y<c.count;y+=3)addFace(y,y+1,y+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Bi).negate(),this.translate(Bi.x,Bi.y,Bi.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=0===t?1:1/t,o=new Matrix4;return o.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){const e=new Vector3,t=new Vector3;for(let n=0,o=this.faces.length;n<o;n++){const o=this.faces[n],c=this.vertices[o.a],h=this.vertices[o.b],d=this.vertices[o.c];e.subVectors(d,h),t.subVectors(c,h),e.cross(t),e.normalize(),o.normal.copy(e)}},computeVertexNormals:function(e){void 0===e&&(e=!0);const t=new Array(this.vertices.length);for(let n=0,o=this.vertices.length;n<o;n++)t[n]=new Vector3;if(e){const e=new Vector3,n=new Vector3;for(let o=0,c=this.faces.length;o<c;o++){const c=this.faces[o],h=this.vertices[c.a],d=this.vertices[c.b],p=this.vertices[c.c];e.subVectors(p,d),n.subVectors(h,d),e.cross(n),t[c.a].add(e),t[c.b].add(e),t[c.c].add(e)}}else{this.computeFaceNormals();for(let e=0,n=this.faces.length;e<n;e++){const n=this.faces[e];t[n.a].add(n.normal),t[n.b].add(n.normal),t[n.c].add(n.normal)}}for(let n=0,o=this.vertices.length;n<o;n++)t[n].normalize();for(let n=0,o=this.faces.length;n<o;n++){const e=this.faces[n],o=e.vertexNormals;3===o.length?(o[0].copy(t[e.a]),o[1].copy(t[e.b]),o[2].copy(t[e.c])):(o[0]=t[e.a].clone(),o[1]=t[e.b].clone(),o[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],n=t.vertexNormals;3===n.length?(n[0].copy(t.normal),n[1].copy(t.normal),n[2].copy(t.normal)):(n[0]=t.normal.clone(),n[1]=t.normal.clone(),n[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,n=this.faces.length;t<n;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,n=e.vertexNormals.length;t<n;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new Geometry;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,n=this.morphNormals[t].vertexNormals;for(let t=0,o=this.faces.length;t<o;t++){const t=new Vector3,o={a:new Vector3,b:new Vector3,c:new Vector3};e.push(t),n.push(o)}}const n=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=n.faceNormals[e],c=n.vertexNormals[e];o.copy(t.normal),c.a.copy(t.vertexNormals[0]),c.b.copy(t.vertexNormals[1]),c.c.copy(t.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,n){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let o,c=this.vertices.length,h=this.vertices,d=e.vertices,p=this.faces,m=e.faces,g=this.colors,y=e.colors;void 0===n&&(n=0),void 0!==t&&(o=(new Matrix3).getNormalMatrix(t));for(let x=0,b=d.length;x<b;x++){const e=d[x],n=e.clone();void 0!==t&&n.applyMatrix4(t),h.push(n)}for(let x=0,b=y.length;x<b;x++)g.push(y[x].clone());for(let x=0,b=m.length;x<b;x++){let e,t,h,d=m[x],g=d.vertexNormals,y=d.vertexColors;e=new Face3(d.a+c,d.b+c,d.c+c),e.normal.copy(d.normal),void 0!==o&&e.normal.applyMatrix3(o).normalize();for(let n=0,c=g.length;n<c;n++)t=g[n].clone(),void 0!==o&&t.applyMatrix3(o).normalize(),e.vertexNormals.push(t);e.color.copy(d.color);for(let n=0,o=y.length;n<o;n++)h=y[n],e.vertexColors.push(h.clone());e.materialIndex=d.materialIndex+n,p.push(e)}for(let x=0,b=e.faceVertexUvs.length;x<b;x++){const t=e.faceVertexUvs[x];void 0===this.faceVertexUvs[x]&&(this.faceVertexUvs[x]=[]);for(let e=0,n=t.length;e<n;e++){const n=t[e],o=[];for(let e=0,t=n.length;e<t;e++)o.push(n[e].clone());this.faceVertexUvs[x].push(o)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(){const e={},t=[],n=[],o=4,c=Math.pow(10,o);for(let p=0,m=this.vertices.length;p<m;p++){const o=this.vertices[p],h=Math.round(o.x*c)+"_"+Math.round(o.y*c)+"_"+Math.round(o.z*c);void 0===e[h]?(e[h]=p,t.push(this.vertices[p]),n[p]=t.length-1):n[p]=n[e[h]]}const h=[];for(let p=0,m=this.faces.length;p<m;p++){const e=this.faces[p];e.a=n[e.a],e.b=n[e.b],e.c=n[e.c];const t=[e.a,e.b,e.c];for(let n=0;n<3;n++)if(t[n]===t[(n+1)%3]){h.push(p);break}}for(let p=h.length-1;p>=0;p--){const e=h[p];this.faces.splice(e,1);for(let t=0,n=this.faceVertexUvs.length;t<n;t++)this.faceVertexUvs[t].splice(e,1)}const d=this.vertices.length-t.length;return this.vertices=t,d},setFromPoints:function(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];this.vertices.push(new Vector3(n.x,n.y,n.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let d=0;d<t;d++)e[d]._id=d;function materialIndexSort(e,t){return e.materialIndex-t.materialIndex}e.sort(materialIndexSort);const n=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let c,h;n&&n.length===t&&(c=[]),o&&o.length===t&&(h=[]);for(let d=0;d<t;d++){const t=e[d]._id;c&&c.push(n[t]),h&&h.push(o[t])}c&&(this.faceVertexUvs[0]=c),h&&(this.faceVertexUvs[1]=h)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}const t=[];for(let g=0;g<this.vertices.length;g++){const e=this.vertices[g];t.push(e.x,e.y,e.z)}const n=[],o=[],c={},h=[],d={},p=[],m={};for(let g=0;g<this.faces.length;g++){const e=this.faces[g],t=!0,o=!1,c=void 0!==this.faceVertexUvs[0][g],h=e.normal.length()>0,d=e.vertexNormals.length>0,p=1!==e.color.r||1!==e.color.g||1!==e.color.b,m=e.vertexColors.length>0;let y=0;if(y=setBit(y,0,0),y=setBit(y,1,t),y=setBit(y,2,o),y=setBit(y,3,c),y=setBit(y,4,h),y=setBit(y,5,d),y=setBit(y,6,p),y=setBit(y,7,m),n.push(y),n.push(e.a,e.b,e.c),n.push(e.materialIndex),c){const e=this.faceVertexUvs[0][g];n.push(getUvIndex(e[0]),getUvIndex(e[1]),getUvIndex(e[2]))}if(h&&n.push(getNormalIndex(e.normal)),d){const t=e.vertexNormals;n.push(getNormalIndex(t[0]),getNormalIndex(t[1]),getNormalIndex(t[2]))}if(p&&n.push(getColorIndex(e.color)),m){const t=e.vertexColors;n.push(getColorIndex(t[0]),getColorIndex(t[1]),getColorIndex(t[2]))}}function setBit(e,t,n){return n?e|1<<t:e&~(1<<t)}function getNormalIndex(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==c[t]||(c[t]=o.length/3,o.push(e.x,e.y,e.z)),c[t]}function getColorIndex(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==d[t]||(d[t]=h.length,h.push(e.getHex())),d[t]}function getUvIndex(e){const t=e.x.toString()+e.y.toString();return void 0!==m[t]||(m[t]=p.length/2,p.push(e.x,e.y)),m[t]}return e.data={},e.data.vertices=t,e.data.normals=o,h.length>0&&(e.data.colors=h),p.length>0&&(e.data.uvs=[p]),e.data.faces=n,e},clone:function(){return(new Geometry).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let x=0,b=t.length;x<b;x++)this.vertices.push(t[x].clone());const n=e.colors;for(let x=0,b=n.length;x<b;x++)this.colors.push(n[x].clone());const o=e.faces;for(let x=0,b=o.length;x<b;x++)this.faces.push(o[x].clone());for(let x=0,b=e.faceVertexUvs.length;x<b;x++){const t=e.faceVertexUvs[x];void 0===this.faceVertexUvs[x]&&(this.faceVertexUvs[x]=[]);for(let e=0,n=t.length;e<n;e++){const n=t[e],o=[];for(let e=0,t=n.length;e<t;e++){const t=n[e];o.push(t.clone())}this.faceVertexUvs[x].push(o)}}const c=e.morphTargets;for(let x=0,b=c.length;x<b;x++){const e={};if(e.name=c[x].name,void 0!==c[x].vertices){e.vertices=[];for(let t=0,n=c[x].vertices.length;t<n;t++)e.vertices.push(c[x].vertices[t].clone())}if(void 0!==c[x].normals){e.normals=[];for(let t=0,n=c[x].normals.length;t<n;t++)e.normals.push(c[x].normals[t].clone())}this.morphTargets.push(e)}const h=e.morphNormals;for(let x=0,b=h.length;x<b;x++){const e={};if(void 0!==h[x].vertexNormals){e.vertexNormals=[];for(let t=0,n=h[x].vertexNormals.length;t<n;t++){const n=h[x].vertexNormals[t],o={};o.a=n.a.clone(),o.b=n.b.clone(),o.c=n.c.clone(),e.vertexNormals.push(o)}}if(void 0!==h[x].faceNormals){e.faceNormals=[];for(let t=0,n=h[x].faceNormals.length;t<n;t++)e.faceNormals.push(h[x].faceNormals[t].clone())}this.morphNormals.push(e)}const d=e.skinWeights;for(let x=0,b=d.length;x<b;x++)this.skinWeights.push(d[x].clone());const p=e.skinIndices;for(let x=0,b=p.length;x<b;x++)this.skinIndices.push(p[x].clone());const m=e.lineDistances;for(let x=0,b=m.length;x<b;x++)this.lineDistances.push(m[x]);const g=e.boundingBox;null!==g&&(this.boundingBox=g.clone());const y=e.boundingSphere;return null!==y&&(this.boundingSphere=y.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class BoxGeometry extends Geometry{constructor(e,t,n,o,c,h){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:o,heightSegments:c,depthSegments:h},this.fromBufferGeometry(new BoxBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}}class BoxBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c,h){super(),this.type="BoxBufferGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:o,heightSegments:c,depthSegments:h};const d=this;e=e||1,t=t||1,n=n||1,o=Math.floor(o)||1,c=Math.floor(c)||1,h=Math.floor(h)||1;const p=[],m=[],g=[],y=[];let x=0,b=0;function buildPlane(e,t,n,o,c,h,M,_,w,S,T){const E=h/w,L=M/S,A=h/2,C=M/2,P=_/2,R=w+1,B=S+1;let D=0,G=0;const I=new Vector3;for(let d=0;d<B;d++){const h=d*L-C;for(let p=0;p<R;p++){const x=p*E-A;I[e]=x*o,I[t]=h*c,I[n]=P,m.push(I.x,I.y,I.z),I[e]=0,I[t]=0,I[n]=_>0?1:-1,g.push(I.x,I.y,I.z),y.push(p/w),y.push(1-d/S),D+=1}}for(let d=0;d<S;d++)for(let e=0;e<w;e++){const t=x+e+R*d,n=x+e+R*(d+1),o=x+(e+1)+R*(d+1),c=x+(e+1)+R*d;p.push(t,n,c),p.push(n,o,c),G+=6}d.addGroup(b,G,T),b+=G,x+=D}buildPlane("z","y","x",-1,-1,n,t,e,h,c,0),buildPlane("z","y","x",1,-1,n,t,-e,h,c,1),buildPlane("x","z","y",1,1,e,n,t,o,h,2),buildPlane("x","z","y",1,-1,e,n,-t,o,h,3),buildPlane("x","y","z",1,-1,e,t,n,o,c,4),buildPlane("x","y","z",-1,-1,e,t,-n,o,c,5),this.setIndex(p),this.setAttribute("position",new Float32BufferAttribute(m,3)),this.setAttribute("normal",new Float32BufferAttribute(g,3)),this.setAttribute("uv",new Float32BufferAttribute(y,2))}}function cloneUniforms(e){const t={};for(const n in e){t[n]={};for(const o in e[n]){const c=e[n][o];c&&(c.isColor||c.isMatrix3||c.isMatrix4||c.isVector2||c.isVector3||c.isVector4||c.isTexture)?t[n][o]=c.clone():Array.isArray(c)?t[n][o]=c.slice():t[n][o]=c}}return t}function mergeUniforms(e){const t={};for(let n=0;n<e.length;n++){const o=cloneUniforms(e[n]);for(const e in o)t[e]=o[e]}return t}const Di={clone:cloneUniforms,merge:mergeUniforms};var Gi="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",Ii="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";function ShaderMaterial(e){Material.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=Gi,this.fragmentShader=Ii,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Camera(){Object3D.call(this),this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4}function PerspectiveCamera(e,t,n,o){Camera.call(this),this.type="PerspectiveCamera",this.fov=void 0!==e?e:50,this.zoom=1,this.near=void 0!==n?n:.1,this.far=void 0!==o?o:2e3,this.focus=10,this.aspect=void 0!==t?t:1,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}ShaderMaterial.prototype=Object.create(Material.prototype),ShaderMaterial.prototype.constructor=ShaderMaterial,ShaderMaterial.prototype.isShaderMaterial=!0,ShaderMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cloneUniforms(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this},ShaderMaterial.prototype.toJSON=function(e){const t=Material.prototype.toJSON.call(this,e);t.uniforms={};for(const o in this.uniforms){const n=this.uniforms[o],c=n.value;c&&c.isTexture?t.uniforms[o]={type:"t",value:c.toJSON(e).uuid}:c&&c.isColor?t.uniforms[o]={type:"c",value:c.getHex()}:c&&c.isVector2?t.uniforms[o]={type:"v2",value:c.toArray()}:c&&c.isVector3?t.uniforms[o]={type:"v3",value:c.toArray()}:c&&c.isVector4?t.uniforms[o]={type:"v4",value:c.toArray()}:c&&c.isMatrix3?t.uniforms[o]={type:"m3",value:c.toArray()}:c&&c.isMatrix4?t.uniforms[o]={type:"m4",value:c.toArray()}:t.uniforms[o]={value:c}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const o in this.extensions)!0===this.extensions[o]&&(n[o]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},Camera.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:!0,copy:function(e,t){return Object3D.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new Vector3),this.updateMatrixWorld(!0);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){Object3D.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.getInverse(this.matrixWorld)},updateWorldMatrix:function(e,t){Object3D.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}}),PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:!0,copy:function(e,t){return Camera.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*Wn.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*Wn.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*Wn.RAD2DEG*Math.atan(Math.tan(.5*Wn.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,o,c,h){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){let e=this.near,t=e*Math.tan(.5*Wn.DEG2RAD*this.fov)/this.zoom,n=2*t,o=this.aspect*n,c=-.5*o,h=this.view;if(null!==this.view&&this.view.enabled){const e=h.fullWidth,d=h.fullHeight;c+=h.offsetX*o/e,t-=h.offsetY*n/d,o*=h.width/e,n*=h.height/d}const d=this.filmOffset;0!==d&&(c+=e*d/this.getFilmWidth()),this.projectionMatrix.makePerspective(c,c+o,t,t-n,e,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const Oi=90,Vi=1;function CubeCamera(e,t,n){if(Object3D.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const o=new PerspectiveCamera(Oi,Vi,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new Vector3(1,0,0)),this.add(o);const c=new PerspectiveCamera(Oi,Vi,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new Vector3(-1,0,0)),this.add(c);const h=new PerspectiveCamera(Oi,Vi,e,t);h.layers=this.layers,h.up.set(0,0,1),h.lookAt(new Vector3(0,1,0)),this.add(h);const d=new PerspectiveCamera(Oi,Vi,e,t);d.layers=this.layers,d.up.set(0,0,-1),d.lookAt(new Vector3(0,-1,0)),this.add(d);const p=new PerspectiveCamera(Oi,Vi,e,t);p.layers=this.layers,p.up.set(0,-1,0),p.lookAt(new Vector3(0,0,1)),this.add(p);const m=new PerspectiveCamera(Oi,Vi,e,t);m.layers=this.layers,m.up.set(0,-1,0),m.lookAt(new Vector3(0,0,-1)),this.add(m),this.update=function(e,t){null===this.parent&&this.updateMatrixWorld();const g=e.xr.enabled,y=e.getRenderTarget();e.xr.enabled=!1;const x=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,o),e.setRenderTarget(n,1),e.render(t,c),e.setRenderTarget(n,2),e.render(t,h),e.setRenderTarget(n,3),e.render(t,d),e.setRenderTarget(n,4),e.render(t,p),n.texture.generateMipmaps=x,e.setRenderTarget(n,5),e.render(t,m),e.setRenderTarget(y),e.xr.enabled=g},this.clear=function(e,t,o,c){const h=e.getRenderTarget();for(let d=0;d<6;d++)e.setRenderTarget(n,d),e.clear(t,o,c);e.setRenderTarget(h)}}function WebGLCubeRenderTarget(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),WebGLRenderTarget.call(this,e,e,t)}function DataTexture(e,t,n,o,c,h,d,p,m,g,y,x){Texture.call(this,null,h,d,p,m,g,o,c,y,x),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==m?m:Se,this.minFilter=void 0!==g?g:Se,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}CubeCamera.prototype=Object.create(Object3D.prototype),CubeCamera.prototype.constructor=CubeCamera,WebGLCubeRenderTarget.prototype=Object.create(WebGLRenderTarget.prototype),WebGLCubeRenderTarget.prototype.constructor=WebGLCubeRenderTarget,WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=!0,WebGLCubeRenderTarget.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=t.format,this.texture.encoding=t.encoding;const n=new Scene,o={uniforms:{tEquirect:{value:null}},vertexShader:["varying vec3 vWorldDirection;","vec3 transformDirection( in vec3 dir, in mat4 matrix ) {","\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );","}","void main() {","\tvWorldDirection = transformDirection( position, modelMatrix );","\t#include <begin_vertex>","\t#include <project_vertex>","}"].join("\n"),fragmentShader:["uniform sampler2D tEquirect;","varying vec3 vWorldDirection;","#include <common>","void main() {","\tvec3 direction = normalize( vWorldDirection );","\tvec2 sampleUV = equirectUv( direction );","\tgl_FragColor = texture2D( tEquirect, sampleUV );","}"].join("\n")},c=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(o.uniforms),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,side:T,blending:C});c.uniforms.tEquirect.value=t;const h=new Mesh(new BoxBufferGeometry(5,5,5),c);n.add(h);const d=new CubeCamera(1,10,this);return d.update(e,n),h.geometry.dispose(),h.material.dispose(),this},DataTexture.prototype=Object.create(Texture.prototype),DataTexture.prototype.constructor=DataTexture,DataTexture.prototype.isDataTexture=!0;const Ni=new Sphere,Fi=new Vector3;function Frustum(e,t,n,o,c,h){this.planes=[void 0!==e?e:new Plane,void 0!==t?t:new Plane,void 0!==n?n:new Plane,void 0!==o?o:new Plane,void 0!==c?c:new Plane,void 0!==h?h:new Plane]}Object.assign(Frustum.prototype,{set:function(e,t,n,o,c,h){const d=this.planes;return d[0].copy(e),d[1].copy(t),d[2].copy(n),d[3].copy(o),d[4].copy(c),d[5].copy(h),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this},setFromProjectionMatrix:function(e){const t=this.planes,n=e.elements,o=n[0],c=n[1],h=n[2],d=n[3],p=n[4],m=n[5],g=n[6],y=n[7],x=n[8],b=n[9],M=n[10],_=n[11],w=n[12],S=n[13],T=n[14],E=n[15];return t[0].setComponents(d-o,y-p,_-x,E-w).normalize(),t[1].setComponents(d+o,y+p,_+x,E+w).normalize(),t[2].setComponents(d+c,y+m,_+b,E+S).normalize(),t[3].setComponents(d-c,y-m,_-b,E-S).normalize(),t[4].setComponents(d-h,y-g,_-M,E-T).normalize(),t[5].setComponents(d+h,y+g,_+M,E+T).normalize(),this},intersectsObject:function(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Ni.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Ni)},intersectsSprite:function(e){return Ni.center.set(0,0,0),Ni.radius=.7071067811865476,Ni.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ni)},intersectsSphere:function(e){const t=this.planes,n=e.center,o=-e.radius;for(let c=0;c<6;c++){const e=t[c].distanceToPoint(n);if(e<o)return!1}return!0},intersectsBox:function(e){const t=this.planes;for(let n=0;n<6;n++){const o=t[n];if(Fi.x=o.normal.x>0?e.max.x:e.min.x,Fi.y=o.normal.y>0?e.max.y:e.min.y,Fi.z=o.normal.z>0?e.max.z:e.min.z,o.distanceToPoint(Fi)<0)return!1}return!0},containsPoint:function(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}});const Ui={common:{diffuse:{value:new Color(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Matrix3},uv2Transform:{value:new Matrix3},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(15658734)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3}}};function WebGLAnimation(){let e=null,t=!1,n=null,o=null;function onAnimationFrame(t,c){n(t,c),o=e.requestAnimationFrame(onAnimationFrame)}return{start:function(){!0!==t&&null!==n&&(o=e.requestAnimationFrame(onAnimationFrame),t=!0)},stop:function(){e.cancelAnimationFrame(o),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function WebGLAttributes(e,t){const n=t.isWebGL2,o=new WeakMap;function createBuffer(t,n){const o=t.array,c=t.usage,h=e.createBuffer();e.bindBuffer(n,h),e.bufferData(n,o,c),t.onUploadCallback();let d=5126;return o instanceof Float32Array?d=5126:o instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):o instanceof Uint16Array?d=5123:o instanceof Int16Array?d=5122:o instanceof Uint32Array?d=5125:o instanceof Int32Array?d=5124:o instanceof Int8Array?d=5120:o instanceof Uint8Array&&(d=5121),{buffer:h,type:d,bytesPerElement:o.BYTES_PER_ELEMENT,version:t.version}}function updateBuffer(t,o,c){const h=o.array,d=o.updateRange;e.bindBuffer(c,t),-1===d.count?e.bufferSubData(c,0,h):(n?e.bufferSubData(c,d.offset*h.BYTES_PER_ELEMENT,h,d.offset,d.count):e.bufferSubData(c,d.offset*h.BYTES_PER_ELEMENT,h.subarray(d.offset,d.offset+d.count)),d.count=-1)}function get(e){return e.isInterleavedBufferAttribute&&(e=e.data),o.get(e)}function remove(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=o.get(t);n&&(e.deleteBuffer(n.buffer),o.delete(t))}function update(e,t){e.isInterleavedBufferAttribute&&(e=e.data);const n=o.get(e);void 0===n?o.set(e,createBuffer(e,t)):n.version<e.version&&(updateBuffer(n.buffer,e,t),n.version=e.version)}return{get:get,remove:remove,update:update}}function PlaneGeometry(e,t,n,o){Geometry.call(this),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:o},this.fromBufferGeometry(new PlaneBufferGeometry(e,t,n,o)),this.mergeVertices()}function PlaneBufferGeometry(e,t,n,o){BufferGeometry.call(this),this.type="PlaneBufferGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:o},e=e||1,t=t||1;const c=e/2,h=t/2,d=Math.floor(n)||1,p=Math.floor(o)||1,m=d+1,g=p+1,y=e/d,x=t/p,b=[],M=[],_=[],w=[];for(let S=0;S<g;S++){const e=S*x-h;for(let t=0;t<m;t++){const n=t*y-c;M.push(n,-e,0),_.push(0,0,1),w.push(t/d),w.push(1-S/p)}}for(let S=0;S<p;S++)for(let e=0;e<d;e++){const t=e+m*S,n=e+m*(S+1),o=e+1+m*(S+1),c=e+1+m*S;b.push(t,n,c),b.push(n,o,c)}this.setIndex(b),this.setAttribute("position",new Float32BufferAttribute(M,3)),this.setAttribute("normal",new Float32BufferAttribute(_,3)),this.setAttribute("uv",new Float32BufferAttribute(w,2))}PlaneGeometry.prototype=Object.create(Geometry.prototype),PlaneGeometry.prototype.constructor=PlaneGeometry,PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype),PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;var zi="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",Hi="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",ki="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",ji="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",Wi="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",qi="vec3 transformed = vec3( position );",Xi="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",Yi="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",Zi="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",Ji="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",Qi="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",Ki="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",$i="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",eo="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",to="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",no="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",ro="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",io="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",oo="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",ao="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",so="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",co="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",lo="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",uo="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",ho="gl_FragColor = linearToOutputTexel( gl_FragColor );",po="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",fo="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",mo="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",go="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",yo="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",vo="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",xo="#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",bo="#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",Mo="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",_o="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",wo="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",So="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",To="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",Eo="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",Lo="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",Ao="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",Co="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",Po="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",Ro="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",Bo="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",Do="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",Go="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",Io="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",Oo="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",Vo="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",No="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",Fo="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",Uo="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",zo="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",Ho="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",ko="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",jo="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",Wo="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",qo="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",Xo="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",Yo="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",Zo="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",Jo="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",Qo="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",Ko="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",$o="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",ea="#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",ta="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",na="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",ra="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",ia="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",oa="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",aa="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",sa="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",ca="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",la="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",ua="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",ha="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",da="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",pa="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",fa="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",ma="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",ga="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",ya="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",va="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",xa="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",ba="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",Ma="#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",_a="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",wa="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",Sa="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",Ta="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",Ea="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",La="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",Aa="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",Ca="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Pa="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",Ra="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Ba="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",Da="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",Ga="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",Ia="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",Oa="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",Va="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Na="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",Fa="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",Ua="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",za="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ha="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",ka="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",ja="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",Wa="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",qa="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",Xa="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ya="#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",Za="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ja="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",Qa="#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ka="#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",$a="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",es="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",ts="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",ns="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",rs="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",is="#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",os="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",as="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const ss={alphamap_fragment:zi,alphamap_pars_fragment:Hi,alphatest_fragment:ki,aomap_fragment:ji,aomap_pars_fragment:Wi,begin_vertex:qi,beginnormal_vertex:Xi,bsdfs:Yi,bumpmap_pars_fragment:Zi,clipping_planes_fragment:Ji,clipping_planes_pars_fragment:Qi,clipping_planes_pars_vertex:Ki,clipping_planes_vertex:$i,color_fragment:eo,color_pars_fragment:to,color_pars_vertex:no,color_vertex:ro,common:io,cube_uv_reflection_fragment:oo,defaultnormal_vertex:ao,displacementmap_pars_vertex:so,displacementmap_vertex:co,emissivemap_fragment:lo,emissivemap_pars_fragment:uo,encodings_fragment:ho,encodings_pars_fragment:po,envmap_fragment:fo,envmap_common_pars_fragment:mo,envmap_pars_fragment:go,envmap_pars_vertex:yo,envmap_physical_pars_fragment:Ao,envmap_vertex:vo,fog_vertex:xo,fog_pars_vertex:bo,fog_fragment:Mo,fog_pars_fragment:_o,gradientmap_pars_fragment:wo,lightmap_fragment:So,lightmap_pars_fragment:To,lights_lambert_vertex:Eo,lights_pars_begin:Lo,lights_toon_fragment:Co,lights_toon_pars_fragment:Po,lights_phong_fragment:Ro,lights_phong_pars_fragment:Bo,lights_physical_fragment:Do,lights_physical_pars_fragment:Go,lights_fragment_begin:Io,lights_fragment_maps:Oo,lights_fragment_end:Vo,logdepthbuf_fragment:No,logdepthbuf_pars_fragment:Fo,logdepthbuf_pars_vertex:Uo,logdepthbuf_vertex:zo,map_fragment:Ho,map_pars_fragment:ko,map_particle_fragment:jo,map_particle_pars_fragment:Wo,metalnessmap_fragment:qo,metalnessmap_pars_fragment:Xo,morphnormal_vertex:Yo,morphtarget_pars_vertex:Zo,morphtarget_vertex:Jo,normal_fragment_begin:Qo,normal_fragment_maps:Ko,normalmap_pars_fragment:$o,clearcoat_normal_fragment_begin:ea,clearcoat_normal_fragment_maps:ta,clearcoat_pars_fragment:na,packing:ra,premultiplied_alpha_fragment:ia,project_vertex:oa,dithering_fragment:aa,dithering_pars_fragment:sa,roughnessmap_fragment:ca,roughnessmap_pars_fragment:la,shadowmap_pars_fragment:ua,shadowmap_pars_vertex:ha,shadowmap_vertex:da,shadowmask_pars_fragment:pa,skinbase_vertex:fa,skinning_pars_vertex:ma,skinning_vertex:ga,skinnormal_vertex:ya,specularmap_fragment:va,specularmap_pars_fragment:xa,tonemapping_fragment:ba,tonemapping_pars_fragment:Ma,uv_pars_fragment:_a,uv_pars_vertex:wa,uv_vertex:Sa,uv2_pars_fragment:Ta,uv2_pars_vertex:Ea,uv2_vertex:La,worldpos_vertex:Aa,background_frag:Ca,background_vert:Pa,cube_frag:Ra,cube_vert:Ba,depth_frag:Da,depth_vert:Ga,distanceRGBA_frag:Ia,distanceRGBA_vert:Oa,equirect_frag:Va,equirect_vert:Na,linedashed_frag:Fa,linedashed_vert:Ua,meshbasic_frag:za,meshbasic_vert:Ha,meshlambert_frag:ka,meshlambert_vert:ja,meshmatcap_frag:Wa,meshmatcap_vert:qa,meshtoon_frag:Xa,meshtoon_vert:Ya,meshphong_frag:Za,meshphong_vert:Ja,meshphysical_frag:Qa,meshphysical_vert:Ka,normal_frag:$a,normal_vert:es,points_frag:ts,points_vert:ns,shadow_frag:rs,shadow_vert:is,sprite_frag:os,sprite_vert:as},cs={basic:{uniforms:mergeUniforms([Ui.common,Ui.specularmap,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.fog]),vertexShader:ss.meshbasic_vert,fragmentShader:ss.meshbasic_frag},lambert:{uniforms:mergeUniforms([Ui.common,Ui.specularmap,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.fog,Ui.lights,{emissive:{value:new Color(0)}}]),vertexShader:ss.meshlambert_vert,fragmentShader:ss.meshlambert_frag},phong:{uniforms:mergeUniforms([Ui.common,Ui.specularmap,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.fog,Ui.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ss.meshphong_vert,fragmentShader:ss.meshphong_frag},standard:{uniforms:mergeUniforms([Ui.common,Ui.envmap,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.roughnessmap,Ui.metalnessmap,Ui.fog,Ui.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ss.meshphysical_vert,fragmentShader:ss.meshphysical_frag},toon:{uniforms:mergeUniforms([Ui.common,Ui.aomap,Ui.lightmap,Ui.emissivemap,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.gradientmap,Ui.fog,Ui.lights,{emissive:{value:new Color(0)}}]),vertexShader:ss.meshtoon_vert,fragmentShader:ss.meshtoon_frag},matcap:{uniforms:mergeUniforms([Ui.common,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,Ui.fog,{matcap:{value:null}}]),vertexShader:ss.meshmatcap_vert,fragmentShader:ss.meshmatcap_frag},points:{uniforms:mergeUniforms([Ui.points,Ui.fog]),vertexShader:ss.points_vert,fragmentShader:ss.points_frag},dashed:{uniforms:mergeUniforms([Ui.common,Ui.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ss.linedashed_vert,fragmentShader:ss.linedashed_frag},depth:{uniforms:mergeUniforms([Ui.common,Ui.displacementmap]),vertexShader:ss.depth_vert,fragmentShader:ss.depth_frag},normal:{uniforms:mergeUniforms([Ui.common,Ui.bumpmap,Ui.normalmap,Ui.displacementmap,{opacity:{value:1}}]),vertexShader:ss.normal_vert,fragmentShader:ss.normal_frag},sprite:{uniforms:mergeUniforms([Ui.sprite,Ui.fog]),vertexShader:ss.sprite_vert,fragmentShader:ss.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null}},vertexShader:ss.background_vert,fragmentShader:ss.background_frag},cube:{uniforms:mergeUniforms([Ui.envmap,{opacity:{value:1}}]),vertexShader:ss.cube_vert,fragmentShader:ss.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ss.equirect_vert,fragmentShader:ss.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([Ui.common,Ui.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ss.distanceRGBA_vert,fragmentShader:ss.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([Ui.lights,Ui.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ss.shadow_vert,fragmentShader:ss.shadow_frag}};function WebGLBackground(e,t,n,o){const c=new Color(0);let h,d,p=0,m=null,g=0,y=null;function render(t,o,x,b){let M=!0===o.isScene?o.background:null;const _=e.xr,w=_.getSession&&_.getSession();if(w&&"additive"===w.environmentBlendMode&&(M=null),null===M?setClear(c,p):M&&M.isColor&&(setClear(M,1),b=!0),(e.autoClear||b)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),M&&(M.isCubeTexture||M.isWebGLCubeRenderTarget||M.mapping===xe)){void 0===d&&(d=new Mesh(new BoxBufferGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(cs.cube.uniforms),vertexShader:cs.cube.vertexShader,fragmentShader:cs.cube.fragmentShader,side:T,depthTest:!1,depthWrite:!1,fog:!1})),d.geometry.deleteAttribute("normal"),d.geometry.deleteAttribute("uv"),d.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(d.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(d));const o=M.isWebGLCubeRenderTarget?M.texture:M;d.material.uniforms.envMap.value=o,d.material.uniforms.flipEnvMap.value=o.isCubeTexture?-1:1,m===M&&g===o.version&&y===e.toneMapping||(d.material.needsUpdate=!0,m=M,g=o.version,y=e.toneMapping),t.unshift(d,d.geometry,d.material,0,0,null)}else M&&M.isTexture&&(void 0===h&&(h=new Mesh(new PlaneBufferGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(cs.background.uniforms),vertexShader:cs.background.vertexShader,fragmentShader:cs.background.fragmentShader,side:S,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(h)),h.material.uniforms.t2D.value=M,!0===M.matrixAutoUpdate&&M.updateMatrix(),h.material.uniforms.uvTransform.value.copy(M.matrix),m===M&&g===M.version&&y===e.toneMapping||(h.material.needsUpdate=!0,m=M,g=M.version,y=e.toneMapping),t.unshift(h,h.geometry,h.material,0,0,null))}function setClear(e,n){t.buffers.color.setClear(e.r,e.g,e.b,n,o)}return{getClearColor:function(){return c},setClearColor:function(e,t){c.set(e),p=void 0!==t?t:1,setClear(c,p)},getClearAlpha:function(){return p},setClearAlpha:function(e){p=e,setClear(c,p)},render:render}}function WebGLBindingStates(e,t,n,o){const c=e.getParameter(34921),h=o.isWebGL2?null:t.get("OES_vertex_array_object"),d=o.isWebGL2||null!==h,p={},m=createBindingState(null);let g=m;function setup(t,o,c,h,p){let m=!1;if(d){const e=getBindingState(h,c,o);g!==e&&(g=e,bindVertexArrayObject(g.object)),m=needsUpdate(h),m&&saveCache(h)}else{const e=!0===o.wireframe;g.geometry===h.id&&g.program===c.id&&g.wireframe===e||(g.geometry=h.id,g.program=c.id,g.wireframe=e,m=!0)}!0===t.isInstancedMesh&&(m=!0),null!==p&&n.update(p,34963),m&&(setupVertexAttributes(t,o,c,h),null!==p&&e.bindBuffer(34963,n.get(p).buffer))}function createVertexArrayObject(){return o.isWebGL2?e.createVertexArray():h.createVertexArrayOES()}function bindVertexArrayObject(t){return o.isWebGL2?e.bindVertexArray(t):h.bindVertexArrayOES(t)}function deleteVertexArrayObject(t){return o.isWebGL2?e.deleteVertexArray(t):h.deleteVertexArrayOES(t)}function getBindingState(e,t,n){const o=!0===n.wireframe;let c=p[e.id];void 0===c&&(c={},p[e.id]=c);let h=c[t.id];void 0===h&&(h={},c[t.id]=h);let d=h[o];return void 0===d&&(d=createBindingState(createVertexArrayObject()),h[o]=d),d}function createBindingState(e){const t=[],n=[],o=[];for(let h=0;h<c;h++)t[h]=0,n[h]=0,o[h]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:o,object:e,attributes:{}}}function needsUpdate(e){const t=g.attributes,n=e.attributes;if(Object.keys(t).length!==Object.keys(n).length)return!0;for(const o in n){const e=t[o],c=n[o];if(e.attribute!==c)return!0;if(e.data!==c.data)return!0}return!1}function saveCache(e){const t={},n=e.attributes;for(const o in n){const e=n[o],c={};c.attribute=e,e.data&&(c.data=e.data),t[o]=c}g.attributes=t}function initAttributes(){const e=g.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function enableAttribute(e){enableAttributeAndDivisor(e,0)}function enableAttributeAndDivisor(n,c){const h=g.newAttributes,d=g.enabledAttributes,p=g.attributeDivisors;if(h[n]=1,0===d[n]&&(e.enableVertexAttribArray(n),d[n]=1),p[n]!==c){const h=o.isWebGL2?e:t.get("ANGLE_instanced_arrays");h[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,c),p[n]=c}}function disableUnusedAttributes(){const t=g.newAttributes,n=g.enabledAttributes;for(let o=0,c=n.length;o<c;o++)n[o]!==t[o]&&(e.disableVertexAttribArray(o),n[o]=0)}function vertexAttribPointer(t,n,c,h,d,p){!0!==o.isWebGL2||5124!==c&&5125!==c?e.vertexAttribPointer(t,n,c,h,d,p):e.vertexAttribIPointer(t,n,c,h,d,p)}function setupVertexAttributes(c,h,d,p){if(!1===o.isWebGL2&&(c.isInstancedMesh||p.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;initAttributes();const m=p.attributes,g=d.getAttributes(),y=h.defaultAttributeValues;for(const t in g){const o=g[t];if(o>=0){const h=m[t];if(void 0!==h){const t=h.normalized,c=h.itemSize,d=n.get(h);if(void 0===d)continue;const m=d.buffer,g=d.type,y=d.bytesPerElement;if(h.isInterleavedBufferAttribute){const n=h.data,d=n.stride,x=h.offset;n&&n.isInstancedInterleavedBuffer?(enableAttributeAndDivisor(o,n.meshPerAttribute),void 0===p._maxInstanceCount&&(p._maxInstanceCount=n.meshPerAttribute*n.count)):enableAttribute(o),e.bindBuffer(34962,m),vertexAttribPointer(o,c,g,t,d*y,x*y)}else h.isInstancedBufferAttribute?(enableAttributeAndDivisor(o,h.meshPerAttribute),void 0===p._maxInstanceCount&&(p._maxInstanceCount=h.meshPerAttribute*h.count)):enableAttribute(o),e.bindBuffer(34962,m),vertexAttribPointer(o,c,g,t,0,0)}else if("instanceMatrix"===t){const t=n.get(c.instanceMatrix);if(void 0===t)continue;const h=t.buffer,d=t.type;enableAttributeAndDivisor(o+0,1),enableAttributeAndDivisor(o+1,1),enableAttributeAndDivisor(o+2,1),enableAttributeAndDivisor(o+3,1),e.bindBuffer(34962,h),e.vertexAttribPointer(o+0,4,d,!1,64,0),e.vertexAttribPointer(o+1,4,d,!1,64,16),e.vertexAttribPointer(o+2,4,d,!1,64,32),e.vertexAttribPointer(o+3,4,d,!1,64,48)}else if(void 0!==y){const n=y[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(o,n);break;case 3:e.vertexAttrib3fv(o,n);break;case 4:e.vertexAttrib4fv(o,n);break;default:e.vertexAttrib1fv(o,n)}}}}disableUnusedAttributes()}function dispose(){reset();for(const e in p){const t=p[e];for(const e in t){const n=t[e];for(const e in n)deleteVertexArrayObject(n[e].object),delete n[e];delete t[e]}delete p[e]}}function releaseStatesOfGeometry(e){if(void 0===p[e.id])return;const t=p[e.id];for(const n in t){const e=t[n];for(const t in e)deleteVertexArrayObject(e[t].object),delete e[t];delete t[n]}delete p[e.id]}function releaseStatesOfProgram(e){for(const t in p){const n=p[t];if(void 0===n[e.id])continue;const o=n[e.id];for(const e in o)deleteVertexArrayObject(o[e].object),delete o[e];delete n[e.id]}}function reset(){resetDefaultState(),g!==m&&(g=m,bindVertexArrayObject(g.object))}function resetDefaultState(){m.geometry=null,m.program=null,m.wireframe=!1}return{setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes}}function WebGLBufferRenderer(e,t,n,o){const c=o.isWebGL2;let h;function setMode(e){h=e}function render(t,o){e.drawArrays(h,t,o),n.update(o,h)}function renderInstances(o,d,p,m){if(0===m)return;let g,y;if(c)g=e,y="drawArraysInstanced";else if(g=t.get("ANGLE_instanced_arrays"),y="drawArraysInstancedANGLE",null===g)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");g[y](h,d,p,m),n.update(p,h,m)}this.setMode=setMode,this.render=render,this.renderInstances=renderInstances}function WebGLCapabilities(e,t,n){let o;function getMaxAnisotropy(){if(void 0!==o)return o;const n=t.get("EXT_texture_filter_anisotropic");return o=null!==n?e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,o}function getMaxPrecision(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const c="undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let h=void 0!==n.precision?n.precision:"highp";const d=getMaxPrecision(h);d!==h&&(console.warn("THREE.WebGLRenderer:",h,"not supported, using",d,"instead."),h=d);const p=!0===n.logarithmicDepthBuffer,m=e.getParameter(34930),g=e.getParameter(35660),y=e.getParameter(3379),x=e.getParameter(34076),b=e.getParameter(34921),M=e.getParameter(36347),_=e.getParameter(36348),w=e.getParameter(36349),S=g>0,T=c||!!t.get("OES_texture_float"),E=S&&T,L=c?e.getParameter(36183):0;return{isWebGL2:c,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:h,logarithmicDepthBuffer:p,maxTextures:m,maxVertexTextures:g,maxTextureSize:y,maxCubemapSize:x,maxAttributes:b,maxVertexUniforms:M,maxVaryings:_,maxFragmentUniforms:w,vertexTextures:S,floatFragmentTextures:T,floatVertexTextures:E,maxSamples:L}}function WebGLClipping(){const e=this;let t=null,n=0,o=!1,c=!1;const h=new Plane,d=new Matrix3,p={value:null,needsUpdate:!1};function resetGlobalState(){p.value!==t&&(p.value=t,p.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function projectPlanes(t,n,o,c){let m=null!==t?t.length:0,g=null;if(0!==m){if(g=p.value,!0!==c||null===g){const e=o+4*m,c=n.matrixWorldInverse;d.getNormalMatrix(c),(null===g||g.length<e)&&(g=new Float32Array(e));for(let n=0,p=o;n!==m;++n,p+=4)h.copy(t[n]).applyMatrix4(c,d),h.normal.toArray(g,p),g[p+3]=h.constant}p.value=g,p.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}this.uniform=p,this.numPlanes=0,this.numIntersection=0,this.init=function(e,c,h){const d=0!==e.length||c||0!==n||o;return o=c,t=projectPlanes(e,h,0),n=e.length,d},this.beginShadows=function(){c=!0,projectPlanes(null)},this.endShadows=function(){c=!1,resetGlobalState()},this.setState=function(e,h,d,m,g,y){if(!o||null===e||0===e.length||c&&!d)c?projectPlanes(null):resetGlobalState();else{const o=c?0:n,d=4*o;let x=g.clippingState||null;p.value=x,x=projectPlanes(e,m,d,y);for(let e=0;e!==d;++e)x[e]=t[e];g.clippingState=x,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=o}}}function WebGLExtensions(e){const t={};return{get:function(n){if(void 0!==t[n])return t[n];let o;switch(n){case"WEBGL_depth_texture":o=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=e.getExtension(n)}return null===o&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),t[n]=o,o}}}function WebGLGeometries(e,t,n,o){const c=new WeakMap,h=new WeakMap;function onGeometryDispose(e){const d=e.target,p=c.get(d);null!==p.index&&t.remove(p.index);for(const n in p.attributes)t.remove(p.attributes[n]);d.removeEventListener("dispose",onGeometryDispose),c.delete(d);const m=h.get(p);m&&(t.remove(m),h.delete(p)),o.releaseStatesOfGeometry(d),!0===d.isInstancedBufferGeometry&&delete d._maxInstanceCount,n.memory.geometries--}function get(e,t){let o=c.get(t);return o||(t.addEventListener("dispose",onGeometryDispose),t.isBufferGeometry?o=t:t.isGeometry&&(void 0===t._bufferGeometry&&(t._bufferGeometry=(new BufferGeometry).setFromObject(e)),o=t._bufferGeometry),c.set(t,o),n.memory.geometries++,o)}function update(e){const n=e.attributes;for(const c in n)t.update(n[c],34962);const o=e.morphAttributes;for(const c in o){const e=o[c];for(let n=0,o=e.length;n<o;n++)t.update(e[n],34962)}}function updateWireframeAttribute(e){const n=[],o=e.index,c=e.attributes.position;let d=0;if(null!==o){const e=o.array;d=o.version;for(let t=0,o=e.length;t<o;t+=3){const o=e[t+0],c=e[t+1],h=e[t+2];n.push(o,c,c,h,h,o)}}else{const e=c.array;d=c.version;for(let t=0,o=e.length/3-1;t<o;t+=3){const e=t+0,o=t+1,c=t+2;n.push(e,o,o,c,c,e)}}const p=new(arrayMax(n)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(n,1);p.version=d;const m=h.get(e);m&&t.remove(m),h.set(e,p)}function getWireframeAttribute(e){const t=h.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&updateWireframeAttribute(e)}else updateWireframeAttribute(e);return h.get(e)}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute}}function WebGLIndexedBufferRenderer(e,t,n,o){const c=o.isWebGL2;let h,d,p;function setMode(e){h=e}function setIndex(e){d=e.type,p=e.bytesPerElement}function render(t,o){e.drawElements(h,o,d,t*p),n.update(o,h)}function renderInstances(o,m,g,y){if(0===y)return;let x,b;if(c)x=e,b="drawElementsInstanced";else if(x=t.get("ANGLE_instanced_arrays"),b="drawElementsInstancedANGLE",null===x)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");x[b](h,g,d,m*p,y),n.update(g,h,y)}this.setMode=setMode,this.setIndex=setIndex,this.render=render,this.renderInstances=renderInstances}function WebGLInfo(e){const t={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function update(e,t,o){switch(o=o||1,n.calls++,t){case 4:n.triangles+=o*(e/3);break;case 1:n.lines+=o*(e/2);break;case 3:n.lines+=o*(e-1);break;case 2:n.lines+=o*e;break;case 0:n.points+=o*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t);break}}function reset(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:t,render:n,programs:null,autoReset:!0,reset:reset,update:update}}function numericalSort(e,t){return e[0]-t[0]}function absNumericalSort(e,t){return Math.abs(t[1])-Math.abs(e[1])}function WebGLMorphtargets(e){const t={},n=new Float32Array(8),o=[];for(let c=0;c<8;c++)o[c]=[c,0];function update(c,h,d,p){const m=c.morphTargetInfluences,g=void 0===m?0:m.length;let y=t[h.id];if(void 0===y){y=[];for(let e=0;e<g;e++)y[e]=[e,0];t[h.id]=y}for(let e=0;e<g;e++){const t=y[e];t[0]=e,t[1]=m[e]}y.sort(absNumericalSort);for(let e=0;e<8;e++)e<g&&y[e][1]?(o[e][0]=y[e][0],o[e][1]=y[e][1]):(o[e][0]=Number.MAX_SAFE_INTEGER,o[e][1]=0);o.sort(numericalSort);const x=d.morphTargets&&h.morphAttributes.position,b=d.morphNormals&&h.morphAttributes.normal;let M=0;for(let e=0;e<8;e++){const t=o[e],c=t[0],d=t[1];c!==Number.MAX_SAFE_INTEGER&&d?(x&&h.getAttribute("morphTarget"+e)!==x[c]&&h.setAttribute("morphTarget"+e,x[c]),b&&h.getAttribute("morphNormal"+e)!==b[c]&&h.setAttribute("morphNormal"+e,b[c]),n[e]=d,M+=d):(x&&void 0!==h.getAttribute("morphTarget"+e)&&h.deleteAttribute("morphTarget"+e),b&&void 0!==h.getAttribute("morphNormal"+e)&&h.deleteAttribute("morphNormal"+e),n[e]=0)}const _=h.morphTargetsRelative?1:1-M;p.getUniforms().setValue(e,"morphTargetBaseInfluence",_),p.getUniforms().setValue(e,"morphTargetInfluences",n)}return{update:update}}function WebGLObjects(e,t,n,o){let c=new WeakMap;function update(e){const h=o.render.frame,d=e.geometry,p=t.get(e,d);return c.get(p)!==h&&(d.isGeometry&&p.updateFromObject(e),t.update(p),c.set(p,h)),e.isInstancedMesh&&n.update(e.instanceMatrix,34962),p}function dispose(){c=new WeakMap}return{update:update,dispose:dispose}}function CubeTexture(e,t,n,o,c,h,d,p,m,g){e=void 0!==e?e:[],t=void 0!==t?t:me,d=void 0!==d?d:Xe,Texture.call(this,e,t,n,o,c,h,d,p,m,g),this.flipY=!1}function DataTexture2DArray(e,t,n,o){Texture.call(this,null),this.image={data:e||null,width:t||1,height:n||1,depth:o||1},this.magFilter=Se,this.minFilter=Se,this.wrapR=_e,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function DataTexture3D(e,t,n,o){Texture.call(this,null),this.image={data:e||null,width:t||1,height:n||1,depth:o||1},this.magFilter=Se,this.minFilter=Se,this.wrapR=_e,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}cs.physical={uniforms:mergeUniforms([cs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Color(0)},transparency:{value:0}}]),vertexShader:ss.meshphysical_vert,fragmentShader:ss.meshphysical_frag},CubeTexture.prototype=Object.create(Texture.prototype),CubeTexture.prototype.constructor=CubeTexture,CubeTexture.prototype.isCubeTexture=!0,Object.defineProperty(CubeTexture.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}}),DataTexture2DArray.prototype=Object.create(Texture.prototype),DataTexture2DArray.prototype.constructor=DataTexture2DArray,DataTexture2DArray.prototype.isDataTexture2DArray=!0,DataTexture3D.prototype=Object.create(Texture.prototype),DataTexture3D.prototype.constructor=DataTexture3D,DataTexture3D.prototype.isDataTexture3D=!0;const ls=new Texture,us=new DataTexture2DArray,hs=new DataTexture3D,ds=new CubeTexture,ps=[],fs=[],ms=new Float32Array(16),gs=new Float32Array(9),ys=new Float32Array(4);function flatten(e,t,n){const o=e[0];if(o<=0||o>0)return e;let c=t*n,h=ps[c];if(void 0===h&&(h=new Float32Array(c),ps[c]=h),0!==t){o.toArray(h,0);for(let o=1,c=0;o!==t;++o)c+=n,e[o].toArray(h,c)}return h}function arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}function copyArray(e,t){for(let n=0,o=t.length;n<o;n++)e[n]=t[n]}function allocTexUnits(e,t){let n=fs[t];void 0===n&&(n=new Int32Array(t),fs[t]=n);for(let o=0;o!==t;++o)n[o]=e.allocateTextureUnit();return n}function setValueV1f(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function setValueV2f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(arraysEqual(n,t))return;e.uniform2fv(this.addr,t),copyArray(n,t)}}function setValueV3f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(arraysEqual(n,t))return;e.uniform3fv(this.addr,t),copyArray(n,t)}}function setValueV4f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(arraysEqual(n,t))return;e.uniform4fv(this.addr,t),copyArray(n,t)}}function setValueM2(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;ys.set(o),e.uniformMatrix2fv(this.addr,!1,ys),copyArray(n,o)}}function setValueM3(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;gs.set(o),e.uniformMatrix3fv(this.addr,!1,gs),copyArray(n,o)}}function setValueM4(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;ms.set(o),e.uniformMatrix4fv(this.addr,!1,ms),copyArray(n,o)}}function setValueT1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.safeSetTexture2D(t||ls,c)}function setValueT2DArray1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.setTexture2DArray(t||us,c)}function setValueT3D1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.setTexture3D(t||hs,c)}function setValueT6(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.safeSetTextureCube(t||ds,c)}function setValueV1i(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function setValueV2i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform2iv(this.addr,t),copyArray(n,t))}function setValueV3i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform3iv(this.addr,t),copyArray(n,t))}function setValueV4i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform4iv(this.addr,t),copyArray(n,t))}function setValueV1ui(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function getSingularSetter(e){switch(e){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(e,t){e.uniform1fv(this.addr,t)}function setValueV1iArray(e,t){e.uniform1iv(this.addr,t)}function setValueV2iArray(e,t){e.uniform2iv(this.addr,t)}function setValueV3iArray(e,t){e.uniform3iv(this.addr,t)}function setValueV4iArray(e,t){e.uniform4iv(this.addr,t)}function setValueV2fArray(e,t){const n=flatten(t,this.size,2);e.uniform2fv(this.addr,n)}function setValueV3fArray(e,t){const n=flatten(t,this.size,3);e.uniform3fv(this.addr,n)}function setValueV4fArray(e,t){const n=flatten(t,this.size,4);e.uniform4fv(this.addr,n)}function setValueM2Array(e,t){const n=flatten(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function setValueM3Array(e,t){const n=flatten(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function setValueM4Array(e,t){const n=flatten(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function setValueT1Array(e,t,n){const o=t.length,c=allocTexUnits(n,o);e.uniform1iv(this.addr,c);for(let h=0;h!==o;++h)n.safeSetTexture2D(t[h]||ls,c[h])}function setValueT6Array(e,t,n){const o=t.length,c=allocTexUnits(n,o);e.uniform1iv(this.addr,c);for(let h=0;h!==o;++h)n.safeSetTextureCube(t[h]||ds,c[h])}function getPureArraySetter(e){switch(e){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35680:case 36300:case 36308:case 36293:return setValueT6Array}}function SingleUniform(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=getSingularSetter(t.type)}function PureArrayUniform(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=getPureArraySetter(t.type)}function StructuredUniform(e){this.id=e,this.seq=[],this.map={}}PureArrayUniform.prototype.updateCache=function(e){let t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),copyArray(t,e)},StructuredUniform.prototype.setValue=function(e,t,n){const o=this.seq;for(let c=0,h=o.length;c!==h;++c){const h=o[c];h.setValue(e,t[h.id],n)}};const vs=/([\w\d_]+)(\])?(\[|\.)?/g;function addUniform(e,t){e.seq.push(t),e.map[t.id]=t}function parseUniform(e,t,n){const o=e.name,c=o.length;vs.lastIndex=0;while(1){const h=vs.exec(o),d=vs.lastIndex;let p=h[1],m="]"===h[2],g=h[3];if(m&&(p|=0),void 0===g||"["===g&&d+2===c){addUniform(n,void 0===g?new SingleUniform(p,e,t):new PureArrayUniform(p,e,t));break}{const e=n.map;let t=e[p];void 0===t&&(t=new StructuredUniform(p),addUniform(n,t)),n=t}}}function WebGLUniforms(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let o=0;o<n;++o){const n=e.getActiveUniform(t,o),c=e.getUniformLocation(t,n.name);parseUniform(n,c,this)}}function WebGLShader(e,t,n){const o=e.createShader(t);return e.shaderSource(o,n),e.compileShader(o),o}WebGLUniforms.prototype.setValue=function(e,t,n,o){const c=this.map[t];void 0!==c&&c.setValue(e,n,o)},WebGLUniforms.prototype.setOptional=function(e,t,n){const o=t[n];void 0!==o&&this.setValue(e,n,o)},WebGLUniforms.upload=function(e,t,n,o){for(let c=0,h=t.length;c!==h;++c){const h=t[c],d=n[h.id];!1!==d.needsUpdate&&h.setValue(e,d.value,o)}},WebGLUniforms.seqWithValue=function(e,t){const n=[];for(let o=0,c=e.length;o!==c;++o){const c=e[o];c.id in t&&n.push(c)}return n};let xs=0;function addLineNumbers(e){const t=e.split("\n");for(let n=0;n<t.length;n++)t[n]=n+1+": "+t[n];return t.join("\n")}function getEncodingComponents(e){switch(e){case sn:return["Linear","( value )"];case cn:return["sRGB","( value )"];case un:return["RGBE","( value )"];case dn:return["RGBM","( value, 7.0 )"];case pn:return["RGBM","( value, 16.0 )"];case fn:return["RGBD","( value, 256.0 )"];case ln:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case hn:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function getShaderErrors(e,t,n){const o=e.getShaderParameter(t,35713),c=e.getShaderInfoLog(t).trim();if(o&&""===c)return"";const h=e.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+c+addLineNumbers(h)}function getTexelDecodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function getTexelEncodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function getToneMappingFunction(e,t){let n;switch(t){case le:n="Linear";break;case ue:n="Reinhard";break;case he:n="OptimizedCineon";break;case de:n="ACESFilmic";break;case pe:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function generateExtensions(e){const t=[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return t.filter(filterEmptyLine).join("\n")}function generateDefines(e){const t=[];for(const n in e){const o=e[n];!1!==o&&t.push("#define "+n+" "+o)}return t.join("\n")}function fetchAttributeLocations(e,t){const n={},o=e.getProgramParameter(t,35721);for(let c=0;c<o;c++){const o=e.getActiveAttrib(t,c),h=o.name;n[h]=e.getAttribLocation(t,h)}return n}function filterEmptyLine(e){return""!==e}function replaceLightNums(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function replaceClippingPlaneNums(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const bs=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(e){return e.replace(bs,includeReplacer)}function includeReplacer(e,t){const n=ss[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return resolveIncludes(n)}const Ms=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,_s=/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;function unrollLoops(e){return e.replace(_s,loopReplacer).replace(Ms,deprecatedLoopReplacer)}function deprecatedLoopReplacer(e,t,n,o){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),loopReplacer(e,t,n,o)}function loopReplacer(e,t,n,o){let c="";for(let h=parseInt(t);h<parseInt(n);h++)c+=o.replace(/\[ i \]/g,"[ "+h+" ]").replace(/UNROLLED_LOOP_INDEX/g,h);return c}function generatePrecision(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function generateShadowMapTypeDefine(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===M?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===_?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===w&&(t="SHADOWMAP_TYPE_VSM"),t}function generateEnvMapTypeDefine(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case me:case ge:t="ENVMAP_TYPE_CUBE";break;case xe:case be:t="ENVMAP_TYPE_CUBE_UV";break;case ye:case ve:t="ENVMAP_TYPE_EQUIREC";break}return t}function generateEnvMapModeDefine(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case ge:case ve:t="ENVMAP_MODE_REFRACTION";break}return t}function generateEnvMapBlendingDefine(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case oe:t="ENVMAP_BLENDING_MULTIPLY";break;case ae:t="ENVMAP_BLENDING_MIX";break;case se:t="ENVMAP_BLENDING_ADD";break}return t}function WebGLProgram(e,t,n,o){const c=e.getContext(),h=n.defines;let d=n.vertexShader,p=n.fragmentShader;const m=generateShadowMapTypeDefine(n),g=generateEnvMapTypeDefine(n),y=generateEnvMapModeDefine(n),x=generateEnvMapBlendingDefine(n),b=e.gammaFactor>0?e.gammaFactor:1,M=n.isWebGL2?"":generateExtensions(n),_=generateDefines(h),w=c.createProgram();let S,T;if(n.isRawShaderMaterial?(S=[_].filter(filterEmptyLine).join("\n"),S.length>0&&(S+="\n"),T=[M,_].filter(filterEmptyLine).join("\n"),T.length>0&&(T+="\n")):(S=[generatePrecision(n),"#define SHADER_NAME "+n.shaderName,_,n.instancing?"#define USE_INSTANCING":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+b,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+y:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+m:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING"," attribute mat4 instanceMatrix;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(filterEmptyLine).join("\n"),T=[M,generatePrecision(n),"#define SHADER_NAME "+n.shaderName,_,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+b,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+g:"",n.envMap?"#define "+y:"",n.envMap?"#define "+x:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+m:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==ce?"#define TONE_MAPPING":"",n.toneMapping!==ce?ss["tonemapping_pars_fragment"]:"",n.toneMapping!==ce?getToneMappingFunction("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",ss["encodings_pars_fragment"],n.map?getTexelDecodingFunction("mapTexelToLinear",n.mapEncoding):"",n.matcap?getTexelDecodingFunction("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?getTexelDecodingFunction("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?getTexelDecodingFunction("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?getTexelDecodingFunction("lightMapTexelToLinear",n.lightMapEncoding):"",getTexelEncodingFunction("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(filterEmptyLine).join("\n")),d=resolveIncludes(d),d=replaceLightNums(d,n),d=replaceClippingPlaneNums(d,n),p=resolveIncludes(p),p=replaceLightNums(p,n),p=replaceClippingPlaneNums(p,n),d=unrollLoops(d),p=unrollLoops(p),n.isWebGL2&&!n.isRawShaderMaterial){let e=!1;const t=/^\s*#version\s+300\s+es\s*\n/;n.isShaderMaterial&&null!==d.match(t)&&null!==p.match(t)&&(e=!0,d=d.replace(t,""),p=p.replace(t,"")),S=["#version 300 es\n","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+S,T=["#version 300 es\n","#define varying in",e?"":"out highp vec4 pc_fragColor;",e?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+T}const E=S+d,L=T+p,A=WebGLShader(c,35633,E),C=WebGLShader(c,35632,L);if(c.attachShader(w,A),c.attachShader(w,C),void 0!==n.index0AttributeName?c.bindAttribLocation(w,0,n.index0AttributeName):!0===n.morphTargets&&c.bindAttribLocation(w,0,"position"),c.linkProgram(w),e.debug.checkShaderErrors){const e=c.getProgramInfoLog(w).trim(),t=c.getShaderInfoLog(A).trim(),n=c.getShaderInfoLog(C).trim();let o=!0,h=!0;if(!1===c.getProgramParameter(w,35714)){o=!1;const t=getShaderErrors(c,A,"vertex"),n=getShaderErrors(c,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",c.getError(),"35715",c.getProgramParameter(w,35715),"gl.getProgramInfoLog",e,t,n)}else""!==e?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",e):""!==t&&""!==n||(h=!1);h&&(this.diagnostics={runnable:o,programLog:e,vertexShader:{log:t,prefix:S},fragmentShader:{log:n,prefix:T}})}let P,R;return c.deleteShader(A),c.deleteShader(C),this.getUniforms=function(){return void 0===P&&(P=new WebGLUniforms(c,w)),P},this.getAttributes=function(){return void 0===R&&(R=fetchAttributeLocations(c,w)),R},this.destroy=function(){o.releaseStatesOfProgram(this),c.deleteProgram(w),this.program=void 0},this.name=n.shaderName,this.id=xs++,this.cacheKey=t,this.usedTimes=1,this.program=w,this.vertexShader=A,this.fragmentShader=C,this}function WebGLPrograms(e,t,n,o){const c=[],h=n.isWebGL2,d=n.logarithmicDepthBuffer,p=n.floatVertexTextures,m=n.maxVertexUniforms,g=n.vertexTextures;let y=n.precision;const x={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},b=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen"];function getShaderObject(e,t){let n;if(t){const o=cs[t];n={name:e.name||e.type,uniforms:Di.clone(o.uniforms),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader}}else n={name:e.name||e.type,uniforms:e.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader};return n}function allocateBones(e){const t=e.skeleton,n=t.bones;if(p)return 1024;{const e=m,t=Math.floor((e-20)/4),o=Math.min(t,n.length);return o<n.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+n.length+" bones. This GPU supports "+o+"."),0):o}}function getTextureEncodingFromMap(e){let t;return e?e.isTexture?t=e.encoding:e.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=sn,t}function getParameters(o,c,m,b,M,_,w){const S=b.fog,L=o.isMeshStandardMaterial?b.environment:null,A=o.envMap||L,C=x[o.type],P=w.isSkinnedMesh?allocateBones(w):0;null!==o.precision&&(y=n.getMaxPrecision(o.precision),y!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",y,"instead."));const R=getShaderObject(o,C);o.onBeforeCompile(R,e);const B=e.getRenderTarget(),D={isWebGL2:h,shaderID:C,shaderName:R.name,uniforms:R.uniforms,vertexShader:R.vertexShader,fragmentShader:R.fragmentShader,defines:o.defines,isRawShaderMaterial:o.isRawShaderMaterial,isShaderMaterial:o.isShaderMaterial,precision:y,instancing:!0===w.isInstancedMesh,supportsVertexTextures:g,outputEncoding:null!==B?getTextureEncodingFromMap(B.texture):e.outputEncoding,map:!!o.map,mapEncoding:getTextureEncodingFromMap(o.map),matcap:!!o.matcap,matcapEncoding:getTextureEncodingFromMap(o.matcap),envMap:!!A,envMapMode:A&&A.mapping,envMapEncoding:getTextureEncodingFromMap(A),envMapCubeUV:!!A&&(A.mapping===xe||A.mapping===be),lightMap:!!o.lightMap,lightMapEncoding:getTextureEncodingFromMap(o.lightMap),aoMap:!!o.aoMap,emissiveMap:!!o.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(o.emissiveMap),bumpMap:!!o.bumpMap,normalMap:!!o.normalMap,objectSpaceNormalMap:o.normalMapType===vn,tangentSpaceNormalMap:o.normalMapType===yn,clearcoatMap:!!o.clearcoatMap,clearcoatRoughnessMap:!!o.clearcoatRoughnessMap,clearcoatNormalMap:!!o.clearcoatNormalMap,displacementMap:!!o.displacementMap,roughnessMap:!!o.roughnessMap,metalnessMap:!!o.metalnessMap,specularMap:!!o.specularMap,alphaMap:!!o.alphaMap,gradientMap:!!o.gradientMap,sheen:!!o.sheen,combine:o.combine,vertexTangents:o.normalMap&&o.vertexTangents,vertexColors:o.vertexColors,vertexUvs:!!o.map||!!o.bumpMap||!!o.normalMap||!!o.specularMap||!!o.alphaMap||!!o.emissiveMap||!!o.roughnessMap||!!o.metalnessMap||!!o.clearcoatMap||!!o.clearcoatRoughnessMap||!!o.clearcoatNormalMap||!!o.displacementMap,uvsVertexOnly:!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatNormalMap)&&!!o.displacementMap,fog:!!S,useFog:o.fog,fogExp2:S&&S.isFogExp2,flatShading:o.flatShading,sizeAttenuation:o.sizeAttenuation,logarithmicDepthBuffer:d,skinning:o.skinning&&P>0,maxBones:P,useVertexTexture:p,morphTargets:o.morphTargets,morphNormals:o.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:c.directional.length,numPointLights:c.point.length,numSpotLights:c.spot.length,numRectAreaLights:c.rectArea.length,numHemiLights:c.hemi.length,numDirLightShadows:c.directionalShadowMap.length,numPointLightShadows:c.pointShadowMap.length,numSpotLightShadows:c.spotShadowMap.length,numClippingPlanes:M,numClipIntersection:_,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&m.length>0,shadowMapType:e.shadowMap.type,toneMapping:o.toneMapped?e.toneMapping:ce,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:o.premultipliedAlpha,alphaTest:o.alphaTest,doubleSided:o.side===E,flipSided:o.side===T,depthPacking:void 0!==o.depthPacking&&o.depthPacking,index0AttributeName:o.index0AttributeName,extensionDerivatives:o.extensions&&o.extensions.derivatives,extensionFragDepth:o.extensions&&o.extensions.fragDepth,extensionDrawBuffers:o.extensions&&o.extensions.drawBuffers,extensionShaderTextureLOD:o.extensions&&o.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||null!==t.get("EXT_frag_depth"),rendererExtensionDrawBuffers:h||null!==t.get("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||null!==t.get("EXT_shader_texture_lod"),customProgramCacheKey:o.customProgramCacheKey()};return D}function getProgramCacheKey(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.fragmentShader),n.push(t.vertexShader)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);if(void 0===t.isRawShaderMaterial){for(let e=0;e<b.length;e++)n.push(t[b[e]]);n.push(e.outputEncoding),n.push(e.gammaFactor)}return n.push(t.customProgramCacheKey),n.join()}function acquireProgram(t,n){let h;for(let e=0,o=c.length;e<o;e++){const t=c[e];if(t.cacheKey===n){h=t,++h.usedTimes;break}}return void 0===h&&(h=new WebGLProgram(e,n,t,o),c.push(h)),h}function releaseProgram(e){if(0===--e.usedTimes){const t=c.indexOf(e);c[t]=c[c.length-1],c.pop(),e.destroy()}}return{getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,acquireProgram:acquireProgram,releaseProgram:releaseProgram,programs:c}}function WebGLProperties(){let e=new WeakMap;function get(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n}function remove(t){e.delete(t)}function update(t,n,o){e.get(t)[n]=o}function dispose(){e=new WeakMap}return{get:get,remove:remove,update:update,dispose:dispose}}function painterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function reversePainterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WebGLRenderList(){const e=[];let t=0;const n=[],o=[],c={id:-1};function init(){t=0,n.length=0,o.length=0}function getNextRenderItem(n,o,h,d,p,m){let g=e[t];return void 0===g?(g={id:n.id,object:n,geometry:o,material:h,program:h.program||c,groupOrder:d,renderOrder:n.renderOrder,z:p,group:m},e[t]=g):(g.id=n.id,g.object=n,g.geometry=o,g.material=h,g.program=h.program||c,g.groupOrder=d,g.renderOrder=n.renderOrder,g.z=p,g.group=m),t++,g}function push(e,t,c,h,d,p){const m=getNextRenderItem(e,t,c,h,d,p);(!0===c.transparent?o:n).push(m)}function unshift(e,t,c,h,d,p){const m=getNextRenderItem(e,t,c,h,d,p);(!0===c.transparent?o:n).unshift(m)}function sort(e,t){n.length>1&&n.sort(e||painterSortStable),o.length>1&&o.sort(t||reversePainterSortStable)}function finish(){for(let n=t,o=e.length;n<o;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.program=null,t.group=null}}return{opaque:n,transparent:o,init:init,push:push,unshift:unshift,finish:finish,sort:sort}}function WebGLRenderLists(){let e=new WeakMap;function onSceneDispose(t){const n=t.target;n.removeEventListener("dispose",onSceneDispose),e.delete(n)}function get(t,n){const o=e.get(t);let c;return void 0===o?(c=new WebGLRenderList,e.set(t,new WeakMap),e.get(t).set(n,c),t.addEventListener("dispose",onSceneDispose)):(c=o.get(n),void 0===c&&(c=new WebGLRenderList,o.set(n,c))),c}function dispose(){e=new WeakMap}return{get:get,dispose:dispose}}function UniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new Vector3,color:new Color};break;case"SpotLight":n={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":n={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return e[t.id]=n,n}}}function ShadowUniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return e[t.id]=n,n}}}let ws=0;function shadowCastingLightsFirst(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function WebGLLights(){const e=new UniformsCache,t=ShadowUniformsCache(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let d=0;d<9;d++)n.probe.push(new Vector3);const o=new Vector3,c=new Matrix4,h=new Matrix4;function setup(d,p,m){let g=0,y=0,x=0;for(let e=0;e<9;e++)n.probe[e].set(0,0,0);let b=0,M=0,_=0,w=0,S=0,T=0,E=0,L=0;const A=m.matrixWorldInverse;d.sort(shadowCastingLightsFirst);for(let P=0,R=d.length;P<R;P++){const p=d[P],m=p.color,C=p.intensity,R=p.distance,B=p.shadow&&p.shadow.map?p.shadow.map.texture:null;if(p.isAmbientLight)g+=m.r*C,y+=m.g*C,x+=m.b*C;else if(p.isLightProbe)for(let e=0;e<9;e++)n.probe[e].addScaledVector(p.sh.coefficients[e],C);else if(p.isDirectionalLight){const c=e.get(p);if(c.color.copy(p.color).multiplyScalar(p.intensity),c.direction.setFromMatrixPosition(p.matrixWorld),o.setFromMatrixPosition(p.target.matrixWorld),c.direction.sub(o),c.direction.transformDirection(A),p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,n.directionalShadow[b]=o,n.directionalShadowMap[b]=B,n.directionalShadowMatrix[b]=p.shadow.matrix,T++}n.directional[b]=c,b++}else if(p.isSpotLight){const c=e.get(p);if(c.position.setFromMatrixPosition(p.matrixWorld),c.position.applyMatrix4(A),c.color.copy(m).multiplyScalar(C),c.distance=R,c.direction.setFromMatrixPosition(p.matrixWorld),o.setFromMatrixPosition(p.target.matrixWorld),c.direction.sub(o),c.direction.transformDirection(A),c.coneCos=Math.cos(p.angle),c.penumbraCos=Math.cos(p.angle*(1-p.penumbra)),c.decay=p.decay,p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,n.spotShadow[_]=o,n.spotShadowMap[_]=B,n.spotShadowMatrix[_]=p.shadow.matrix,L++}n.spot[_]=c,_++}else if(p.isRectAreaLight){const t=e.get(p);t.color.copy(m).multiplyScalar(C),t.position.setFromMatrixPosition(p.matrixWorld),t.position.applyMatrix4(A),h.identity(),c.copy(p.matrixWorld),c.premultiply(A),h.extractRotation(c),t.halfWidth.set(.5*p.width,0,0),t.halfHeight.set(0,.5*p.height,0),t.halfWidth.applyMatrix4(h),t.halfHeight.applyMatrix4(h),n.rectArea[w]=t,w++}else if(p.isPointLight){const o=e.get(p);if(o.position.setFromMatrixPosition(p.matrixWorld),o.position.applyMatrix4(A),o.color.copy(p.color).multiplyScalar(p.intensity),o.distance=p.distance,o.decay=p.decay,p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,o.shadowCameraNear=e.camera.near,o.shadowCameraFar=e.camera.far,n.pointShadow[M]=o,n.pointShadowMap[M]=B,n.pointShadowMatrix[M]=p.shadow.matrix,E++}n.point[M]=o,M++}else if(p.isHemisphereLight){const t=e.get(p);t.direction.setFromMatrixPosition(p.matrixWorld),t.direction.transformDirection(A),t.direction.normalize(),t.skyColor.copy(p.color).multiplyScalar(C),t.groundColor.copy(p.groundColor).multiplyScalar(C),n.hemi[S]=t,S++}}n.ambient[0]=g,n.ambient[1]=y,n.ambient[2]=x;const C=n.hash;C.directionalLength===b&&C.pointLength===M&&C.spotLength===_&&C.rectAreaLength===w&&C.hemiLength===S&&C.numDirectionalShadows===T&&C.numPointShadows===E&&C.numSpotShadows===L||(n.directional.length=b,n.spot.length=_,n.rectArea.length=w,n.point.length=M,n.hemi.length=S,n.directionalShadow.length=T,n.directionalShadowMap.length=T,n.pointShadow.length=E,n.pointShadowMap.length=E,n.spotShadow.length=L,n.spotShadowMap.length=L,n.directionalShadowMatrix.length=T,n.pointShadowMatrix.length=E,n.spotShadowMatrix.length=L,C.directionalLength=b,C.pointLength=M,C.spotLength=_,C.rectAreaLength=w,C.hemiLength=S,C.numDirectionalShadows=T,C.numPointShadows=E,C.numSpotShadows=L,n.version=ws++)}return{setup:setup,state:n}}function WebGLRenderState(){const e=new WebGLLights,t=[],n=[];function init(){t.length=0,n.length=0}function pushLight(e){t.push(e)}function pushShadow(e){n.push(e)}function setupLights(o){e.setup(t,n,o)}const o={lightsArray:t,shadowsArray:n,lights:e};return{init:init,state:o,setupLights:setupLights,pushLight:pushLight,pushShadow:pushShadow}}function WebGLRenderStates(){let e=new WeakMap;function onSceneDispose(t){const n=t.target;n.removeEventListener("dispose",onSceneDispose),e.delete(n)}function get(t,n){let o;return!1===e.has(t)?(o=new WebGLRenderState,e.set(t,new WeakMap),e.get(t).set(n,o),t.addEventListener("dispose",onSceneDispose)):!1===e.get(t).has(n)?(o=new WebGLRenderState,e.get(t).set(n,o)):o=e.get(t).get(n),o}function dispose(){e=new WeakMap}return{get:get,dispose:dispose}}function MeshDepthMaterial(e){Material.call(this),this.type="MeshDepthMaterial",this.depthPacking=mn,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function MeshDistanceMaterial(e){Material.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Vector3,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}MeshDepthMaterial.prototype=Object.create(Material.prototype),MeshDepthMaterial.prototype.constructor=MeshDepthMaterial,MeshDepthMaterial.prototype.isMeshDepthMaterial=!0,MeshDepthMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},MeshDistanceMaterial.prototype=Object.create(Material.prototype),MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial,MeshDistanceMaterial.prototype.isMeshDistanceMaterial=!0,MeshDistanceMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this};var Ss="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",Ts="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";function WebGLShadowMap(e,t,n){let o=new Frustum;const c=new Vector2,h=new Vector2,d=new Vector4,p=[],m=[],g={},y={0:T,1:S,2:E},x=new ShaderMaterial({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:Ts,fragmentShader:Ss}),b=x.clone();b.defines.HORIZONAL_PASS=1;const _=new BufferGeometry;_.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const L=new Mesh(_,x),A=this;function VSMPass(n,o){const c=t.update(L);x.uniforms.shadow_pass.value=n.map.texture,x.uniforms.resolution.value=n.mapSize,x.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(o,null,c,x,L,null),b.uniforms.shadow_pass.value=n.mapPass.texture,b.uniforms.resolution.value=n.mapSize,b.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(o,null,c,b,L,null)}function getDepthMaterialVariant(e,t,n){const o=e<<0|t<<1|n<<2;let c=p[o];return void 0===c&&(c=new MeshDepthMaterial({depthPacking:gn,morphTargets:e,skinning:t}),p[o]=c),c}function getDistanceMaterialVariant(e,t,n){const o=e<<0|t<<1|n<<2;let c=m[o];return void 0===c&&(c=new MeshDistanceMaterial({morphTargets:e,skinning:t}),m[o]=c),c}function getDepthMaterial(t,n,o,c,h,d,p){let m=null,x=getDepthMaterialVariant,b=t.customDepthMaterial;if(!0===c.isPointLight&&(x=getDistanceMaterialVariant,b=t.customDistanceMaterial),void 0===b){let e=!1;!0===o.morphTargets&&(e=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let c=!1;!0===t.isSkinnedMesh&&(!0===o.skinning?c=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t));const h=!0===t.isInstancedMesh;m=x(e,c,h)}else m=b;if(e.localClippingEnabled&&!0===o.clipShadows&&0!==o.clippingPlanes.length){const e=m.uuid,t=o.uuid;let n=g[e];void 0===n&&(n={},g[e]=n);let c=n[t];void 0===c&&(c=m.clone(),n[t]=c),m=c}return m.visible=o.visible,m.wireframe=o.wireframe,m.side=p===w?null!==o.shadowSide?o.shadowSide:o.side:null!==o.shadowSide?o.shadowSide:y[o.side],m.clipShadows=o.clipShadows,m.clippingPlanes=o.clippingPlanes,m.clipIntersection=o.clipIntersection,m.wireframeLinewidth=o.wireframeLinewidth,m.linewidth=o.linewidth,!0===c.isPointLight&&!0===m.isMeshDistanceMaterial&&(m.referencePosition.setFromMatrixPosition(c.matrixWorld),m.nearDistance=h,m.farDistance=d),m}function renderObject(n,c,h,d,p){if(!1===n.visible)return;const m=n.layers.test(c.layers);if(m&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&p===w)&&(!n.frustumCulled||o.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse,n.matrixWorld);const o=t.update(n),c=n.material;if(Array.isArray(c)){const t=o.groups;for(let m=0,g=t.length;m<g;m++){const g=t[m],y=c[g.materialIndex];if(y&&y.visible){const t=getDepthMaterial(n,o,y,d,h.near,h.far,p);e.renderBufferDirect(h,null,o,t,n,g)}}}else if(c.visible){const t=getDepthMaterial(n,o,c,d,h.near,h.far,p);e.renderBufferDirect(h,null,o,t,n,null)}}const g=n.children;for(let e=0,t=g.length;e<t;e++)renderObject(g[e],c,h,d,p)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=M,this.render=function(t,p,m){if(!1===A.enabled)return;if(!1===A.autoUpdate&&!1===A.needsUpdate)return;if(0===t.length)return;const g=e.getRenderTarget(),y=e.getActiveCubeFace(),x=e.getActiveMipmapLevel(),b=e.state;b.setBlending(C),b.buffers.color.setClear(1,1,1,1),b.buffers.depth.setTest(!0),b.setScissorTest(!1);for(let M=0,_=t.length;M<_;M++){const g=t[M],y=g.shadow;if(!1===y.autoUpdate&&!1===y.needsUpdate)continue;if(void 0===y){console.warn("THREE.WebGLShadowMap:",g,"has no shadow.");continue}c.copy(y.mapSize);const x=y.getFrameExtents();if(c.multiply(x),h.copy(y.mapSize),(c.x>n||c.y>n)&&(c.x>n&&(h.x=Math.floor(n/x.x),c.x=h.x*x.x,y.mapSize.x=h.x),c.y>n&&(h.y=Math.floor(n/x.y),c.y=h.y*x.y,y.mapSize.y=h.y)),null===y.map&&!y.isPointLightShadow&&this.type===w){const e={minFilter:Ce,magFilter:Ce,format:Ye};y.map=new WebGLRenderTarget(c.x,c.y,e),y.map.texture.name=g.name+".shadowMap",y.mapPass=new WebGLRenderTarget(c.x,c.y,e),y.camera.updateProjectionMatrix()}if(null===y.map){const e={minFilter:Se,magFilter:Se,format:Ye};y.map=new WebGLRenderTarget(c.x,c.y,e),y.map.texture.name=g.name+".shadowMap",y.camera.updateProjectionMatrix()}e.setRenderTarget(y.map),e.clear();const _=y.getViewportCount();for(let e=0;e<_;e++){const t=y.getViewport(e);d.set(h.x*t.x,h.y*t.y,h.x*t.z,h.y*t.w),b.viewport(d),y.updateMatrices(g,e),o=y.getFrustum(),renderObject(p,m,y.camera,g,this.type)}y.isPointLightShadow||this.type!==w||VSMPass(y,m),y.needsUpdate=!1}A.needsUpdate=!1,e.setRenderTarget(g,y,x)}}function WebGLState(e,t,n){const o=n.isWebGL2;function ColorBuffer(){let t=!1;const n=new Vector4;let o=null;const c=new Vector4(0,0,0,0);return{setMask:function(n){o===n||t||(e.colorMask(n,n,n,n),o=n)},setLocked:function(e){t=e},setClear:function(t,o,h,d,p){!0===p&&(t*=d,o*=d,h*=d),n.set(t,o,h,d),!1===c.equals(n)&&(e.clearColor(t,o,h,d),c.copy(n))},reset:function(){t=!1,o=null,c.set(-1,0,0,0)}}}function DepthBuffer(){let t=!1,n=null,o=null,c=null;return{setTest:function(e){e?enable(2929):disable(2929)},setMask:function(o){n===o||t||(e.depthMask(o),n=o)},setFunc:function(t){if(o!==t){if(t)switch(t){case Q:e.depthFunc(512);break;case K:e.depthFunc(519);break;case $:e.depthFunc(513);break;case ee:e.depthFunc(515);break;case te:e.depthFunc(514);break;case ne:e.depthFunc(518);break;case re:e.depthFunc(516);break;case ie:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);o=t}},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearDepth(t),c=t)},reset:function(){t=!1,n=null,o=null,c=null}}}function StencilBuffer(){let t=!1,n=null,o=null,c=null,h=null,d=null,p=null,m=null,g=null;return{setTest:function(e){t||(e?enable(2960):disable(2960))},setMask:function(o){n===o||t||(e.stencilMask(o),n=o)},setFunc:function(t,n,d){o===t&&c===n&&h===d||(e.stencilFunc(t,n,d),o=t,c=n,h=d)},setOp:function(t,n,o){d===t&&p===n&&m===o||(e.stencilOp(t,n,o),d=t,p=n,m=o)},setLocked:function(e){t=e},setClear:function(t){g!==t&&(e.clearStencil(t),g=t)},reset:function(){t=!1,n=null,o=null,c=null,h=null,d=null,p=null,m=null,g=null}}}const c=new ColorBuffer,h=new DepthBuffer,g=new StencilBuffer;let y={},x=null,b=null,M=null,_=null,w=null,S=null,L=null,A=null,oe=null,ae=!1,se=null,ce=null,le=null,ue=null,he=null;const de=e.getParameter(35661);let pe=!1,fe=0;const me=e.getParameter(7938);-1!==me.indexOf("WebGL")?(fe=parseFloat(/^WebGL\ ([0-9])/.exec(me)[1]),pe=fe>=1):-1!==me.indexOf("OpenGL ES")&&(fe=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(me)[1]),pe=fe>=2);let ge=null,ye={};const ve=new Vector4,xe=new Vector4;function createTexture(t,n,o){const c=new Uint8Array(4),h=e.createTexture();e.bindTexture(t,h),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let d=0;d<o;d++)e.texImage2D(n+d,0,6408,1,1,0,6408,5121,c);return h}const be={};function enable(t){!0!==y[t]&&(e.enable(t),y[t]=!0)}function disable(t){!1!==y[t]&&(e.disable(t),y[t]=!1)}function useProgram(t){return x!==t&&(e.useProgram(t),x=t,!0)}be[3553]=createTexture(3553,3553,1),be[34067]=createTexture(34067,34069,6),c.setClear(0,0,0,1),h.setClear(1),g.setClear(0),enable(2929),h.setFunc(ee),setFlipSided(!1),setCullFace(p),enable(2884),setBlending(C);const Me={[I]:32774,[O]:32778,[V]:32779};if(o)Me[N]=32775,Me[F]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(Me[N]=e.MIN_EXT,Me[F]=e.MAX_EXT)}const _e={[U]:0,[z]:1,[H]:768,[j]:770,[J]:776,[Y]:774,[q]:772,[k]:769,[W]:771,[Z]:775,[X]:773};function setBlending(t,n,o,c,h,d,p,m){if(t!==C){if(b||(enable(3042),b=!0),t===G)h=h||n,d=d||o,p=p||c,n===_&&h===L||(e.blendEquationSeparate(Me[n],Me[h]),_=n,L=h),o===w&&c===S&&d===A&&p===oe||(e.blendFuncSeparate(_e[o],_e[c],_e[d],_e[p]),w=o,S=c,A=d,oe=p),M=t,ae=null;else if(t!==M||m!==ae){if(_===I&&L===I||(e.blendEquation(32774),_=I,L=I),m)switch(t){case P:e.blendFuncSeparate(1,771,1,771);break;case R:e.blendFunc(1,1);break;case B:e.blendFuncSeparate(0,0,769,771);break;case D:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}else switch(t){case P:e.blendFuncSeparate(770,771,1,771);break;case R:e.blendFunc(770,1);break;case B:e.blendFunc(0,769);break;case D:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}w=null,S=null,A=null,oe=null,M=t,ae=m}}else b&&(disable(3042),b=!1)}function setMaterial(e,t){e.side===E?disable(2884):enable(2884);let n=e.side===T;t&&(n=!n),setFlipSided(n),e.blending===P&&!1===e.transparent?setBlending(C):setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),h.setFunc(e.depthFunc),h.setTest(e.depthTest),h.setMask(e.depthWrite),c.setMask(e.colorWrite);const o=e.stencilWrite;g.setTest(o),o&&(g.setMask(e.stencilWriteMask),g.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),g.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits)}function setFlipSided(t){se!==t&&(t?e.frontFace(2304):e.frontFace(2305),se=t)}function setCullFace(t){t!==d?(enable(2884),t!==ce&&(t===p?e.cullFace(1029):t===m?e.cullFace(1028):e.cullFace(1032))):disable(2884),ce=t}function setLineWidth(t){t!==le&&(pe&&e.lineWidth(t),le=t)}function setPolygonOffset(t,n,o){t?(enable(32823),ue===n&&he===o||(e.polygonOffset(n,o),ue=n,he=o)):disable(32823)}function setScissorTest(e){e?enable(3089):disable(3089)}function activeTexture(t){void 0===t&&(t=33984+de-1),ge!==t&&(e.activeTexture(t),ge=t)}function bindTexture(t,n){null===ge&&activeTexture();let o=ye[ge];void 0===o&&(o={type:void 0,texture:void 0},ye[ge]=o),o.type===t&&o.texture===n||(e.bindTexture(t,n||be[t]),o.type=t,o.texture=n)}function unbindTexture(){const t=ye[ge];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)}function compressedTexImage2D(){try{e.compressedTexImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function texImage2D(){try{e.texImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function texImage3D(){try{e.texImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function scissor(t){!1===ve.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),ve.copy(t))}function viewport(t){!1===xe.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),xe.copy(t))}function reset(){y={},ge=null,ye={},x=null,M=null,se=null,ce=null,c.reset(),h.reset(),g.reset()}return{buffers:{color:c,depth:h,stencil:g},enable:enable,disable:disable,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset}}function WebGLTextures(e,t,n,o,c,h,d){const p=c.isWebGL2,m=c.maxTextures,g=c.maxCubemapSize,y=c.maxTextureSize,x=c.maxSamples,b=new WeakMap;let M,_=!1;try{_="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(A){}function createCanvas(e,t){return _?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function resizeImage(e,t,n,o){let c=1;if((e.width>o||e.height>o)&&(c=o/Math.max(e.width,e.height)),c<1||!0===t){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap){const o=t?Wn.floorPowerOfTwo:Math.floor,h=o(c*e.width),d=o(c*e.height);void 0===M&&(M=createCanvas(h,d));const p=n?createCanvas(h,d):M;p.width=h,p.height=d;const m=p.getContext("2d");return m.drawImage(e,0,0,h,d),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+h+"x"+d+")."),p}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function isPowerOfTwo(e){return Wn.isPowerOfTwo(e.width)&&Wn.isPowerOfTwo(e.height)}function textureNeedsPowerOfTwo(e){return!p&&(e.wrapS!==_e||e.wrapT!==_e||e.minFilter!==Se&&e.minFilter!==Ce)}function textureNeedsGenerateMipmaps(e,t){return e.generateMipmaps&&t&&e.minFilter!==Se&&e.minFilter!==Ce}function generateMipmap(t,n,c,h){e.generateMipmap(t);const d=o.get(n);d.__maxMipLevel=Math.log(Math.max(c,h))*Math.LOG2E}function getInternalFormat(n,o,c){if(!1===p)return o;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let h=o;return 6403===o&&(5126===c&&(h=33326),5131===c&&(h=33325),5121===c&&(h=33321)),6407===o&&(5126===c&&(h=34837),5131===c&&(h=34843),5121===c&&(h=32849)),6408===o&&(5126===c&&(h=34836),5131===c&&(h=34842),5121===c&&(h=32856)),33325!==h&&33326!==h&&34842!==h&&34836!==h||t.get("EXT_color_buffer_float"),h}function filterFallback(e){return e===Se||e===Te||e===Le?9728:9729}function onTextureDispose(e){const t=e.target;t.removeEventListener("dispose",onTextureDispose),deallocateTexture(t),t.isVideoTexture&&b.delete(t),d.memory.textures--}function onRenderTargetDispose(e){const t=e.target;t.removeEventListener("dispose",onRenderTargetDispose),deallocateRenderTarget(t),d.memory.textures--}function deallocateTexture(t){const n=o.get(t);void 0!==n.__webglInit&&(e.deleteTexture(n.__webglTexture),o.remove(t))}function deallocateRenderTarget(t){const n=o.get(t),c=o.get(t.texture);if(t){if(void 0!==c.__webglTexture&&e.deleteTexture(c.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&e.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer);o.remove(t.texture),o.remove(t)}}let w=0;function resetTextureUnits(){w=0}function allocateTextureUnit(){const e=w;return e>=m&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+m),w+=1,e}function setTexture2D(e,t){const c=o.get(e);if(e.isVideoTexture&&updateVideoTexture(e),e.version>0&&c.__version!==e.version){const n=e.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void uploadTexture(c,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,c.__webglTexture)}function setTexture2DArray(e,t){const c=o.get(e);e.version>0&&c.__version!==e.version?uploadTexture(c,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,c.__webglTexture))}function setTexture3D(e,t){const c=o.get(e);e.version>0&&c.__version!==e.version?uploadTexture(c,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,c.__webglTexture))}function setTextureCube(t,c){if(6!==t.image.length)return;const d=o.get(t);if(t.version>0&&d.__version!==t.version){initTexture(d,t),n.activeTexture(33984+c),n.bindTexture(34067,d.__webglTexture),e.pixelStorei(37440,t.flipY);const o=t&&(t.isCompressedTexture||t.image[0].isCompressedTexture),m=t.image[0]&&t.image[0].isDataTexture,y=[];for(let e=0;e<6;e++)y[e]=o||m?m?t.image[e].image:t.image[e]:resizeImage(t.image[e],!1,!0,g);const x=y[0],b=isPowerOfTwo(x)||p,M=h.convert(t.format),_=h.convert(t.type),w=getInternalFormat(t.internalFormat,M,_);let S;if(setTextureParameters(34067,t,b),o){for(let e=0;e<6;e++){S=y[e].mipmaps;for(let o=0;o<S.length;o++){const c=S[o];t.format!==Ye&&t.format!==Xe?null!==M?n.compressedTexImage2D(34069+e,o,w,c.width,c.height,0,c.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+e,o,w,c.width,c.height,0,M,_,c.data)}}d.__maxMipLevel=S.length-1}else{S=t.mipmaps;for(let e=0;e<6;e++)if(m){n.texImage2D(34069+e,0,w,y[e].width,y[e].height,0,M,_,y[e].data);for(let t=0;t<S.length;t++){const o=S[t],c=o.image[e].image;n.texImage2D(34069+e,t+1,w,c.width,c.height,0,M,_,c.data)}}else{n.texImage2D(34069+e,0,w,M,_,y[e]);for(let t=0;t<S.length;t++){const o=S[t];n.texImage2D(34069+e,t+1,w,M,_,o.image[e])}}d.__maxMipLevel=S.length}textureNeedsGenerateMipmaps(t,b)&&generateMipmap(34067,t,x.width,x.height),d.__version=t.version,t.onUpdate&&t.onUpdate(t)}else n.activeTexture(33984+c),n.bindTexture(34067,d.__webglTexture)}function setTextureCubeDynamic(e,t){n.activeTexture(33984+t),n.bindTexture(34067,o.get(e).__webglTexture)}const S={[Me]:10497,[_e]:33071,[we]:33648},T={[Se]:9728,[Te]:9984,[Le]:9986,[Ce]:9729,[Pe]:9985,[Be]:9987};function setTextureParameters(n,h,d){d?(e.texParameteri(n,10242,S[h.wrapS]),e.texParameteri(n,10243,S[h.wrapT]),32879!==n&&35866!==n||e.texParameteri(n,32882,S[h.wrapR]),e.texParameteri(n,10240,T[h.magFilter]),e.texParameteri(n,10241,T[h.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),32879!==n&&35866!==n||e.texParameteri(n,32882,33071),h.wrapS===_e&&h.wrapT===_e||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,filterFallback(h.magFilter)),e.texParameteri(n,10241,filterFallback(h.minFilter)),h.minFilter!==Se&&h.minFilter!==Ce&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const m=t.get("EXT_texture_filter_anisotropic");if(m){if(h.type===Ue&&null===t.get("OES_texture_float_linear"))return;if(h.type===ze&&null===(p||t.get("OES_texture_half_float_linear")))return;(h.anisotropy>1||o.get(h).__currentAnisotropy)&&(e.texParameterf(n,m.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(h.anisotropy,c.getMaxAnisotropy())),o.get(h).__currentAnisotropy=h.anisotropy)}}function initTexture(t,n){void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",onTextureDispose),t.__webglTexture=e.createTexture(),d.memory.textures++)}function uploadTexture(t,o,c){let d=3553;o.isDataTexture2DArray&&(d=35866),o.isDataTexture3D&&(d=32879),initTexture(t,o),n.activeTexture(33984+c),n.bindTexture(d,t.__webglTexture),e.pixelStorei(37440,o.flipY),e.pixelStorei(37441,o.premultiplyAlpha),e.pixelStorei(3317,o.unpackAlignment);const m=textureNeedsPowerOfTwo(o)&&!1===isPowerOfTwo(o.image),g=resizeImage(o.image,m,!1,y),x=isPowerOfTwo(g)||p,b=h.convert(o.format);let M,_=h.convert(o.type),w=getInternalFormat(o.internalFormat,b,_);setTextureParameters(d,o,x);const S=o.mipmaps;if(o.isDepthTexture)w=6402,p?w=o.type===Ue?36012:o.type===Fe?33190:o.type===We?35056:33189:o.type===Ue&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),o.format===Ke&&6402===w&&o.type!==Ve&&o.type!==Fe&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),o.type=Ve,_=h.convert(o.type)),o.format===$e&&6402===w&&(w=34041,o.type!==We&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),o.type=We,_=h.convert(o.type))),n.texImage2D(3553,0,w,g.width,g.height,0,b,_,null);else if(o.isDataTexture)if(S.length>0&&x){for(let e=0,t=S.length;e<t;e++)M=S[e],n.texImage2D(3553,e,w,M.width,M.height,0,b,_,M.data);o.generateMipmaps=!1,t.__maxMipLevel=S.length-1}else n.texImage2D(3553,0,w,g.width,g.height,0,b,_,g.data),t.__maxMipLevel=0;else if(o.isCompressedTexture){for(let e=0,t=S.length;e<t;e++)M=S[e],o.format!==Ye&&o.format!==Xe?null!==b?n.compressedTexImage2D(3553,e,w,M.width,M.height,0,M.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,e,w,M.width,M.height,0,b,_,M.data);t.__maxMipLevel=S.length-1}else if(o.isDataTexture2DArray)n.texImage3D(35866,0,w,g.width,g.height,g.depth,0,b,_,g.data),t.__maxMipLevel=0;else if(o.isDataTexture3D)n.texImage3D(32879,0,w,g.width,g.height,g.depth,0,b,_,g.data),t.__maxMipLevel=0;else if(S.length>0&&x){for(let e=0,t=S.length;e<t;e++)M=S[e],n.texImage2D(3553,e,w,b,_,M);o.generateMipmaps=!1,t.__maxMipLevel=S.length-1}else n.texImage2D(3553,0,w,b,_,g),t.__maxMipLevel=0;textureNeedsGenerateMipmaps(o,x)&&generateMipmap(d,o,g.width,g.height),t.__version=o.version,o.onUpdate&&o.onUpdate(o)}function setupFrameBufferTexture(t,c,d,p){const m=h.convert(c.texture.format),g=h.convert(c.texture.type),y=getInternalFormat(c.texture.internalFormat,m,g);n.texImage2D(p,0,y,c.width,c.height,0,m,g,null),e.bindFramebuffer(36160,t),e.framebufferTexture2D(36160,d,p,o.get(c.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function setupRenderBufferStorage(t,n,o){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let c=33189;if(o){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===Ue?c=36012:t.type===Fe&&(c=33190));const o=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,o,c,n.width,n.height)}else e.renderbufferStorage(36161,c,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){if(o){const t=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,t,35056,n.width,n.height)}else e.renderbufferStorage(36161,34041,n.width,n.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=h.convert(n.texture.format),c=h.convert(n.texture.type),d=getInternalFormat(n.texture.internalFormat,t,c);if(o){const t=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,t,d,n.width,n.height)}else e.renderbufferStorage(36161,d,n.width,n.height)}e.bindRenderbuffer(36161,null)}function setupDepthTexture(t,n){const c=n&&n.isWebGLCubeRenderTarget;if(c)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");o.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),setTexture2D(n.depthTexture,0);const h=o.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===Ke)e.framebufferTexture2D(36160,36096,3553,h,0);else{if(n.depthTexture.format!==$e)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,h,0)}}function setupDepthRenderbuffer(t){const n=o.get(t),c=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(c)throw new Error("target.depthTexture not supported in Cube render targets");setupDepthTexture(n.__webglFramebuffer,t)}else if(c){n.__webglDepthbuffer=[];for(let o=0;o<6;o++)e.bindFramebuffer(36160,n.__webglFramebuffer[o]),n.__webglDepthbuffer[o]=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer[o],t,!1)}else e.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer,t,!1);e.bindFramebuffer(36160,null)}function setupRenderTarget(t){const c=o.get(t),m=o.get(t.texture);t.addEventListener("dispose",onRenderTargetDispose),m.__webglTexture=e.createTexture(),d.memory.textures++;const g=!0===t.isWebGLCubeRenderTarget,y=!0===t.isWebGLMultisampleRenderTarget,x=isPowerOfTwo(t)||p;if(!p||t.texture.format!==Xe||t.texture.type!==Ue&&t.texture.type!==ze||(t.texture.format=Ye,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),g){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else if(c.__webglFramebuffer=e.createFramebuffer(),y)if(p){c.__webglMultisampledFramebuffer=e.createFramebuffer(),c.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,c.__webglColorRenderbuffer);const n=h.convert(t.texture.format),o=h.convert(t.texture.type),d=getInternalFormat(t.texture.internalFormat,n,o),p=getRenderTargetSamples(t);e.renderbufferStorageMultisample(36161,p,d,t.width,t.height),e.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,c.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(c.__webglDepthRenderbuffer=e.createRenderbuffer(),setupRenderBufferStorage(c.__webglDepthRenderbuffer,t,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(g){n.bindTexture(34067,m.__webglTexture),setTextureParameters(34067,t.texture,x);for(let e=0;e<6;e++)setupFrameBufferTexture(c.__webglFramebuffer[e],t,36064,34069+e);textureNeedsGenerateMipmaps(t.texture,x)&&generateMipmap(34067,t.texture,t.width,t.height),n.bindTexture(34067,null)}else n.bindTexture(3553,m.__webglTexture),setTextureParameters(3553,t.texture,x),setupFrameBufferTexture(c.__webglFramebuffer,t,36064,3553),textureNeedsGenerateMipmaps(t.texture,x)&&generateMipmap(3553,t.texture,t.width,t.height),n.bindTexture(3553,null);t.depthBuffer&&setupDepthRenderbuffer(t)}function updateRenderTargetMipmap(e){const t=e.texture,c=isPowerOfTwo(e)||p;if(textureNeedsGenerateMipmaps(t,c)){const c=e.isWebGLCubeRenderTarget?34067:3553,h=o.get(t).__webglTexture;n.bindTexture(c,h),generateMipmap(c,t,e.width,e.height),n.bindTexture(c,null)}}function updateMultisampleRenderTarget(t){if(t.isWebGLMultisampleRenderTarget)if(p){const n=o.get(t);e.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,n.__webglFramebuffer);const c=t.width,h=t.height;let d=16384;t.depthBuffer&&(d|=256),t.stencilBuffer&&(d|=1024),e.blitFramebuffer(0,0,c,h,0,0,c,h,d,9728),e.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function getRenderTargetSamples(e){return p&&e.isWebGLMultisampleRenderTarget?Math.min(x,e.samples):0}function updateVideoTexture(e){const t=d.render.frame;b.get(e)!==t&&(b.set(e,t),e.update())}let E=!1,L=!1;function safeSetTexture2D(e,t){e&&e.isWebGLRenderTarget&&(!1===E&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),E=!0),e=e.texture),setTexture2D(e,t)}function safeSetTextureCube(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===L&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),L=!0),e=e.texture),e&&e.isCubeTexture||Array.isArray(e.image)&&6===e.image.length?setTextureCube(e,t):setTextureCubeDynamic(e,t)}this.allocateTextureUnit=allocateTextureUnit,this.resetTextureUnits=resetTextureUnits,this.setTexture2D=setTexture2D,this.setTexture2DArray=setTexture2DArray,this.setTexture3D=setTexture3D,this.setTextureCube=setTextureCube,this.setTextureCubeDynamic=setTextureCubeDynamic,this.setupRenderTarget=setupRenderTarget,this.updateRenderTargetMipmap=updateRenderTargetMipmap,this.updateMultisampleRenderTarget=updateMultisampleRenderTarget,this.safeSetTexture2D=safeSetTexture2D,this.safeSetTextureCube=safeSetTextureCube}function WebGLUtils(e,t,n){const o=n.isWebGL2;function convert(e){let n;if(e===Ge)return 5121;if(e===He)return 32819;if(e===ke)return 32820;if(e===je)return 33635;if(e===Ie)return 5120;if(e===Oe)return 5122;if(e===Ve)return 5123;if(e===Ne)return 5124;if(e===Fe)return 5125;if(e===Ue)return 5126;if(e===ze)return o?5131:(n=t.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(e===qe)return 6406;if(e===Xe)return 6407;if(e===Ye)return 6408;if(e===Ze)return 6409;if(e===Je)return 6410;if(e===Ke)return 6402;if(e===$e)return 34041;if(e===et)return 6403;if(e===tt)return 36244;if(e===nt)return 33319;if(e===rt)return 33320;if(e===it)return 36248;if(e===ot)return 36249;if(e===at||e===st||e===ct||e===lt){if(n=t.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(e===at)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===st)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===ct)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===lt)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===ut||e===ht||e===dt||e===pt){if(n=t.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(e===ut)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===ht)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===dt)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===pt)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===ft)return n=t.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((e===mt||e===gt)&&(n=t.get("WEBGL_compressed_texture_etc"),null!==n)){if(e===mt)return n.COMPRESSED_RGB8_ETC2;if(e===gt)return n.COMPRESSED_RGBA8_ETC2_EAC}return e===yt||e===vt||e===xt||e===bt||e===Mt||e===_t||e===wt||e===St||e===Tt||e===Et||e===Lt||e===At||e===Ct||e===Pt||e===Bt||e===Dt||e===Gt||e===It||e===Ot||e===Vt||e===Nt||e===Ft||e===Ut||e===zt||e===Ht||e===kt||e===jt||e===Wt?(n=t.get("WEBGL_compressed_texture_astc"),null!==n?e:null):e===Rt?(n=t.get("EXT_texture_compression_bptc"),null!==n?e:null):e===We?o?34042:(n=t.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}return{convert:convert}}function ArrayCamera(e){PerspectiveCamera.call(this),this.cameras=e||[]}function Group(){Object3D.call(this),this.type="Group"}function WebXRController(){this._targetRay=null,this._grip=null}function WebXRManager(e,t){const n=this;let o=null,c=1,h=null,d="local-floor",p=null;const m=[],g=new Map,y=new PerspectiveCamera;y.layers.enable(1),y.viewport=new Vector4;const x=new PerspectiveCamera;x.layers.enable(2),x.viewport=new Vector4;const b=[y,x],M=new ArrayCamera;M.layers.enable(1),M.layers.enable(2);let _=null,w=null;function onSessionEvent(e){const t=g.get(e.inputSource);t&&t.dispatchEvent({type:e.type})}function onSessionEnd(){g.forEach((function(e,t){e.disconnect(t)})),g.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),L.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function onRequestReferenceSpace(e){h=e,L.setContext(o),L.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}function updateInputSources(e){const t=o.inputSources;for(let n=0;n<m.length;n++)g.set(t[n],m[n]);for(let n=0;n<e.removed.length;n++){const t=e.removed[n],o=g.get(t);o&&(o.dispatchEvent({type:"disconnected",data:t}),g.delete(t))}for(let n=0;n<e.added.length;n++){const t=e.added[n],o=g.get(t);o&&o.dispatchEvent({type:"connected",data:t})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=m[e];return void 0===t&&(t=new WebXRController,m[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=m[e];return void 0===t&&(t=new WebXRController,m[e]=t),t.getGripSpace()},this.setFramebufferScaleFactor=function(e){c=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){d=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return h},this.getSession=function(){return o},this.setSession=function(e){if(o=e,null!==o){o.addEventListener("select",onSessionEvent),o.addEventListener("selectstart",onSessionEvent),o.addEventListener("selectend",onSessionEvent),o.addEventListener("squeeze",onSessionEvent),o.addEventListener("squeezestart",onSessionEvent),o.addEventListener("squeezeend",onSessionEvent),o.addEventListener("end",onSessionEnd);const e=t.getContextAttributes();!0!==e.xrCompatible&&t.makeXRCompatible();const n={antialias:e.antialias,alpha:e.alpha,depth:e.depth,stencil:e.stencil,framebufferScaleFactor:c},h=new XRWebGLLayer(o,t,n);o.updateRenderState({baseLayer:h}),o.requestReferenceSpace(d).then(onRequestReferenceSpace),o.addEventListener("inputsourceschange",updateInputSources)}};const S=new Vector3,T=new Vector3;function setProjectionFromUnion(e,t,n){S.setFromMatrixPosition(t.matrixWorld),T.setFromMatrixPosition(n.matrixWorld);const o=S.distanceTo(T),c=t.projectionMatrix.elements,h=n.projectionMatrix.elements,d=c[14]/(c[10]-1),p=c[14]/(c[10]+1),m=(c[9]+1)/c[5],g=(c[9]-1)/c[5],y=(c[8]-1)/c[0],x=(h[8]+1)/h[0],b=d*y,M=d*x,_=o/(-y+x),w=_*-y;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(w),e.translateZ(_),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.getInverse(e.matrixWorld);const E=d+_,L=p+_,A=b-w,C=M+(o-w),P=m*p/L*E,R=g*p/L*E;e.projectionMatrix.makePerspective(A,C,P,R,E,L)}function updateCamera(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.getInverse(e.matrixWorld)}this.getCamera=function(e){M.near=x.near=y.near=e.near,M.far=x.far=y.far=e.far,_===M.near&&w===M.far||(o.updateRenderState({depthNear:M.near,depthFar:M.far}),_=M.near,w=M.far);const t=e.parent,n=M.cameras;updateCamera(M,t);for(let o=0;o<n.length;o++)updateCamera(n[o],t);e.matrixWorld.copy(M.matrixWorld);const c=e.children;for(let o=0,h=c.length;o<h;o++)c[o].updateMatrixWorld(!0);return 2===n.length?setProjectionFromUnion(M,y,x):M.projectionMatrix.copy(y.projectionMatrix),M};let E=null;function onAnimationFrame(t,n){if(p=n.getViewerPose(h),null!==p){const t=p.views,n=o.renderState.baseLayer;e.setFramebuffer(n.framebuffer);let c=!1;t.length!==M.cameras.length&&(M.cameras.length=0,c=!0);for(let e=0;e<t.length;e++){const o=t[e],h=n.getViewport(o),d=b[e];d.matrix.fromArray(o.transform.matrix),d.projectionMatrix.fromArray(o.projectionMatrix),d.viewport.set(h.x,h.y,h.width,h.height),0===e&&M.matrix.copy(d.matrix),!0===c&&M.cameras.push(d)}}const c=o.inputSources;for(let e=0;e<m.length;e++){const t=m[e],o=c[e];t.update(o,n,h)}E&&E(t,n)}const L=new WebGLAnimation;L.setAnimationLoop(onAnimationFrame),this.setAnimationLoop=function(e){E=e},this.dispose=function(){}}function WebGLMaterials(e){function refreshFogUniforms(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)}function refreshMaterialUniforms(e,t,n,o,c){t.isMeshBasicMaterial?refreshUniformsCommon(e,t):t.isMeshLambertMaterial?(refreshUniformsCommon(e,t),refreshUniformsLambert(e,t)):t.isMeshToonMaterial?(refreshUniformsCommon(e,t),refreshUniformsToon(e,t)):t.isMeshPhongMaterial?(refreshUniformsCommon(e,t),refreshUniformsPhong(e,t)):t.isMeshStandardMaterial?(refreshUniformsCommon(e,t,n),t.isMeshPhysicalMaterial?refreshUniformsPhysical(e,t,n):refreshUniformsStandard(e,t,n)):t.isMeshMatcapMaterial?(refreshUniformsCommon(e,t),refreshUniformsMatcap(e,t)):t.isMeshDepthMaterial?(refreshUniformsCommon(e,t),refreshUniformsDepth(e,t)):t.isMeshDistanceMaterial?(refreshUniformsCommon(e,t),refreshUniformsDistance(e,t)):t.isMeshNormalMaterial?(refreshUniformsCommon(e,t),refreshUniformsNormal(e,t)):t.isLineBasicMaterial?(refreshUniformsLine(e,t),t.isLineDashedMaterial&&refreshUniformsDash(e,t)):t.isPointsMaterial?refreshUniformsPoints(e,t,o,c):t.isSpriteMaterial?refreshUniformsSprites(e,t):t.isShadowMaterial?(e.color.value.copy(t.color),e.opacity.value=t.opacity):t.isShaderMaterial&&(t.uniformsNeedUpdate=!1)}function refreshUniformsCommon(t,n,o){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.specularMap&&(t.specularMap.value=n.specularMap);const c=n.envMap||o;let h,d;c&&(t.envMap.value=c,t.flipEnvMap.value=c.isCubeTexture?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio,t.maxMipLevel.value=e.get(c).__maxMipLevel),n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?h=n.map:n.specularMap?h=n.specularMap:n.displacementMap?h=n.displacementMap:n.normalMap?h=n.normalMap:n.bumpMap?h=n.bumpMap:n.roughnessMap?h=n.roughnessMap:n.metalnessMap?h=n.metalnessMap:n.alphaMap?h=n.alphaMap:n.emissiveMap&&(h=n.emissiveMap),void 0!==h&&(h.isWebGLRenderTarget&&(h=h.texture),!0===h.matrixAutoUpdate&&h.updateMatrix(),t.uvTransform.value.copy(h.matrix)),n.aoMap?d=n.aoMap:n.lightMap&&(d=n.lightMap),void 0!==d&&(d.isWebGLRenderTarget&&(d=d.texture),!0===d.matrixAutoUpdate&&d.updateMatrix(),t.uv2Transform.value.copy(d.matrix))}function refreshUniformsLine(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}function refreshUniformsDash(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}function refreshUniformsPoints(e,t,n,o){let c;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*o,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?c=t.map:t.alphaMap&&(c=t.alphaMap),void 0!==c&&(!0===c.matrixAutoUpdate&&c.updateMatrix(),e.uvTransform.value.copy(c.matrix))}function refreshUniformsSprites(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}function refreshUniformsLambert(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}function refreshUniformsPhong(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===T&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===T&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsToon(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===T&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===T&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsStandard(e,t,n){e.roughness.value=t.roughness,e.metalness.value=t.metalness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap),t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===T&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===T&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),(t.envMap||n)&&(e.envMapIntensity.value=t.envMapIntensity)}function refreshUniformsPhysical(e,t,n){refreshUniformsStandard(e,t,n),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,t.side===T&&e.clearcoatNormalScale.value.negate()),e.transparency.value=t.transparency}function refreshUniformsMatcap(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===T&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===T&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsDepth(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsDistance(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}function refreshUniformsNormal(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===T&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===T&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}return{refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms}}function WebGLRenderer(e){e=e||{};const t=void 0!==e.canvas?e.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),n=void 0!==e.context?e.context:null,o=void 0!==e.alpha&&e.alpha,c=void 0===e.depth||e.depth,h=void 0===e.stencil||e.stencil,d=void 0!==e.antialias&&e.antialias,p=void 0===e.premultipliedAlpha||e.premultipliedAlpha,m=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,g=void 0!==e.powerPreference?e.powerPreference:"default",y=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let x=null,b=null;this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=sn,this.physicallyCorrectLights=!1,this.toneMapping=ce,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const M=this;let _=!1,w=null,S=0,T=0,E=null,L=null,A=-1,C=null,P=null;const R=new Vector4,B=new Vector4;let D=null,G=t.width,I=t.height,O=1,V=null,N=null;const F=new Vector4(0,0,G,I),U=new Vector4(0,0,G,I);let z=!1;const H=new Frustum,k=new WebGLClipping;let j=!1,W=!1;const q=new Matrix4,X=new Vector3,Y={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function getTargetPixelRatio(){return null===E?O:1}let Z,J,Q,K,$,ee,te,ne,re,ie,oe,ae,se,le,ue,he,de,pe,fe,me=n;function getContext(e,n){for(let o=0;o<e.length;o++){const c=e[o],h=t.getContext(c,n);if(null!==h)return h}return null}try{const e={alpha:o,depth:c,stencil:h,antialias:d,premultipliedAlpha:p,preserveDrawingBuffer:m,powerPreference:g,failIfMajorPerformanceCaveat:y};if(t.addEventListener("webglcontextlost",onContextLost,!1),t.addEventListener("webglcontextrestored",onContextRestore,!1),null===me){const t=["webgl2","webgl","experimental-webgl"];if(!0===M.isWebGL1Renderer&&t.shift(),me=getContext(t,e),null===me)throw getContext(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===me.getShaderPrecisionFormat&&(me.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(be){throw console.error("THREE.WebGLRenderer: "+be.message),be}function initGLContext(){Z=new WebGLExtensions(me),J=new WebGLCapabilities(me,Z,e),!1===J.isWebGL2&&(Z.get("WEBGL_depth_texture"),Z.get("OES_texture_float"),Z.get("OES_texture_half_float"),Z.get("OES_texture_half_float_linear"),Z.get("OES_standard_derivatives"),Z.get("OES_element_index_uint"),Z.get("OES_vertex_array_object"),Z.get("ANGLE_instanced_arrays")),Z.get("OES_texture_float_linear"),pe=new WebGLUtils(me,Z,J),Q=new WebGLState(me,Z,J),Q.scissor(B.copy(U).multiplyScalar(O).floor()),Q.viewport(R.copy(F).multiplyScalar(O).floor()),K=new WebGLInfo(me),$=new WebGLProperties,ee=new WebGLTextures(me,Z,Q,$,J,pe,K),te=new WebGLAttributes(me,J),fe=new WebGLBindingStates(me,Z,te,J),ne=new WebGLGeometries(me,te,K,fe),re=new WebGLObjects(me,ne,te,K),ue=new WebGLMorphtargets(me),ie=new WebGLPrograms(M,Z,J,fe),oe=new WebGLMaterials($),ae=new WebGLRenderLists,se=new WebGLRenderStates,le=new WebGLBackground(M,Q,re,p),he=new WebGLBufferRenderer(me,Z,K,J),de=new WebGLIndexedBufferRenderer(me,Z,K,J),K.programs=ie.programs,M.capabilities=J,M.extensions=Z,M.properties=$,M.renderLists=ae,M.state=Q,M.info=K}initGLContext();const ge=new WebXRManager(M,me);this.xr=ge;const ye=new WebGLShadowMap(M,re,J.maxTextureSize);function onContextLost(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1,initGLContext()}function onMaterialDispose(e){const t=e.target;t.removeEventListener("dispose",onMaterialDispose),deallocateMaterial(t)}function deallocateMaterial(e){releaseMaterialProgramReference(e),$.remove(e)}function releaseMaterialProgramReference(e){const t=$.get(e).program;e.program=void 0,void 0!==t&&ie.releaseProgram(t)}function renderObjectImmediate(e,t){e.render((function(e){M.renderBufferImmediate(e,t)}))}this.shadowMap=ye,this.getContext=function(){return me},this.getContextAttributes=function(){return me.getContextAttributes()},this.forceContextLoss=function(){const e=Z.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=Z.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(e){void 0!==e&&(O=e,this.setSize(G,I,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new Vector2),e.set(G,I)},this.setSize=function(e,n,o){ge.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(G=e,I=n,t.width=Math.floor(e*O),t.height=Math.floor(n*O),!1!==o&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new Vector2),e.set(G*O,I*O).floor()},this.setDrawingBufferSize=function(e,n,o){G=e,I=n,O=o,t.width=Math.floor(e*o),t.height=Math.floor(n*o),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new Vector4),e.copy(R)},this.getViewport=function(e){return e.copy(F)},this.setViewport=function(e,t,n,o){e.isVector4?F.set(e.x,e.y,e.z,e.w):F.set(e,t,n,o),Q.viewport(R.copy(F).multiplyScalar(O).floor())},this.getScissor=function(e){return e.copy(U)},this.setScissor=function(e,t,n,o){e.isVector4?U.set(e.x,e.y,e.z,e.w):U.set(e,t,n,o),Q.scissor(B.copy(U).multiplyScalar(O).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(e){Q.setScissorTest(z=e)},this.setOpaqueSort=function(e){V=e},this.setTransparentSort=function(e){N=e},this.getClearColor=function(){return le.getClearColor()},this.setClearColor=function(){le.setClearColor.apply(le,arguments)},this.getClearAlpha=function(){return le.getClearAlpha()},this.setClearAlpha=function(){le.setClearAlpha.apply(le,arguments)},this.clear=function(e,t,n){let o=0;(void 0===e||e)&&(o|=16384),(void 0===t||t)&&(o|=256),(void 0===n||n)&&(o|=1024),me.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",onContextLost,!1),t.removeEventListener("webglcontextrestored",onContextRestore,!1),ae.dispose(),se.dispose(),$.dispose(),re.dispose(),fe.dispose(),ge.dispose(),xe.stop()},this.renderBufferImmediate=function(e,t){fe.initAttributes();const n=$.get(e);e.hasPositions&&!n.position&&(n.position=me.createBuffer()),e.hasNormals&&!n.normal&&(n.normal=me.createBuffer()),e.hasUvs&&!n.uv&&(n.uv=me.createBuffer()),e.hasColors&&!n.color&&(n.color=me.createBuffer());const o=t.getAttributes();e.hasPositions&&(me.bindBuffer(34962,n.position),me.bufferData(34962,e.positionArray,35048),fe.enableAttribute(o.position),me.vertexAttribPointer(o.position,3,5126,!1,0,0)),e.hasNormals&&(me.bindBuffer(34962,n.normal),me.bufferData(34962,e.normalArray,35048),fe.enableAttribute(o.normal),me.vertexAttribPointer(o.normal,3,5126,!1,0,0)),e.hasUvs&&(me.bindBuffer(34962,n.uv),me.bufferData(34962,e.uvArray,35048),fe.enableAttribute(o.uv),me.vertexAttribPointer(o.uv,2,5126,!1,0,0)),e.hasColors&&(me.bindBuffer(34962,n.color),me.bufferData(34962,e.colorArray,35048),fe.enableAttribute(o.color),me.vertexAttribPointer(o.color,3,5126,!1,0,0)),fe.disableUnusedAttributes(),me.drawArrays(4,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,n,o,c,h){null===t&&(t=Y);const d=c.isMesh&&c.matrixWorld.determinant()<0,p=setProgram(e,t,o,c);Q.setMaterial(o,d);let m=n.index;const g=n.attributes.position;if(null===m){if(void 0===g||0===g.count)return}else if(0===m.count)return;let y,x=1;!0===o.wireframe&&(m=ne.getWireframeAttribute(n),x=2),(o.morphTargets||o.morphNormals)&&ue.update(c,n,o,p),fe.setup(c,o,p,n,m);let b=he;null!==m&&(y=te.get(m),b=de,b.setIndex(y));const M=null!==m?m.count:g.count,_=n.drawRange.start*x,w=n.drawRange.count*x,S=null!==h?h.start*x:0,T=null!==h?h.count*x:1/0,E=Math.max(_,S),L=Math.min(M,_+w,S+T)-1,A=Math.max(0,L-E+1);if(0!==A){if(c.isMesh)!0===o.wireframe?(Q.setLineWidth(o.wireframeLinewidth*getTargetPixelRatio()),b.setMode(1)):b.setMode(4);else if(c.isLine){let e=o.linewidth;void 0===e&&(e=1),Q.setLineWidth(e*getTargetPixelRatio()),c.isLineSegments?b.setMode(1):c.isLineLoop?b.setMode(2):b.setMode(3)}else c.isPoints?b.setMode(0):c.isSprite&&b.setMode(4);if(c.isInstancedMesh)b.renderInstances(n,E,A,c.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);b.renderInstances(n,E,A,e)}else b.render(E,A)}},this.compile=function(e,t){b=se.get(e,t),b.init(),e.traverse((function(e){e.isLight&&(b.pushLight(e),e.castShadow&&b.pushShadow(e))})),b.setupLights(t);const n=new WeakMap;e.traverse((function(t){let o=t.material;if(o)if(Array.isArray(o))for(let c=0;c<o.length;c++){let h=o[c];!1===n.has(h)&&(initMaterial(h,e,t),n.set(h))}else!1===n.has(o)&&(initMaterial(o,e,t),n.set(o))}))};let ve=null;function onAnimationFrame(e){ge.isPresenting||ve&&ve(e)}const xe=new WebGLAnimation;function projectObject(e,t,n,o){if(!1===e.visible)return;const c=e.layers.test(t.layers);if(c)if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)b.pushLight(e),e.castShadow&&b.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||H.intersectsSprite(e)){o&&X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(q);const t=re.update(e),c=e.material;c.visible&&x.push(e,t,c,n,X.z,null)}}else if(e.isImmediateRenderObject)o&&X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(q),x.push(e,null,e.material,n,X.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==K.render.frame&&(e.skeleton.update(),e.skeleton.frame=K.render.frame),!e.frustumCulled||H.intersectsObject(e))){o&&X.setFromMatrixPosition(e.matrixWorld).applyMatrix4(q);const t=re.update(e),c=e.material;if(Array.isArray(c)){const o=t.groups;for(let h=0,d=o.length;h<d;h++){const d=o[h],p=c[d.materialIndex];p&&p.visible&&x.push(e,t,p,n,X.z,d)}}else c.visible&&x.push(e,t,c,n,X.z,null)}const h=e.children;for(let d=0,p=h.length;d<p;d++)projectObject(h[d],t,n,o)}function renderObjects(e,t,n){const o=!0===t.isScene?t.overrideMaterial:null;for(let c=0,h=e.length;c<h;c++){const h=e[c],d=h.object,p=h.geometry,m=null===o?h.material:o,g=h.group;if(n.isArrayCamera){P=n;const e=n.cameras;for(let n=0,o=e.length;n<o;n++){const o=e[n];d.layers.test(o.layers)&&(Q.viewport(R.copy(o.viewport)),b.setupLights(o),renderObject(d,t,o,p,m,g))}}else P=null,renderObject(d,t,n,p,m,g)}}function renderObject(e,t,n,o,c,h){if(e.onBeforeRender(M,t,n,o,c,h),b=se.get(t,P||n),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){const o=setProgram(n,t,c,e);Q.setMaterial(c),fe.reset(),renderObjectImmediate(e,o)}else M.renderBufferDirect(n,t,o,c,e,h);e.onAfterRender(M,t,n,o,c,h),b=se.get(t,P||n)}function initMaterial(e,t,n){!0!==t.isScene&&(t=Y);const o=$.get(e),c=b.state.lights,h=b.state.shadowsArray,d=c.state.version,p=ie.getParameters(e,c.state,h,t,k.numPlanes,k.numIntersection,n),m=ie.getProgramCacheKey(p);let g=o.program,y=!0;if(void 0===g)e.addEventListener("dispose",onMaterialDispose);else if(g.cacheKey!==m)releaseMaterialProgramReference(e);else if(o.lightsStateVersion!==d)o.lightsStateVersion=d,y=!1;else{if(void 0!==p.shaderID)return;y=!1}y&&(g=ie.acquireProgram(p,m),o.program=g,o.uniforms=p.uniforms,o.outputEncoding=p.outputEncoding,e.program=g);const x=g.getAttributes();if(e.morphTargets){e.numSupportedMorphTargets=0;for(let t=0;t<M.maxMorphTargets;t++)x["morphTarget"+t]>=0&&e.numSupportedMorphTargets++}if(e.morphNormals){e.numSupportedMorphNormals=0;for(let t=0;t<M.maxMorphNormals;t++)x["morphNormal"+t]>=0&&e.numSupportedMorphNormals++}const _=o.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(o.numClippingPlanes=k.numPlanes,o.numIntersection=k.numIntersection,_.clippingPlanes=k.uniform),o.environment=e.isMeshStandardMaterial?t.environment:null,o.fog=t.fog,o.needsLights=materialNeedsLights(e),o.lightsStateVersion=d,o.needsLights&&(_.ambientLightColor.value=c.state.ambient,_.lightProbe.value=c.state.probe,_.directionalLights.value=c.state.directional,_.directionalLightShadows.value=c.state.directionalShadow,_.spotLights.value=c.state.spot,_.spotLightShadows.value=c.state.spotShadow,_.rectAreaLights.value=c.state.rectArea,_.pointLights.value=c.state.point,_.pointLightShadows.value=c.state.pointShadow,_.hemisphereLights.value=c.state.hemi,_.directionalShadowMap.value=c.state.directionalShadowMap,_.directionalShadowMatrix.value=c.state.directionalShadowMatrix,_.spotShadowMap.value=c.state.spotShadowMap,_.spotShadowMatrix.value=c.state.spotShadowMatrix,_.pointShadowMap.value=c.state.pointShadowMap,_.pointShadowMatrix.value=c.state.pointShadowMatrix);const w=o.program.getUniforms(),S=WebGLUniforms.seqWithValue(w.seq,_);o.uniformsList=S}function setProgram(e,t,n,o){!0!==t.isScene&&(t=Y),ee.resetTextureUnits();const c=t.fog,h=n.isMeshStandardMaterial?t.environment:null,d=null===E?M.outputEncoding:E.texture.encoding,p=$.get(n),m=b.state.lights;if(!0===j&&(!0===W||e!==C)){const t=e===C&&n.id===A;k.setState(n.clippingPlanes,n.clipIntersection,n.clipShadows,e,p,t)}n.version===p.__version?void 0===p.program||n.fog&&p.fog!==c||p.environment!==h||p.needsLights&&p.lightsStateVersion!==m.state.version?initMaterial(n,t,o):void 0===p.numClippingPlanes||p.numClippingPlanes===k.numPlanes&&p.numIntersection===k.numIntersection?p.outputEncoding!==d&&initMaterial(n,t,o):initMaterial(n,t,o):(initMaterial(n,t,o),p.__version=n.version);let g=!1,y=!1,x=!1;const _=p.program,w=_.getUniforms(),S=p.uniforms;if(Q.useProgram(_.program)&&(g=!0,y=!0,x=!0),n.id!==A&&(A=n.id,y=!0),g||C!==e){if(w.setValue(me,"projectionMatrix",e.projectionMatrix),J.logarithmicDepthBuffer&&w.setValue(me,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),C!==e&&(C=e,y=!0,x=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const t=w.map.cameraPosition;void 0!==t&&t.setValue(me,X.setFromMatrixPosition(e.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&w.setValue(me,"isOrthographic",!0===e.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&w.setValue(me,"viewMatrix",e.matrixWorldInverse)}if(n.skinning){w.setOptional(me,o,"bindMatrix"),w.setOptional(me,o,"bindMatrixInverse");const e=o.skeleton;if(e){const t=e.bones;if(J.floatVertexTextures){if(void 0===e.boneTexture){let n=Math.sqrt(4*t.length);n=Wn.ceilPowerOfTwo(n),n=Math.max(n,4);const o=new Float32Array(n*n*4);o.set(e.boneMatrices);const c=new DataTexture(o,n,n,Ye,Ue);e.boneMatrices=o,e.boneTexture=c,e.boneTextureSize=n}w.setValue(me,"boneTexture",e.boneTexture,ee),w.setValue(me,"boneTextureSize",e.boneTextureSize)}else w.setOptional(me,e,"boneMatrices")}}return(y||p.receiveShadow!==o.receiveShadow)&&(p.receiveShadow=o.receiveShadow,w.setValue(me,"receiveShadow",o.receiveShadow)),y&&(w.setValue(me,"toneMappingExposure",M.toneMappingExposure),p.needsLights&&markUniformsLightsNeedsUpdate(S,x),c&&n.fog&&oe.refreshFogUniforms(S,c),oe.refreshMaterialUniforms(S,n,h,O,I),void 0!==S.ltc_1&&(S.ltc_1.value=Ui.LTC_1),void 0!==S.ltc_2&&(S.ltc_2.value=Ui.LTC_2),WebGLUniforms.upload(me,p.uniformsList,S,ee)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(WebGLUniforms.upload(me,p.uniformsList,S,ee),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&w.setValue(me,"center",o.center),w.setValue(me,"modelViewMatrix",o.modelViewMatrix),w.setValue(me,"normalMatrix",o.normalMatrix),w.setValue(me,"modelMatrix",o.matrixWorld),_}function markUniformsLightsNeedsUpdate(e,t){e.ambientLightColor.needsUpdate=t,e.lightProbe.needsUpdate=t,e.directionalLights.needsUpdate=t,e.directionalLightShadows.needsUpdate=t,e.pointLights.needsUpdate=t,e.pointLightShadows.needsUpdate=t,e.spotLights.needsUpdate=t,e.spotLightShadows.needsUpdate=t,e.rectAreaLights.needsUpdate=t,e.hemisphereLights.needsUpdate=t}function materialNeedsLights(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}xe.setAnimationLoop(onAnimationFrame),"undefined"!==typeof window&&xe.setContext(window),this.setAnimationLoop=function(e){ve=e,ge.setAnimationLoop(e),null===e?xe.stop():xe.start()},this.render=function(e,t){let n,o;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),o=arguments[3]),void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===_)return;fe.resetDefaultState(),A=-1,C=null,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===ge.enabled&&!0===ge.isPresenting&&(t=ge.getCamera(t)),!0===e.isScene&&e.onBeforeRender(M,e,t,n||E),b=se.get(e,t),b.init(),q.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),H.setFromProjectionMatrix(q),W=this.localClippingEnabled,j=k.init(this.clippingPlanes,W,t),x=ae.get(e,t),x.init(),projectObject(e,t,0,M.sortObjects),x.finish(),!0===M.sortObjects&&x.sort(V,N),!0===j&&k.beginShadows();const c=b.state.shadowsArray;ye.render(c,e,t),b.setupLights(t),!0===j&&k.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),le.render(x,e,t,o);const h=x.opaque,d=x.transparent;h.length>0&&renderObjects(h,e,t),d.length>0&&renderObjects(d,e,t),!0===e.isScene&&e.onAfterRender(M,e,t),null!==E&&(ee.updateRenderTargetMipmap(E),ee.updateMultisampleRenderTarget(E)),Q.buffers.depth.setTest(!0),Q.buffers.depth.setMask(!0),Q.buffers.color.setMask(!0),Q.setPolygonOffset(!1),x=null,b=null},this.setFramebuffer=function(e){w!==e&&null===E&&me.bindFramebuffer(36160,e),w=e},this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return T},this.getRenderTarget=function(){return E},this.setRenderTarget=function(e,t,n){E=e,S=t,T=n,e&&void 0===$.get(e).__webglFramebuffer&&ee.setupRenderTarget(e);let o=w,c=!1;if(e){const n=$.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(o=n[t||0],c=!0):o=e.isWebGLMultisampleRenderTarget?$.get(e).__webglMultisampledFramebuffer:n,R.copy(e.viewport),B.copy(e.scissor),D=e.scissorTest}else R.copy(F).multiplyScalar(O).floor(),B.copy(U).multiplyScalar(O).floor(),D=z;if(L!==o&&(me.bindFramebuffer(36160,o),L=o),Q.viewport(R),Q.scissor(B),Q.setScissorTest(D),c){const o=$.get(e.texture);me.framebufferTexture2D(36160,36064,34069+(t||0),o.__webglTexture,n||0)}},this.readRenderTargetPixels=function(e,t,n,o,c,h,d){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let p=$.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==d&&(p=p[d]),p){let d=!1;p!==L&&(me.bindFramebuffer(36160,p),d=!0);try{const p=e.texture,m=p.format,g=p.type;if(m!==Ye&&pe.convert(m)!==me.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(g!==Ge&&pe.convert(g)!==me.getParameter(35738)&&(g!==Ue||!(J.isWebGL2||Z.get("OES_texture_float")||Z.get("WEBGL_color_buffer_float")))&&(g!==ze||!(J.isWebGL2?Z.get("EXT_color_buffer_float"):Z.get("EXT_color_buffer_half_float"))))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===me.checkFramebufferStatus(36160)?t>=0&&t<=e.width-o&&n>=0&&n<=e.height-c&&me.readPixels(t,n,o,c,pe.convert(m),pe.convert(g),h):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{d&&me.bindFramebuffer(36160,L)}}},this.copyFramebufferToTexture=function(e,t,n){void 0===n&&(n=0);const o=Math.pow(2,-n),c=Math.floor(t.image.width*o),h=Math.floor(t.image.height*o),d=pe.convert(t.format);ee.setTexture2D(t,0),me.copyTexImage2D(3553,n,d,e.x,e.y,c,h,0),Q.unbindTexture()},this.copyTextureToTexture=function(e,t,n,o){void 0===o&&(o=0);const c=t.image.width,h=t.image.height,d=pe.convert(n.format),p=pe.convert(n.type);ee.setTexture2D(n,0),me.pixelStorei(37440,n.flipY),me.pixelStorei(37441,n.premultiplyAlpha),me.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?me.texSubImage2D(3553,o,e.x,e.y,c,h,d,p,t.image.data):t.isCompressedTexture?me.compressedTexSubImage2D(3553,o,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,d,t.mipmaps[0].data):me.texSubImage2D(3553,o,e.x,e.y,d,p,t.image),0===o&&n.generateMipmaps&&me.generateMipmap(3553),Q.unbindTexture()},this.initTexture=function(e){ee.setTexture2D(e,0),Q.unbindTexture()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function WebGL1Renderer(e){WebGLRenderer.call(this,e)}function FogExp2(e,t){this.name="",this.color=new Color(e),this.density=void 0!==t?t:25e-5}function Fog(e,t,n){this.name="",this.color=new Color(e),this.near=void 0!==t?t:1,this.far=void 0!==n?n:1e3}function InterleavedBuffer(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=In,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Wn.generateUUID()}ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:!0}),Group.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Group,isGroup:!0}),Object.assign(WebXRController.prototype,{constructor:WebXRController,getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),this},update:function(e,t,n){let o=null,c=null;const h=this._targetRay,d=this._grip;return e&&(null!==h&&(o=t.getPose(e.targetRaySpace,n),null!==o&&(h.matrix.fromArray(o.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale))),null!==d&&e.gripSpace&&(c=t.getPose(e.gripSpace,n),null!==c&&(d.matrix.fromArray(c.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale)))),null!==h&&(h.visible=null!==o),null!==d&&(d.visible=null!==c),this}}),Object.assign(WebXRManager.prototype,EventDispatcher.prototype),WebGL1Renderer.prototype=Object.assign(Object.create(WebGLRenderer.prototype),{constructor:WebGL1Renderer,isWebGL1Renderer:!0}),Object.assign(FogExp2.prototype,{isFogExp2:!0,clone:function(){return new FogExp2(this.color,this.density)},toJSON:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}),Object.assign(Fog.prototype,{isFog:!0,clone:function(){return new Fog(this.color,this.near,this.far)},toJSON:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}),Object.defineProperty(InterleavedBuffer.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(InterleavedBuffer.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let o=0,c=this.stride;o<c;o++)this.array[e+o]=t.array[n+o];return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Wn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new InterleavedBuffer(t,this.stride);return n.setUsage(this.usage),n},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Wn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Es=new Vector3;function InterleavedBufferAttribute(e,t,n,o){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===o}function SpriteMaterial(e){Material.call(this),this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}let Ls;Object.defineProperties(InterleavedBufferAttribute.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}}}),Object.assign(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Es.x=this.getX(t),Es.y=this.getY(t),Es.z=this.getZ(t),Es.applyMatrix4(e),this.setXYZ(t,Es.x,Es.y,Es.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this},setXYZW:function(e,t,n,o,c){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this.data.array[e+3]=c,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new BufferAttribute(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),SpriteMaterial.prototype=Object.create(Material.prototype),SpriteMaterial.prototype.constructor=SpriteMaterial,SpriteMaterial.prototype.isSpriteMaterial=!0,SpriteMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};const As=new Vector3,Cs=new Vector3,Ps=new Vector3,Rs=new Vector2,Bs=new Vector2,Ds=new Matrix4,Gs=new Vector3,Is=new Vector3,Os=new Vector3,Vs=new Vector2,Ns=new Vector2,Fs=new Vector2;function Sprite(e){if(Object3D.call(this),this.type="Sprite",void 0===Ls){Ls=new BufferGeometry;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new InterleavedBuffer(e,5);Ls.setIndex([0,1,2,0,2,3]),Ls.setAttribute("position",new InterleavedBufferAttribute(t,3,0,!1)),Ls.setAttribute("uv",new InterleavedBufferAttribute(t,2,3,!1))}this.geometry=Ls,this.material=void 0!==e?e:new SpriteMaterial,this.center=new Vector2(.5,.5)}function transformVertex(e,t,n,o,c,h){Rs.subVectors(e,n).addScalar(.5).multiply(o),void 0!==c?(Bs.x=h*Rs.x-c*Rs.y,Bs.y=c*Rs.x+h*Rs.y):Bs.copy(Rs),e.copy(t),e.x+=Bs.x,e.y+=Bs.y,e.applyMatrix4(Ds)}Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:!0,raycast:function(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Cs.setFromMatrixScale(this.matrixWorld),Ds.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ps.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Cs.multiplyScalar(-Ps.z);const n=this.material.rotation;let o,c;0!==n&&(c=Math.cos(n),o=Math.sin(n));const h=this.center;transformVertex(Gs.set(-.5,-.5,0),Ps,h,Cs,o,c),transformVertex(Is.set(.5,-.5,0),Ps,h,Cs,o,c),transformVertex(Os.set(.5,.5,0),Ps,h,Cs,o,c),Vs.set(0,0),Ns.set(1,0),Fs.set(1,1);let d=e.ray.intersectTriangle(Gs,Is,Os,!1,As);if(null===d&&(transformVertex(Is.set(-.5,.5,0),Ps,h,Cs,o,c),Ns.set(0,1),d=e.ray.intersectTriangle(Gs,Os,Is,!1,As),null===d))return;const p=e.ray.origin.distanceTo(As);p<e.near||p>e.far||t.push({distance:p,point:As.clone(),uv:Triangle.getUV(As,Gs,Is,Os,Vs,Ns,Fs,new Vector2),face:null,object:this})},copy:function(e){return Object3D.prototype.copy.call(this,e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}});const Us=new Vector3,zs=new Vector3;function LOD(){Object3D.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}function SkinnedMesh(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Mesh.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4}LOD.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LOD,isLOD:!0,copy:function(e){Object3D.prototype.copy.call(this,e,!1);const t=e.levels;for(let n=0,o=t.length;n<o;n++){const e=t[n];this.addLevel(e.object.clone(),e.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t){void 0===t&&(t=0),t=Math.abs(t);const n=this.levels;let o;for(o=0;o<n.length;o++)if(t<n[o].distance)break;return n.splice(o,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,o;for(n=1,o=t.length;n<o;n++)if(e<t[n].distance)break;return t[n-1].object}return null},raycast:function(e,t){const n=this.levels;if(n.length>0){Us.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(Us);this.getObjectForDistance(n).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){Us.setFromMatrixPosition(e.matrixWorld),zs.setFromMatrixPosition(this.matrixWorld);const n=Us.distanceTo(zs)/e.zoom;let o,c;for(t[0].object.visible=!0,o=1,c=t.length;o<c;o++){if(!(n>=t[o].distance))break;t[o-1].object.visible=!1,t[o].object.visible=!0}for(this._currentLevel=o-1;o<c;o++)t[o].object.visible=!1}},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let o=0,c=n.length;o<c;o++){const e=n[o];t.object.levels.push({object:e.object.uuid,distance:e.distance})}return t}}),SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:!0,copy:function(e){return Mesh.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.getInverse(t)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new Vector4,t=this.geometry.attributes.skinWeight;for(let n=0,o=t.count;n<o;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const o=1/e.manhattanLength();o!==1/0?e.multiplyScalar(o):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){Mesh.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(){const e=new Vector3,t=new Vector4,n=new Vector4,o=new Vector3,c=new Matrix4;return function(h,d){const p=this.skeleton,m=this.geometry;t.fromBufferAttribute(m.attributes.skinIndex,h),n.fromBufferAttribute(m.attributes.skinWeight,h),e.fromBufferAttribute(m.attributes.position,h).applyMatrix4(this.bindMatrix),d.set(0,0,0);for(let g=0;g<4;g++){const h=n.getComponent(g);if(0!==h){const n=t.getComponent(g);c.multiplyMatrices(p.bones[n].matrixWorld,p.boneInverses[n]),d.addScaledVector(o.copy(e).applyMatrix4(c),h)}}return d.applyMatrix4(this.bindMatrixInverse)}}()});const Hs=new Matrix4,ks=new Matrix4;function Skeleton(e,t){if(e=e||[],this.bones=e.slice(0),this.boneMatrices=new Float32Array(16*this.bones.length),this.frame=-1,void 0===t)this.calculateInverses();else if(this.bones.length===t.length)this.boneInverses=t.slice(0);else{console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Matrix4)}}function Bone(){Object3D.call(this),this.type="Bone"}Object.assign(Skeleton.prototype,{calculateInverses:function(){this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++){const t=new Matrix4;this.bones[e]&&t.getInverse(this.bones[e].matrixWorld),this.boneInverses.push(t)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.getInverse(this.boneInverses[e])}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.getInverse(t.parent.matrixWorld),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,o=this.boneTexture;for(let c=0,h=e.length;c<h;c++){const o=e[c]?e[c].matrixWorld:ks;Hs.multiplyMatrices(o,t[c]),Hs.toArray(n,16*c)}void 0!==o&&(o.needsUpdate=!0)},clone:function(){return new Skeleton(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}},dispose:function(){this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=void 0)}}),Bone.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Bone,isBone:!0});const js=new Matrix4,Ws=new Matrix4,qs=[],Xs=new Mesh;function InstancedMesh(e,t,n){Mesh.call(this,e,t),this.instanceMatrix=new BufferAttribute(new Float32Array(16*n),16),this.count=n,this.frustumCulled=!1}function LineBasicMaterial(e){Material.call(this),this.type="LineBasicMaterial",this.color=new Color(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}InstancedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:InstancedMesh,isInstancedMesh:!0,copy:function(e){return Mesh.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,o=this.count;if(Xs.geometry=this.geometry,Xs.material=this.material,void 0!==Xs.material)for(let c=0;c<o;c++){this.getMatrixAt(c,js),Ws.multiplyMatrices(n,js),Xs.matrixWorld=Ws,Xs.raycast(e,qs);for(let e=0,n=qs.length;e<n;e++){const n=qs[e];n.instanceId=c,n.object=this,t.push(n)}qs.length=0}},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){}}),LineBasicMaterial.prototype=Object.create(Material.prototype),LineBasicMaterial.prototype.constructor=LineBasicMaterial,LineBasicMaterial.prototype.isLineBasicMaterial=!0,LineBasicMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const Ys=new Vector3,Zs=new Vector3,Js=new Matrix4,Qs=new Ray,Ks=new Sphere;function Line(e,t,n){1===n&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),Object3D.call(this),this.type="Line",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new LineBasicMaterial,this.updateMorphTargets()}Line.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Line,isLine:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,o=t.count;e<o;e++)Ys.fromBufferAttribute(t,e-1),Zs.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=Ys.distanceTo(Zs);e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;n[0]=0;for(let e=1,o=t.length;e<o;e++)n[e]=n[e-1],n[e]+=t[e-1].distanceTo(t[e])}return this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,c=e.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ks.copy(n.boundingSphere),Ks.applyMatrix4(o),Ks.radius+=c,!1===e.ray.intersectsSphere(Ks))return;Js.getInverse(o),Qs.copy(e.ray).applyMatrix4(Js);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h,p=new Vector3,m=new Vector3,g=new Vector3,y=new Vector3,x=this&&this.isLineSegments?2:1;if(n.isBufferGeometry){const o=n.index,c=n.attributes,h=c.position.array;if(null!==o){const n=o.array;for(let o=0,c=n.length-1;o<c;o+=x){const c=n[o],x=n[o+1];p.fromArray(h,3*c),m.fromArray(h,3*x);const b=Qs.distanceSqToSegment(p,m,y,g);if(b>d)continue;y.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(y);M<e.near||M>e.far||t.push({distance:M,point:g.clone().applyMatrix4(this.matrixWorld),index:o,face:null,faceIndex:null,object:this})}}else for(let n=0,b=h.length/3-1;n<b;n+=x){p.fromArray(h,3*n),m.fromArray(h,3*n+3);const o=Qs.distanceSqToSegment(p,m,y,g);if(o>d)continue;y.applyMatrix4(this.matrixWorld);const c=e.ray.origin.distanceTo(y);c<e.near||c>e.far||t.push({distance:c,point:g.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const o=n.vertices,c=o.length;for(let n=0;n<c-1;n+=x){const c=Qs.distanceSqToSegment(o[n],o[n+1],y,g);if(c>d)continue;y.applyMatrix4(this.matrixWorld);const h=e.ray.origin.distanceTo(y);h<e.near||h>e.far||t.push({distance:h,point:g.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const $s=new Vector3,ec=new Vector3;function LineSegments(e,t){Line.call(this,e,t),this.type="LineSegments"}function LineLoop(e,t){Line.call(this,e,t),this.type="LineLoop"}function PointsMaterial(e){Material.call(this),this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}LineSegments.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,o=t.count;e<o;e+=2)$s.fromBufferAttribute(t,e),ec.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+$s.distanceTo(ec);e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;for(let e=0,o=t.length;e<o;e+=2)$s.copy(t[e]),ec.copy(t[e+1]),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+$s.distanceTo(ec)}return this}}),LineLoop.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineLoop,isLineLoop:!0}),PointsMaterial.prototype=Object.create(Material.prototype),PointsMaterial.prototype.constructor=PointsMaterial,PointsMaterial.prototype.isPointsMaterial=!0,PointsMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const tc=new Matrix4,nc=new Ray,rc=new Sphere,ic=new Vector3;function Points(e,t){Object3D.call(this),this.type="Points",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new PointsMaterial,this.updateMorphTargets()}function testPoint(e,t,n,o,c,h,d){const p=nc.distanceSqToPoint(e);if(p<n){const n=new Vector3;nc.closestPointToPoint(e,n),n.applyMatrix4(o);const m=c.ray.origin.distanceTo(n);if(m<c.near||m>c.far)return;h.push({distance:m,distanceToRay:Math.sqrt(p),point:n,index:t,face:null,object:d})}}function VideoTexture(e,t,n,o,c,h,d,p,m){Texture.call(this,e,t,n,o,c,h,d,p,m),this.format=void 0!==d?d:Xe,this.minFilter=void 0!==h?h:Ce,this.magFilter=void 0!==c?c:Ce,this.generateMipmaps=!1}function CompressedTexture(e,t,n,o,c,h,d,p,m,g,y,x){Texture.call(this,null,h,d,p,m,g,o,c,y,x),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function CanvasTexture(e,t,n,o,c,h,d,p,m){Texture.call(this,e,t,n,o,c,h,d,p,m),this.needsUpdate=!0}function DepthTexture(e,t,n,o,c,h,d,p,m,g){if(g=void 0!==g?g:Ke,g!==Ke&&g!==$e)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&g===Ke&&(n=Ve),void 0===n&&g===$e&&(n=We),Texture.call(this,null,o,c,h,d,p,g,n,m),this.image={width:e,height:t},this.magFilter=void 0!==d?d:Se,this.minFilter=void 0!==p?p:Se,this.flipY=!1,this.generateMipmaps=!1}function WireframeGeometry(e){BufferGeometry.call(this),this.type="WireframeGeometry";const t=[],n=[0,0],o={},c=["a","b","c"];if(e&&e.isGeometry){const h=e.faces;for(let e=0,t=h.length;e<t;e++){const t=h[e];for(let e=0;e<3;e++){const h=t[c[e]],d=t[c[(e+1)%3]];n[0]=Math.min(h,d),n[1]=Math.max(h,d);const p=n[0]+","+n[1];void 0===o[p]&&(o[p]={index1:n[0],index2:n[1]})}}for(const n in o){const c=o[n];let h=e.vertices[c.index1];t.push(h.x,h.y,h.z),h=e.vertices[c.index2],t.push(h.x,h.y,h.z)}}else if(e&&e.isBufferGeometry){let c=new Vector3;if(null!==e.index){const h=e.attributes.position,d=e.index;let p=e.groups;0===p.length&&(p=[{start:0,count:d.count,materialIndex:0}]);for(let e=0,t=p.length;e<t;++e){const t=p[e],c=t.start,h=t.count;for(let e=c,p=c+h;e<p;e+=3)for(let t=0;t<3;t++){const c=d.getX(e+t),h=d.getX(e+(t+1)%3);n[0]=Math.min(c,h),n[1]=Math.max(c,h);const p=n[0]+","+n[1];void 0===o[p]&&(o[p]={index1:n[0],index2:n[1]})}}for(const e in o){const n=o[e];c.fromBufferAttribute(h,n.index1),t.push(c.x,c.y,c.z),c.fromBufferAttribute(h,n.index2),t.push(c.x,c.y,c.z)}}else{const n=e.attributes.position;for(let e=0,o=n.count/3;e<o;e++)for(let h=0;h<3;h++){const o=3*e+h;c.fromBufferAttribute(n,o),t.push(c.x,c.y,c.z);const d=3*e+(h+1)%3;c.fromBufferAttribute(n,d),t.push(c.x,c.y,c.z)}}}this.setAttribute("position",new Float32BufferAttribute(t,3))}function ParametricGeometry(e,t,n){Geometry.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n},this.fromBufferGeometry(new ParametricBufferGeometry(e,t,n)),this.mergeVertices()}function ParametricBufferGeometry(e,t,n){BufferGeometry.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:n};const o=[],c=[],h=[],d=[],p=1e-5,m=new Vector3,g=new Vector3,y=new Vector3,x=new Vector3,b=new Vector3;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const M=t+1;for(let _=0;_<=n;_++){const o=_/n;for(let n=0;n<=t;n++){const M=n/t;e(M,o,g),c.push(g.x,g.y,g.z),M-p>=0?(e(M-p,o,y),x.subVectors(g,y)):(e(M+p,o,y),x.subVectors(y,g)),o-p>=0?(e(M,o-p,y),b.subVectors(g,y)):(e(M,o+p,y),b.subVectors(y,g)),m.crossVectors(x,b).normalize(),h.push(m.x,m.y,m.z),d.push(M,o)}}for(let _=0;_<n;_++)for(let e=0;e<t;e++){const t=_*M+e,n=_*M+e+1,c=(_+1)*M+e+1,h=(_+1)*M+e;o.push(t,n,h),o.push(n,c,h)}this.setIndex(o),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2))}function PolyhedronGeometry(e,t,n,o){Geometry.call(this),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:o},this.fromBufferGeometry(new PolyhedronBufferGeometry(e,t,n,o)),this.mergeVertices()}function PolyhedronBufferGeometry(e,t,n,o){BufferGeometry.call(this),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:o},n=n||1,o=o||0;const c=[],h=[];function subdivide(e){const n=new Vector3,o=new Vector3,c=new Vector3;for(let h=0;h<t.length;h+=3)getVertexByIndex(t[h+0],n),getVertexByIndex(t[h+1],o),getVertexByIndex(t[h+2],c),subdivideFace(n,o,c,e)}function subdivideFace(e,t,n,o){const c=Math.pow(2,o),h=[];for(let d=0;d<=c;d++){h[d]=[];const o=e.clone().lerp(n,d/c),p=t.clone().lerp(n,d/c),m=c-d;for(let e=0;e<=m;e++)h[d][e]=0===e&&d===c?o:o.clone().lerp(p,e/m)}for(let d=0;d<c;d++)for(let e=0;e<2*(c-d)-1;e++){const t=Math.floor(e/2);e%2===0?(pushVertex(h[d][t+1]),pushVertex(h[d+1][t]),pushVertex(h[d][t])):(pushVertex(h[d][t+1]),pushVertex(h[d+1][t+1]),pushVertex(h[d+1][t]))}}function applyRadius(e){const t=new Vector3;for(let n=0;n<c.length;n+=3)t.x=c[n+0],t.y=c[n+1],t.z=c[n+2],t.normalize().multiplyScalar(e),c[n+0]=t.x,c[n+1]=t.y,c[n+2]=t.z}function generateUVs(){const e=new Vector3;for(let t=0;t<c.length;t+=3){e.x=c[t+0],e.y=c[t+1],e.z=c[t+2];const n=azimuth(e)/2/Math.PI+.5,o=inclination(e)/Math.PI+.5;h.push(n,1-o)}correctUVs(),correctSeam()}function correctSeam(){for(let e=0;e<h.length;e+=6){const t=h[e+0],n=h[e+2],o=h[e+4],c=Math.max(t,n,o),d=Math.min(t,n,o);c>.9&&d<.1&&(t<.2&&(h[e+0]+=1),n<.2&&(h[e+2]+=1),o<.2&&(h[e+4]+=1))}}function pushVertex(e){c.push(e.x,e.y,e.z)}function getVertexByIndex(t,n){const o=3*t;n.x=e[o+0],n.y=e[o+1],n.z=e[o+2]}function correctUVs(){const e=new Vector3,t=new Vector3,n=new Vector3,o=new Vector3,d=new Vector2,p=new Vector2,m=new Vector2;for(let g=0,y=0;g<c.length;g+=9,y+=6){e.set(c[g+0],c[g+1],c[g+2]),t.set(c[g+3],c[g+4],c[g+5]),n.set(c[g+6],c[g+7],c[g+8]),d.set(h[y+0],h[y+1]),p.set(h[y+2],h[y+3]),m.set(h[y+4],h[y+5]),o.copy(e).add(t).add(n).divideScalar(3);const x=azimuth(o);correctUV(d,y+0,e,x),correctUV(p,y+2,t,x),correctUV(m,y+4,n,x)}}function correctUV(e,t,n,o){o<0&&1===e.x&&(h[t]=e.x-1),0===n.x&&0===n.z&&(h[t]=o/2/Math.PI+.5)}function azimuth(e){return Math.atan2(e.z,-e.x)}function inclination(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}subdivide(o),applyRadius(n),generateUVs(),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(c.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(h,2)),0===o?this.computeVertexNormals():this.normalizeNormals()}function TetrahedronGeometry(e,t){Geometry.call(this),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new TetrahedronBufferGeometry(e,t)),this.mergeVertices()}function TetrahedronBufferGeometry(e,t){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],o=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,n,o,e,t),this.type="TetrahedronBufferGeometry",this.parameters={radius:e,detail:t}}function OctahedronGeometry(e,t){Geometry.call(this),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new OctahedronBufferGeometry(e,t)),this.mergeVertices()}function OctahedronBufferGeometry(e,t){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],o=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,n,o,e,t),this.type="OctahedronBufferGeometry",this.parameters={radius:e,detail:t}}function IcosahedronGeometry(e,t){Geometry.call(this),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new IcosahedronBufferGeometry(e,t)),this.mergeVertices()}function IcosahedronBufferGeometry(e,t){const n=(1+Math.sqrt(5))/2,o=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],c=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,o,c,e,t),this.type="IcosahedronBufferGeometry",this.parameters={radius:e,detail:t}}function DodecahedronGeometry(e,t){Geometry.call(this),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new DodecahedronBufferGeometry(e,t)),this.mergeVertices()}function DodecahedronBufferGeometry(e,t){const n=(1+Math.sqrt(5))/2,o=1/n,c=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-o,-n,0,-o,n,0,o,-n,0,o,n,-o,-n,0,-o,n,0,o,-n,0,o,n,0,-n,0,-o,n,0,-o,-n,0,o,n,0,o],h=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];PolyhedronBufferGeometry.call(this,c,h,e,t),this.type="DodecahedronBufferGeometry",this.parameters={radius:e,detail:t}}function TubeGeometry(e,t,n,o,c,h){Geometry.call(this),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:o,closed:c},void 0!==h&&console.warn("THREE.TubeGeometry: taper has been removed.");const d=new TubeBufferGeometry(e,t,n,o,c);this.tangents=d.tangents,this.normals=d.normals,this.binormals=d.binormals,this.fromBufferGeometry(d),this.mergeVertices()}function TubeBufferGeometry(e,t,n,o,c){BufferGeometry.call(this),this.type="TubeBufferGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:o,closed:c},t=t||64,n=n||1,o=o||8,c=c||!1;const h=e.computeFrenetFrames(t,c);this.tangents=h.tangents,this.normals=h.normals,this.binormals=h.binormals;const d=new Vector3,p=new Vector3,m=new Vector2;let g=new Vector3;const y=[],x=[],b=[],M=[];function generateBufferData(){for(let e=0;e<t;e++)generateSegment(e);generateSegment(!1===c?t:0),generateUVs(),generateIndices()}function generateSegment(c){g=e.getPointAt(c/t,g);const m=h.normals[c],b=h.binormals[c];for(let e=0;e<=o;e++){const t=e/o*Math.PI*2,c=Math.sin(t),h=-Math.cos(t);p.x=h*m.x+c*b.x,p.y=h*m.y+c*b.y,p.z=h*m.z+c*b.z,p.normalize(),x.push(p.x,p.y,p.z),d.x=g.x+n*p.x,d.y=g.y+n*p.y,d.z=g.z+n*p.z,y.push(d.x,d.y,d.z)}}function generateIndices(){for(let e=1;e<=t;e++)for(let t=1;t<=o;t++){const n=(o+1)*(e-1)+(t-1),c=(o+1)*e+(t-1),h=(o+1)*e+t,d=(o+1)*(e-1)+t;M.push(n,c,d),M.push(c,h,d)}}function generateUVs(){for(let e=0;e<=t;e++)for(let n=0;n<=o;n++)m.x=e/t,m.y=n/o,b.push(m.x,m.y)}generateBufferData(),this.setIndex(M),this.setAttribute("position",new Float32BufferAttribute(y,3)),this.setAttribute("normal",new Float32BufferAttribute(x,3)),this.setAttribute("uv",new Float32BufferAttribute(b,2))}function TorusKnotGeometry(e,t,n,o,c,h,d){Geometry.call(this),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:o,p:c,q:h},void 0!==d&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new TorusKnotBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}function TorusKnotBufferGeometry(e,t,n,o,c,h){BufferGeometry.call(this),this.type="TorusKnotBufferGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:o,p:c,q:h},e=e||1,t=t||.4,n=Math.floor(n)||64,o=Math.floor(o)||8,c=c||2,h=h||3;const d=[],p=[],m=[],g=[],y=new Vector3,x=new Vector3,b=new Vector3,M=new Vector3,_=new Vector3,w=new Vector3,S=new Vector3;for(let T=0;T<=n;++T){const d=T/n*c*Math.PI*2;calculatePositionOnCurve(d,c,h,e,b),calculatePositionOnCurve(d+.01,c,h,e,M),w.subVectors(M,b),S.addVectors(M,b),_.crossVectors(w,S),S.crossVectors(_,w),_.normalize(),S.normalize();for(let e=0;e<=o;++e){const c=e/o*Math.PI*2,h=-t*Math.cos(c),d=t*Math.sin(c);y.x=b.x+(h*S.x+d*_.x),y.y=b.y+(h*S.y+d*_.y),y.z=b.z+(h*S.z+d*_.z),p.push(y.x,y.y,y.z),x.subVectors(y,b).normalize(),m.push(x.x,x.y,x.z),g.push(T/n),g.push(e/o)}}for(let T=1;T<=n;T++)for(let e=1;e<=o;e++){const t=(o+1)*(T-1)+(e-1),n=(o+1)*T+(e-1),c=(o+1)*T+e,h=(o+1)*(T-1)+e;d.push(t,n,h),d.push(n,c,h)}function calculatePositionOnCurve(e,t,n,o,c){const h=Math.cos(e),d=Math.sin(e),p=n/t*e,m=Math.cos(p);c.x=o*(2+m)*.5*h,c.y=o*(2+m)*d*.5,c.z=o*Math.sin(p)*.5}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(g,2))}function TorusGeometry(e,t,n,o,c){Geometry.call(this),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:o,arc:c},this.fromBufferGeometry(new TorusBufferGeometry(e,t,n,o,c)),this.mergeVertices()}function TorusBufferGeometry(e,t,n,o,c){BufferGeometry.call(this),this.type="TorusBufferGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:o,arc:c},e=e||1,t=t||.4,n=Math.floor(n)||8,o=Math.floor(o)||6,c=c||2*Math.PI;const h=[],d=[],p=[],m=[],g=new Vector3,y=new Vector3,x=new Vector3;for(let b=0;b<=n;b++)for(let h=0;h<=o;h++){const M=h/o*c,_=b/n*Math.PI*2;y.x=(e+t*Math.cos(_))*Math.cos(M),y.y=(e+t*Math.cos(_))*Math.sin(M),y.z=t*Math.sin(_),d.push(y.x,y.y,y.z),g.x=e*Math.cos(M),g.y=e*Math.sin(M),x.subVectors(y,g).normalize(),p.push(x.x,x.y,x.z),m.push(h/o),m.push(b/n)}for(let b=1;b<=n;b++)for(let e=1;e<=o;e++){const t=(o+1)*b+e-1,n=(o+1)*(b-1)+e-1,c=(o+1)*(b-1)+e,d=(o+1)*b+e;h.push(t,n,d),h.push(n,c,d)}this.setIndex(h),this.setAttribute("position",new Float32BufferAttribute(d,3)),this.setAttribute("normal",new Float32BufferAttribute(p,3)),this.setAttribute("uv",new Float32BufferAttribute(m,2))}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,c=e.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),rc.copy(n.boundingSphere),rc.applyMatrix4(o),rc.radius+=c,!1===e.ray.intersectsSphere(rc))return;tc.getInverse(o),nc.copy(e.ray).applyMatrix4(tc);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h;if(n.isBufferGeometry){const c=n.index,h=n.attributes,p=h.position.array;if(null!==c){const n=c.array;for(let c=0,h=n.length;c<h;c++){const h=n[c];ic.fromArray(p,3*h),testPoint(ic,h,d,o,e,t,this)}}else for(let n=0,m=p.length/3;n<m;n++)ic.fromArray(p,3*n),testPoint(ic,n,d,o,e,t,this)}else{const c=n.vertices;for(let n=0,h=c.length;n<h;n++)testPoint(c[n],n,d,o,e,t,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),VideoTexture.prototype=Object.assign(Object.create(Texture.prototype),{constructor:VideoTexture,isVideoTexture:!0,update:function(){const e=this.image;e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),CompressedTexture.prototype=Object.create(Texture.prototype),CompressedTexture.prototype.constructor=CompressedTexture,CompressedTexture.prototype.isCompressedTexture=!0,CanvasTexture.prototype=Object.create(Texture.prototype),CanvasTexture.prototype.constructor=CanvasTexture,CanvasTexture.prototype.isCanvasTexture=!0,DepthTexture.prototype=Object.create(Texture.prototype),DepthTexture.prototype.constructor=DepthTexture,DepthTexture.prototype.isDepthTexture=!0,WireframeGeometry.prototype=Object.create(BufferGeometry.prototype),WireframeGeometry.prototype.constructor=WireframeGeometry,ParametricGeometry.prototype=Object.create(Geometry.prototype),ParametricGeometry.prototype.constructor=ParametricGeometry,ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype),ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry,PolyhedronGeometry.prototype=Object.create(Geometry.prototype),PolyhedronGeometry.prototype.constructor=PolyhedronGeometry,PolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype),PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry,TetrahedronGeometry.prototype=Object.create(Geometry.prototype),TetrahedronGeometry.prototype.constructor=TetrahedronGeometry,TetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype),TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry,OctahedronGeometry.prototype=Object.create(Geometry.prototype),OctahedronGeometry.prototype.constructor=OctahedronGeometry,OctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype),OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry,IcosahedronGeometry.prototype=Object.create(Geometry.prototype),IcosahedronGeometry.prototype.constructor=IcosahedronGeometry,IcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype),IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry,DodecahedronGeometry.prototype=Object.create(Geometry.prototype),DodecahedronGeometry.prototype.constructor=DodecahedronGeometry,DodecahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype),DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry,TubeGeometry.prototype=Object.create(Geometry.prototype),TubeGeometry.prototype.constructor=TubeGeometry,TubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype),TubeBufferGeometry.prototype.constructor=TubeBufferGeometry,TubeBufferGeometry.prototype.toJSON=function(){const e=BufferGeometry.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e},TorusKnotGeometry.prototype=Object.create(Geometry.prototype),TorusKnotGeometry.prototype.constructor=TorusKnotGeometry,TorusKnotBufferGeometry.prototype=Object.create(BufferGeometry.prototype),TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry,TorusGeometry.prototype=Object.create(Geometry.prototype),TorusGeometry.prototype.constructor=TorusGeometry,TorusBufferGeometry.prototype=Object.create(BufferGeometry.prototype),TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;const oc={triangulate:function(e,t,n){n=n||2;let o,c,h,d,p,m,g,y=t&&t.length,x=y?t[0]*n:e.length,b=linkedList(e,0,x,n,!0),M=[];if(!b||b.next===b.prev)return M;if(y&&(b=eliminateHoles(e,t,b,n)),e.length>80*n){o=h=e[0],c=d=e[1];for(let t=n;t<x;t+=n)p=e[t],m=e[t+1],p<o&&(o=p),m<c&&(c=m),p>h&&(h=p),m>d&&(d=m);g=Math.max(h-o,d-c),g=0!==g?1/g:0}return earcutLinked(b,M,n,o,c,g),M}};function linkedList(e,t,n,o,c){let h,d;if(c===signedArea(e,t,n,o)>0)for(h=t;h<n;h+=o)d=insertNode(h,e[h],e[h+1],d);else for(h=n-o;h>=t;h-=o)d=insertNode(h,e[h],e[h+1],d);return d&&equals(d,d.next)&&(removeNode(d),d=d.next),d}function filterPoints(e,t){if(!e)return e;t||(t=e);let n,o=e;do{if(n=!1,o.steiner||!equals(o,o.next)&&0!==area(o.prev,o,o.next))o=o.next;else{if(removeNode(o),o=t=o.prev,o===o.next)break;n=!0}}while(n||o!==t);return t}function earcutLinked(e,t,n,o,c,h,d){if(!e)return;!d&&h&&indexCurve(e,o,c,h);let p,m,g=e;while(e.prev!==e.next)if(p=e.prev,m=e.next,h?isEarHashed(e,o,c,h):isEar(e))t.push(p.i/n),t.push(e.i/n),t.push(m.i/n),removeNode(e),e=m.next,g=m.next;else if(e=m,e===g){d?1===d?(e=cureLocalIntersections(filterPoints(e),t,n),earcutLinked(e,t,n,o,c,h,2)):2===d&&splitEarcut(e,t,n,o,c,h):earcutLinked(filterPoints(e),t,n,o,c,h,1);break}}function isEar(e){let t=e.prev,n=e,o=e.next;if(area(t,n,o)>=0)return!1;let c=e.next.next;while(c!==e.prev){if(pointInTriangle(t.x,t.y,n.x,n.y,o.x,o.y,c.x,c.y)&&area(c.prev,c,c.next)>=0)return!1;c=c.next}return!0}function isEarHashed(e,t,n,o){let c=e.prev,h=e,d=e.next;if(area(c,h,d)>=0)return!1;let p=c.x<h.x?c.x<d.x?c.x:d.x:h.x<d.x?h.x:d.x,m=c.y<h.y?c.y<d.y?c.y:d.y:h.y<d.y?h.y:d.y,g=c.x>h.x?c.x>d.x?c.x:d.x:h.x>d.x?h.x:d.x,y=c.y>h.y?c.y>d.y?c.y:d.y:h.y>d.y?h.y:d.y,x=zOrder(p,m,t,n,o),b=zOrder(g,y,t,n,o),M=e.prevZ,_=e.nextZ;while(M&&M.z>=x&&_&&_.z<=b){if(M!==e.prev&&M!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,M.x,M.y)&&area(M.prev,M,M.next)>=0)return!1;if(M=M.prevZ,_!==e.prev&&_!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,_.x,_.y)&&area(_.prev,_,_.next)>=0)return!1;_=_.nextZ}while(M&&M.z>=x){if(M!==e.prev&&M!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,M.x,M.y)&&area(M.prev,M,M.next)>=0)return!1;M=M.prevZ}while(_&&_.z<=b){if(_!==e.prev&&_!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,_.x,_.y)&&area(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function cureLocalIntersections(e,t,n){let o=e;do{let c=o.prev,h=o.next.next;!equals(c,h)&&intersects(c,o,o.next,h)&&locallyInside(c,h)&&locallyInside(h,c)&&(t.push(c.i/n),t.push(o.i/n),t.push(h.i/n),removeNode(o),removeNode(o.next),o=e=h),o=o.next}while(o!==e);return filterPoints(o)}function splitEarcut(e,t,n,o,c,h){let d=e;do{let e=d.next.next;while(e!==d.prev){if(d.i!==e.i&&isValidDiagonal(d,e)){let p=splitPolygon(d,e);return d=filterPoints(d,d.next),p=filterPoints(p,p.next),earcutLinked(d,t,n,o,c,h),void earcutLinked(p,t,n,o,c,h)}e=e.next}d=d.next}while(d!==e)}function eliminateHoles(e,t,n,o){let c,h,d,p,m,g=[];for(c=0,h=t.length;c<h;c++)d=t[c]*o,p=c<h-1?t[c+1]*o:e.length,m=linkedList(e,d,p,o,!1),m===m.next&&(m.steiner=!0),g.push(getLeftmost(m));for(g.sort(compareX),c=0;c<g.length;c++)eliminateHole(g[c],n),n=filterPoints(n,n.next);return n}function compareX(e,t){return e.x-t.x}function eliminateHole(e,t){if(t=findHoleBridge(e,t),t){const n=splitPolygon(t,e);filterPoints(t,t.next),filterPoints(n,n.next)}}function findHoleBridge(e,t){let n,o=t,c=e.x,h=e.y,d=-1/0;do{if(h<=o.y&&h>=o.next.y&&o.next.y!==o.y){let e=o.x+(h-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(e<=c&&e>d){if(d=e,e===c){if(h===o.y)return o;if(h===o.next.y)return o.next}n=o.x<o.next.x?o:o.next}}o=o.next}while(o!==t);if(!n)return null;if(c===d)return n;let p,m=n,g=n.x,y=n.y,x=1/0;o=n;do{c>=o.x&&o.x>=g&&c!==o.x&&pointInTriangle(h<y?c:d,h,g,y,h<y?d:c,h,o.x,o.y)&&(p=Math.abs(h-o.y)/(c-o.x),locallyInside(o,e)&&(p<x||p===x&&(o.x>n.x||o.x===n.x&&sectorContainsSector(n,o)))&&(n=o,x=p)),o=o.next}while(o!==m);return n}function sectorContainsSector(e,t){return area(e.prev,e,t.prev)<0&&area(t.next,e,e.next)<0}function indexCurve(e,t,n,o){let c=e;do{null===c.z&&(c.z=zOrder(c.x,c.y,t,n,o)),c.prevZ=c.prev,c.nextZ=c.next,c=c.next}while(c!==e);c.prevZ.nextZ=null,c.prevZ=null,sortLinked(c)}function sortLinked(e){let t,n,o,c,h,d,p,m,g=1;do{n=e,e=null,h=null,d=0;while(n){for(d++,o=n,p=0,t=0;t<g;t++)if(p++,o=o.nextZ,!o)break;m=g;while(p>0||m>0&&o)0!==p&&(0===m||!o||n.z<=o.z)?(c=n,n=n.nextZ,p--):(c=o,o=o.nextZ,m--),h?h.nextZ=c:e=c,c.prevZ=h,h=c;n=o}h.nextZ=null,g*=2}while(d>1);return e}function zOrder(e,t,n,o,c){return e=32767*(e-n)*c,t=32767*(t-o)*c,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e|t<<1}function getLeftmost(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function pointInTriangle(e,t,n,o,c,h,d,p){return(c-d)*(t-p)-(e-d)*(h-p)>=0&&(e-d)*(o-p)-(n-d)*(t-p)>=0&&(n-d)*(h-p)-(c-d)*(o-p)>=0}function isValidDiagonal(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!intersectsPolygon(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&middleInside(e,t)&&(area(e.prev,e,t.prev)||area(e,t.prev,t))||equals(e,t)&&area(e.prev,e,e.next)>0&&area(t.prev,t,t.next)>0)}function area(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function equals(e,t){return e.x===t.x&&e.y===t.y}function intersects(e,t,n,o){const c=sign(area(e,t,n)),h=sign(area(e,t,o)),d=sign(area(n,o,e)),p=sign(area(n,o,t));return c!==h&&d!==p||(!(0!==c||!onSegment(e,n,t))||(!(0!==h||!onSegment(e,o,t))||(!(0!==d||!onSegment(n,e,o))||!(0!==p||!onSegment(n,t,o)))))}function onSegment(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function sign(e){return e>0?1:e<0?-1:0}function intersectsPolygon(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&intersects(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}function locallyInside(e,t){return area(e.prev,e,e.next)<0?area(e,t,e.next)>=0&&area(e,e.prev,t)>=0:area(e,t,e.prev)<0||area(e,e.next,t)<0}function middleInside(e,t){let n=e,o=!1,c=(e.x+t.x)/2,h=(e.y+t.y)/2;do{n.y>h!==n.next.y>h&&n.next.y!==n.y&&c<(n.next.x-n.x)*(h-n.y)/(n.next.y-n.y)+n.x&&(o=!o),n=n.next}while(n!==e);return o}function splitPolygon(e,t){let n=new Node(e.i,e.x,e.y),o=new Node(t.i,t.x,t.y),c=e.next,h=t.prev;return e.next=t,t.prev=e,n.next=c,c.prev=n,o.next=n,n.prev=o,h.next=o,o.prev=h,o}function insertNode(e,t,n,o){const c=new Node(e,t,n);return o?(c.next=o.next,c.prev=o,o.next.prev=c,o.next=c):(c.prev=c,c.next=c),c}function removeNode(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(e,t,n,o){let c=0;for(let h=t,d=n-o;h<n;h+=o)c+=(e[d]-e[h])*(e[h+1]+e[d+1]),d=h;return c}const ac={area:function(e){const t=e.length;let n=0;for(let o=t-1,c=0;c<t;o=c++)n+=e[o].x*e[c].y-e[c].x*e[o].y;return.5*n},isClockWise:function(e){return ac.area(e)<0},triangulateShape:function(e,t){const n=[],o=[],c=[];removeDupEndPts(e),addContour(n,e);let h=e.length;t.forEach(removeDupEndPts);for(let p=0;p<t.length;p++)o.push(h),h+=t[p].length,addContour(n,t[p]);const d=oc.triangulate(n,o);for(let p=0;p<d.length;p+=3)c.push(d.slice(p,p+3));return c}};function removeDupEndPts(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function addContour(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}function ExtrudeGeometry(e,t){Geometry.call(this),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},this.fromBufferGeometry(new ExtrudeBufferGeometry(e,t)),this.mergeVertices()}function ExtrudeBufferGeometry(e,t){BufferGeometry.call(this),this.type="ExtrudeBufferGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,o=[],c=[];for(let h=0,d=e.length;h<d;h++){const t=e[h];addShape(t)}function addShape(e){const h=[],d=void 0!==t.curveSegments?t.curveSegments:12,p=void 0!==t.steps?t.steps:1;let m=void 0!==t.depth?t.depth:100,g=void 0===t.bevelEnabled||t.bevelEnabled,y=void 0!==t.bevelThickness?t.bevelThickness:6,x=void 0!==t.bevelSize?t.bevelSize:y-2,b=void 0!==t.bevelOffset?t.bevelOffset:0,M=void 0!==t.bevelSegments?t.bevelSegments:3;const _=t.extrudePath,w=void 0!==t.UVGenerator?t.UVGenerator:sc;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),m=t.amount);let S,T,E,L,A,C=!1;_&&(S=_.getSpacedPoints(p),C=!0,g=!1,T=_.computeFrenetFrames(p,!1),E=new Vector3,L=new Vector3,A=new Vector3),g||(M=0,y=0,x=0,b=0);const P=e.extractPoints(d);let R=P.shape;const B=P.holes,D=!ac.isClockWise(R);if(D){R=R.reverse();for(let e=0,t=B.length;e<t;e++){const t=B[e];ac.isClockWise(t)&&(B[e]=t.reverse())}}const G=ac.triangulateShape(R,B),I=R;for(let t=0,n=B.length;t<n;t++){const e=B[t];R=R.concat(e)}function scalePt2(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const O=R.length,V=G.length;function getBevelVec(e,t,n){let o,c,h;const d=e.x-t.x,p=e.y-t.y,m=n.x-e.x,g=n.y-e.y,y=d*d+p*p,x=d*g-p*m;if(Math.abs(x)>Number.EPSILON){const x=Math.sqrt(y),b=Math.sqrt(m*m+g*g),M=t.x-p/x,_=t.y+d/x,w=n.x-g/b,S=n.y+m/b,T=((w-M)*g-(S-_)*m)/(d*g-p*m);o=M+d*T-e.x,c=_+p*T-e.y;const E=o*o+c*c;if(E<=2)return new Vector2(o,c);h=Math.sqrt(E/2)}else{let e=!1;d>Number.EPSILON?m>Number.EPSILON&&(e=!0):d<-Number.EPSILON?m<-Number.EPSILON&&(e=!0):Math.sign(p)===Math.sign(g)&&(e=!0),e?(o=-p,c=d,h=Math.sqrt(y)):(o=d,c=p,h=Math.sqrt(y/2))}return new Vector2(o/h,c/h)}const N=[];for(let t=0,n=I.length,o=n-1,c=t+1;t<n;t++,o++,c++)o===n&&(o=0),c===n&&(c=0),N[t]=getBevelVec(I[t],I[o],I[c]);const F=[];let U,z=N.concat();for(let t=0,n=B.length;t<n;t++){const e=B[t];U=[];for(let t=0,n=e.length,o=n-1,c=t+1;t<n;t++,o++,c++)o===n&&(o=0),c===n&&(c=0),U[t]=getBevelVec(e[t],e[o],e[c]);F.push(U),z=z.concat(U)}for(let t=0;t<M;t++){const e=t/M,n=y*Math.cos(e*Math.PI/2),o=x*Math.sin(e*Math.PI/2)+b;for(let t=0,c=I.length;t<c;t++){const e=scalePt2(I[t],N[t],o);v(e.x,e.y,-n)}for(let t=0,c=B.length;t<c;t++){const e=B[t];U=F[t];for(let t=0,c=e.length;t<c;t++){const c=scalePt2(e[t],U[t],o);v(c.x,c.y,-n)}}}const H=x+b;for(let t=0;t<O;t++){const e=g?scalePt2(R[t],z[t],H):R[t];C?(L.copy(T.normals[0]).multiplyScalar(e.x),E.copy(T.binormals[0]).multiplyScalar(e.y),A.copy(S[0]).add(L).add(E),v(A.x,A.y,A.z)):v(e.x,e.y,0)}for(let t=1;t<=p;t++)for(let e=0;e<O;e++){const n=g?scalePt2(R[e],z[e],H):R[e];C?(L.copy(T.normals[t]).multiplyScalar(n.x),E.copy(T.binormals[t]).multiplyScalar(n.y),A.copy(S[t]).add(L).add(E),v(A.x,A.y,A.z)):v(n.x,n.y,m/p*t)}for(let t=M-1;t>=0;t--){const e=t/M,n=y*Math.cos(e*Math.PI/2),o=x*Math.sin(e*Math.PI/2)+b;for(let t=0,c=I.length;t<c;t++){const e=scalePt2(I[t],N[t],o);v(e.x,e.y,m+n)}for(let t=0,c=B.length;t<c;t++){const e=B[t];U=F[t];for(let t=0,c=e.length;t<c;t++){const c=scalePt2(e[t],U[t],o);C?v(c.x,c.y+S[p-1].y,S[p-1].x+n):v(c.x,c.y,m+n)}}}function buildLidFaces(){const e=o.length/3;if(g){let e=0,t=O*e;for(let n=0;n<V;n++){const e=G[n];f3(e[2]+t,e[1]+t,e[0]+t)}e=p+2*M,t=O*e;for(let n=0;n<V;n++){const e=G[n];f3(e[0]+t,e[1]+t,e[2]+t)}}else{for(let e=0;e<V;e++){const t=G[e];f3(t[2],t[1],t[0])}for(let e=0;e<V;e++){const t=G[e];f3(t[0]+O*p,t[1]+O*p,t[2]+O*p)}}n.addGroup(e,o.length/3-e,0)}function buildSideFaces(){const e=o.length/3;let t=0;sidewalls(I,t),t+=I.length;for(let n=0,o=B.length;n<o;n++){const e=B[n];sidewalls(e,t),t+=e.length}n.addGroup(e,o.length/3-e,1)}function sidewalls(e,t){let n=e.length;while(--n>=0){const o=n;let c=n-1;c<0&&(c=e.length-1);for(let e=0,n=p+2*M;e<n;e++){const n=O*e,h=O*(e+1),d=t+o+n,p=t+c+n,m=t+c+h,g=t+o+h;f4(d,p,m,g)}}}function v(e,t,n){h.push(e),h.push(t),h.push(n)}function f3(e,t,c){addVertex(e),addVertex(t),addVertex(c);const h=o.length/3,d=w.generateTopUV(n,o,h-3,h-2,h-1);addUV(d[0]),addUV(d[1]),addUV(d[2])}function f4(e,t,c,h){addVertex(e),addVertex(t),addVertex(h),addVertex(t),addVertex(c),addVertex(h);const d=o.length/3,p=w.generateSideWallUV(n,o,d-6,d-3,d-2,d-1);addUV(p[0]),addUV(p[1]),addUV(p[3]),addUV(p[1]),addUV(p[2]),addUV(p[3])}function addVertex(e){o.push(h[3*e+0]),o.push(h[3*e+1]),o.push(h[3*e+2])}function addUV(e){c.push(e.x),c.push(e.y)}buildLidFaces(),buildSideFaces()}this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("uv",new Float32BufferAttribute(c,2)),this.computeVertexNormals()}ExtrudeGeometry.prototype=Object.create(Geometry.prototype),ExtrudeGeometry.prototype.constructor=ExtrudeGeometry,ExtrudeGeometry.prototype.toJSON=function(){const e=Geometry.prototype.toJSON.call(this),t=this.parameters.shapes,n=this.parameters.options;return toJSON(t,n,e)},ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype),ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry,ExtrudeBufferGeometry.prototype.toJSON=function(){const e=BufferGeometry.prototype.toJSON.call(this),t=this.parameters.shapes,n=this.parameters.options;return toJSON(t,n,e)};const sc={generateTopUV:function(e,t,n,o,c){const h=t[3*n],d=t[3*n+1],p=t[3*o],m=t[3*o+1],g=t[3*c],y=t[3*c+1];return[new Vector2(h,d),new Vector2(p,m),new Vector2(g,y)]},generateSideWallUV:function(e,t,n,o,c,h){const d=t[3*n],p=t[3*n+1],m=t[3*n+2],g=t[3*o],y=t[3*o+1],x=t[3*o+2],b=t[3*c],M=t[3*c+1],_=t[3*c+2],w=t[3*h],S=t[3*h+1],T=t[3*h+2];return Math.abs(p-y)<.01?[new Vector2(d,1-m),new Vector2(g,1-x),new Vector2(b,1-_),new Vector2(w,1-T)]:[new Vector2(p,1-m),new Vector2(y,1-x),new Vector2(M,1-_),new Vector2(S,1-T)]}};function toJSON(e,t,n){if(n.shapes=[],Array.isArray(e))for(let o=0,c=e.length;o<c;o++){const t=e[o];n.shapes.push(t.uuid)}else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}function TextGeometry(e,t){Geometry.call(this),this.type="TextGeometry",this.parameters={text:e,parameters:t},this.fromBufferGeometry(new TextBufferGeometry(e,t)),this.mergeVertices()}function TextBufferGeometry(e,t){t=t||{};const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Geometry;const o=n.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),ExtrudeBufferGeometry.call(this,o,t),this.type="TextBufferGeometry"}function SphereGeometry(e,t,n,o,c,h,d){Geometry.call(this),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:o,phiLength:c,thetaStart:h,thetaLength:d},this.fromBufferGeometry(new SphereBufferGeometry(e,t,n,o,c,h,d)),this.mergeVertices()}function SphereBufferGeometry(e,t,n,o,c,h,d){BufferGeometry.call(this),this.type="SphereBufferGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:o,phiLength:c,thetaStart:h,thetaLength:d},e=e||1,t=Math.max(3,Math.floor(t)||8),n=Math.max(2,Math.floor(n)||6),o=void 0!==o?o:0,c=void 0!==c?c:2*Math.PI,h=void 0!==h?h:0,d=void 0!==d?d:Math.PI;const p=Math.min(h+d,Math.PI);let m=0;const g=[],y=new Vector3,x=new Vector3,b=[],M=[],_=[],w=[];for(let S=0;S<=n;S++){const b=[],T=S/n;let E=0;0==S&&0==h?E=.5/t:S==n&&p==Math.PI&&(E=-.5/t);for(let n=0;n<=t;n++){const p=n/t;y.x=-e*Math.cos(o+p*c)*Math.sin(h+T*d),y.y=e*Math.cos(h+T*d),y.z=e*Math.sin(o+p*c)*Math.sin(h+T*d),M.push(y.x,y.y,y.z),x.copy(y).normalize(),_.push(x.x,x.y,x.z),w.push(p+E,1-T),b.push(m++)}g.push(b)}for(let S=0;S<n;S++)for(let e=0;e<t;e++){const t=g[S][e+1],o=g[S][e],c=g[S+1][e],d=g[S+1][e+1];(0!==S||h>0)&&b.push(t,o,d),(S!==n-1||p<Math.PI)&&b.push(o,c,d)}this.setIndex(b),this.setAttribute("position",new Float32BufferAttribute(M,3)),this.setAttribute("normal",new Float32BufferAttribute(_,3)),this.setAttribute("uv",new Float32BufferAttribute(w,2))}function RingGeometry(e,t,n,o,c,h){Geometry.call(this),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:o,thetaStart:c,thetaLength:h},this.fromBufferGeometry(new RingBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}function RingBufferGeometry(e,t,n,o,c,h){BufferGeometry.call(this),this.type="RingBufferGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:o,thetaStart:c,thetaLength:h},e=e||.5,t=t||1,c=void 0!==c?c:0,h=void 0!==h?h:2*Math.PI,n=void 0!==n?Math.max(3,n):8,o=void 0!==o?Math.max(1,o):1;const d=[],p=[],m=[],g=[];let y=e;const x=(t-e)/o,b=new Vector3,M=new Vector2;for(let _=0;_<=o;_++){for(let e=0;e<=n;e++){const o=c+e/n*h;b.x=y*Math.cos(o),b.y=y*Math.sin(o),p.push(b.x,b.y,b.z),m.push(0,0,1),M.x=(b.x/t+1)/2,M.y=(b.y/t+1)/2,g.push(M.x,M.y)}y+=x}for(let _=0;_<o;_++){const e=_*(n+1);for(let t=0;t<n;t++){const o=t+e,c=o,h=o+n+1,p=o+n+2,m=o+1;d.push(c,h,m),d.push(h,p,m)}}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(g,2))}function LatheGeometry(e,t,n,o){Geometry.call(this),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:o},this.fromBufferGeometry(new LatheBufferGeometry(e,t,n,o)),this.mergeVertices()}function LatheBufferGeometry(e,t,n,o){BufferGeometry.call(this),this.type="LatheBufferGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:o},t=Math.floor(t)||12,n=n||0,o=o||2*Math.PI,o=Wn.clamp(o,0,2*Math.PI);const c=[],h=[],d=[],p=1/t,m=new Vector3,g=new Vector2;for(let y=0;y<=t;y++){const c=n+y*p*o,x=Math.sin(c),b=Math.cos(c);for(let n=0;n<=e.length-1;n++)m.x=e[n].x*x,m.y=e[n].y,m.z=e[n].x*b,h.push(m.x,m.y,m.z),g.x=y/t,g.y=n/(e.length-1),d.push(g.x,g.y)}for(let y=0;y<t;y++)for(let t=0;t<e.length-1;t++){const n=t+y*e.length,o=n,h=n+e.length,d=n+e.length+1,p=n+1;c.push(o,h,p),c.push(h,d,p)}if(this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2)),this.computeVertexNormals(),o===2*Math.PI){const n=this.attributes.normal.array,o=new Vector3,c=new Vector3,h=new Vector3,d=t*e.length*3;for(let t=0,p=0;t<e.length;t++,p+=3)o.x=n[p+0],o.y=n[p+1],o.z=n[p+2],c.x=n[d+p+0],c.y=n[d+p+1],c.z=n[d+p+2],h.addVectors(o,c).normalize(),n[p+0]=n[d+p+0]=h.x,n[p+1]=n[d+p+1]=h.y,n[p+2]=n[d+p+2]=h.z}}function ShapeGeometry(e,t){Geometry.call(this),this.type="ShapeGeometry","object"===typeof t&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),t=t.curveSegments),this.parameters={shapes:e,curveSegments:t},this.fromBufferGeometry(new ShapeBufferGeometry(e,t)),this.mergeVertices()}function ShapeBufferGeometry(e,t){BufferGeometry.call(this),this.type="ShapeBufferGeometry",this.parameters={shapes:e,curveSegments:t},t=t||12;const n=[],o=[],c=[],h=[];let d=0,p=0;if(!1===Array.isArray(e))addShape(e);else for(let m=0;m<e.length;m++)addShape(e[m]),this.addGroup(d,p,m),d+=p,p=0;function addShape(e){const d=o.length/3,m=e.extractPoints(t);let g=m.shape;const y=m.holes;!1===ac.isClockWise(g)&&(g=g.reverse());for(let t=0,n=y.length;t<n;t++){const e=y[t];!0===ac.isClockWise(e)&&(y[t]=e.reverse())}const x=ac.triangulateShape(g,y);for(let t=0,n=y.length;t<n;t++){const e=y[t];g=g.concat(e)}for(let t=0,n=g.length;t<n;t++){const e=g[t];o.push(e.x,e.y,0),c.push(0,0,1),h.push(e.x,e.y)}for(let t=0,o=x.length;t<o;t++){const e=x[t],o=e[0]+d,c=e[1]+d,h=e[2]+d;n.push(o,c,h),p+=3}}this.setIndex(n),this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("normal",new Float32BufferAttribute(c,3)),this.setAttribute("uv",new Float32BufferAttribute(h,2))}function toJSON$1(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,o=e.length;n<o;n++){const o=e[n];t.shapes.push(o.uuid)}else t.shapes.push(e.uuid);return t}function EdgesGeometry(e,t){BufferGeometry.call(this),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=void 0!==t?t:1;const n=[],o=Math.cos(Wn.DEG2RAD*t),c=[0,0],h={};let d,p,m;const g=["a","b","c"];let y;e.isBufferGeometry?(y=new Geometry,y.fromBufferGeometry(e)):y=e.clone(),y.mergeVertices(),y.computeFaceNormals();const x=y.vertices,b=y.faces;for(let M=0,_=b.length;M<_;M++){const e=b[M];for(let t=0;t<3;t++)d=e[g[t]],p=e[g[(t+1)%3]],c[0]=Math.min(d,p),c[1]=Math.max(d,p),m=c[0]+","+c[1],void 0===h[m]?h[m]={index1:c[0],index2:c[1],face1:M,face2:void 0}:h[m].face2=M}for(m in h){const e=h[m];if(void 0===e.face2||b[e.face1].normal.dot(b[e.face2].normal)<=o){let t=x[e.index1];n.push(t.x,t.y,t.z),t=x[e.index2],n.push(t.x,t.y,t.z)}}this.setAttribute("position",new Float32BufferAttribute(n,3))}function CylinderGeometry(e,t,n,o,c,h,d,p){Geometry.call(this),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:o,heightSegments:c,openEnded:h,thetaStart:d,thetaLength:p},this.fromBufferGeometry(new CylinderBufferGeometry(e,t,n,o,c,h,d,p)),this.mergeVertices()}function CylinderBufferGeometry(e,t,n,o,c,h,d,p){BufferGeometry.call(this),this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:o,heightSegments:c,openEnded:h,thetaStart:d,thetaLength:p};const m=this;e=void 0!==e?e:1,t=void 0!==t?t:1,n=n||1,o=Math.floor(o)||8,c=Math.floor(c)||1,h=void 0!==h&&h,d=void 0!==d?d:0,p=void 0!==p?p:2*Math.PI;const g=[],y=[],x=[],b=[];let M=0;const _=[],w=n/2;let S=0;function generateTorso(){const h=new Vector3,T=new Vector3;let E=0;const L=(t-e)/n;for(let m=0;m<=c;m++){const g=[],S=m/c,E=S*(t-e)+e;for(let e=0;e<=o;e++){const t=e/o,c=t*p+d,m=Math.sin(c),_=Math.cos(c);T.x=E*m,T.y=-S*n+w,T.z=E*_,y.push(T.x,T.y,T.z),h.set(m,L,_).normalize(),x.push(h.x,h.y,h.z),b.push(t,1-S),g.push(M++)}_.push(g)}for(let e=0;e<o;e++)for(let t=0;t<c;t++){const n=_[t][e],o=_[t+1][e],c=_[t+1][e+1],h=_[t][e+1];g.push(n,o,h),g.push(o,c,h),E+=6}m.addGroup(S,E,0),S+=E}function generateCap(n){let c,h;const _=new Vector2,T=new Vector3;let E=0;const L=!0===n?e:t,A=!0===n?1:-1;c=M;for(let e=1;e<=o;e++)y.push(0,w*A,0),x.push(0,A,0),b.push(.5,.5),M++;h=M;for(let e=0;e<=o;e++){const t=e/o,n=t*p+d,c=Math.cos(n),h=Math.sin(n);T.x=L*h,T.y=w*A,T.z=L*c,y.push(T.x,T.y,T.z),x.push(0,A,0),_.x=.5*c+.5,_.y=.5*h*A+.5,b.push(_.x,_.y),M++}for(let e=0;e<o;e++){const t=c+e,o=h+e;!0===n?g.push(o,o+1,t):g.push(o+1,o,t),E+=3}m.addGroup(S,E,!0===n?1:2),S+=E}generateTorso(),!1===h&&(e>0&&generateCap(!0),t>0&&generateCap(!1)),this.setIndex(g),this.setAttribute("position",new Float32BufferAttribute(y,3)),this.setAttribute("normal",new Float32BufferAttribute(x,3)),this.setAttribute("uv",new Float32BufferAttribute(b,2))}function ConeGeometry(e,t,n,o,c,h,d){CylinderGeometry.call(this,0,e,t,n,o,c,h,d),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:o,openEnded:c,thetaStart:h,thetaLength:d}}function ConeBufferGeometry(e,t,n,o,c,h,d){CylinderBufferGeometry.call(this,0,e,t,n,o,c,h,d),this.type="ConeBufferGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:o,openEnded:c,thetaStart:h,thetaLength:d}}function CircleGeometry(e,t,n,o){Geometry.call(this),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:o},this.fromBufferGeometry(new CircleBufferGeometry(e,t,n,o)),this.mergeVertices()}function CircleBufferGeometry(e,t,n,o){BufferGeometry.call(this),this.type="CircleBufferGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:o},e=e||1,t=void 0!==t?Math.max(3,t):8,n=void 0!==n?n:0,o=void 0!==o?o:2*Math.PI;const c=[],h=[],d=[],p=[],m=new Vector3,g=new Vector2;h.push(0,0,0),d.push(0,0,1),p.push(.5,.5);for(let y=0,x=3;y<=t;y++,x+=3){const c=n+y/t*o;m.x=e*Math.cos(c),m.y=e*Math.sin(c),h.push(m.x,m.y,m.z),d.push(0,0,1),g.x=(h[x]/e+1)/2,g.y=(h[x+1]/e+1)/2,p.push(g.x,g.y)}for(let y=1;y<=t;y++)c.push(y,y+1,0);this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("normal",new Float32BufferAttribute(d,3)),this.setAttribute("uv",new Float32BufferAttribute(p,2))}TextGeometry.prototype=Object.create(Geometry.prototype),TextGeometry.prototype.constructor=TextGeometry,TextBufferGeometry.prototype=Object.create(ExtrudeBufferGeometry.prototype),TextBufferGeometry.prototype.constructor=TextBufferGeometry,SphereGeometry.prototype=Object.create(Geometry.prototype),SphereGeometry.prototype.constructor=SphereGeometry,SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype),SphereBufferGeometry.prototype.constructor=SphereBufferGeometry,RingGeometry.prototype=Object.create(Geometry.prototype),RingGeometry.prototype.constructor=RingGeometry,RingBufferGeometry.prototype=Object.create(BufferGeometry.prototype),RingBufferGeometry.prototype.constructor=RingBufferGeometry,LatheGeometry.prototype=Object.create(Geometry.prototype),LatheGeometry.prototype.constructor=LatheGeometry,LatheBufferGeometry.prototype=Object.create(BufferGeometry.prototype),LatheBufferGeometry.prototype.constructor=LatheBufferGeometry,ShapeGeometry.prototype=Object.create(Geometry.prototype),ShapeGeometry.prototype.constructor=ShapeGeometry,ShapeGeometry.prototype.toJSON=function(){const e=Geometry.prototype.toJSON.call(this),t=this.parameters.shapes;return toJSON$1(t,e)},ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype),ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry,ShapeBufferGeometry.prototype.toJSON=function(){const e=BufferGeometry.prototype.toJSON.call(this),t=this.parameters.shapes;return toJSON$1(t,e)},EdgesGeometry.prototype=Object.create(BufferGeometry.prototype),EdgesGeometry.prototype.constructor=EdgesGeometry,CylinderGeometry.prototype=Object.create(Geometry.prototype),CylinderGeometry.prototype.constructor=CylinderGeometry,CylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype),CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry,ConeGeometry.prototype=Object.create(CylinderGeometry.prototype),ConeGeometry.prototype.constructor=ConeGeometry,ConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype),ConeBufferGeometry.prototype.constructor=ConeBufferGeometry,CircleGeometry.prototype=Object.create(Geometry.prototype),CircleGeometry.prototype.constructor=CircleGeometry,CircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype),CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;var cc=Object.freeze({__proto__:null,WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry});function ShadowMaterial(e){Material.call(this),this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.setValues(e)}function RawShaderMaterial(e){ShaderMaterial.call(this,e),this.type="RawShaderMaterial"}function MeshStandardMaterial(e){Material.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=yn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function MeshPhysicalMaterial(e){MeshStandardMaterial.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,this.sheen=null,this.transparency=0,this.setValues(e)}function MeshPhongMaterial(e){Material.call(this),this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=yn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oe,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshToonMaterial(e){Material.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=yn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshNormalMaterial(e){Material.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=yn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshLambertMaterial(e){Material.call(this),this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=oe,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshMatcapMaterial(e){Material.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=yn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function LineDashedMaterial(e){LineBasicMaterial.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}ShadowMaterial.prototype=Object.create(Material.prototype),ShadowMaterial.prototype.constructor=ShadowMaterial,ShadowMaterial.prototype.isShadowMaterial=!0,ShadowMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this},RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype),RawShaderMaterial.prototype.constructor=RawShaderMaterial,RawShaderMaterial.prototype.isRawShaderMaterial=!0,MeshStandardMaterial.prototype=Object.create(Material.prototype),MeshStandardMaterial.prototype.constructor=MeshStandardMaterial,MeshStandardMaterial.prototype.isMeshStandardMaterial=!0,MeshStandardMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},MeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype),MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial,MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=!0,MeshPhysicalMaterial.prototype.copy=function(e){return MeshStandardMaterial.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new Color).copy(e.sheen):this.sheen=null,this.transparency=e.transparency,this},MeshPhongMaterial.prototype=Object.create(Material.prototype),MeshPhongMaterial.prototype.constructor=MeshPhongMaterial,MeshPhongMaterial.prototype.isMeshPhongMaterial=!0,MeshPhongMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshToonMaterial.prototype=Object.create(Material.prototype),MeshToonMaterial.prototype.constructor=MeshToonMaterial,MeshToonMaterial.prototype.isMeshToonMaterial=!0,MeshToonMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshNormalMaterial.prototype=Object.create(Material.prototype),MeshNormalMaterial.prototype.constructor=MeshNormalMaterial,MeshNormalMaterial.prototype.isMeshNormalMaterial=!0,MeshNormalMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshLambertMaterial.prototype=Object.create(Material.prototype),MeshLambertMaterial.prototype.constructor=MeshLambertMaterial,MeshLambertMaterial.prototype.isMeshLambertMaterial=!0,MeshLambertMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshMatcapMaterial.prototype=Object.create(Material.prototype),MeshMatcapMaterial.prototype.constructor=MeshMatcapMaterial,MeshMatcapMaterial.prototype.isMeshMatcapMaterial=!0,MeshMatcapMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},LineDashedMaterial.prototype=Object.create(LineBasicMaterial.prototype),LineDashedMaterial.prototype.constructor=LineDashedMaterial,LineDashedMaterial.prototype.isLineDashedMaterial=!0,LineDashedMaterial.prototype.copy=function(e){return LineBasicMaterial.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var lc=Object.freeze({__proto__:null,ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});const uc={arraySlice:function(e,t,n){return uc.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"===typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function compareTime(t,n){return e[t]-e[n]}const t=e.length,n=new Array(t);for(let o=0;o!==t;++o)n[o]=o;return n.sort(compareTime),n},sortedArray:function(e,t,n){const o=e.length,c=new e.constructor(o);for(let h=0,d=0;d!==o;++h){const o=n[h]*t;for(let n=0;n!==t;++n)c[d++]=e[o+n]}return c},flattenJSON:function(e,t,n,o){let c=1,h=e[0];while(void 0!==h&&void 0===h[o])h=e[c++];if(void 0===h)return;let d=h[o];if(void 0!==d)if(Array.isArray(d))do{d=h[o],void 0!==d&&(t.push(h.time),n.push.apply(n,d)),h=e[c++]}while(void 0!==h);else if(void 0!==d.toArray)do{d=h[o],void 0!==d&&(t.push(h.time),d.toArray(n,n.length)),h=e[c++]}while(void 0!==h);else do{d=h[o],void 0!==d&&(t.push(h.time),n.push(d)),h=e[c++]}while(void 0!==h)},subclip:function(e,t,n,o,c){c=c||30;const h=e.clone();h.name=t;const d=[];for(let m=0;m<h.tracks.length;++m){const e=h.tracks[m],t=e.getValueSize(),p=[],g=[];for(let h=0;h<e.times.length;++h){const d=e.times[h]*c;if(!(d<n||d>=o)){p.push(e.times[h]);for(let n=0;n<t;++n)g.push(e.values[h*t+n])}}0!==p.length&&(e.times=uc.convertArray(p,e.times.constructor),e.values=uc.convertArray(g,e.values.constructor),d.push(e))}h.tracks=d;let p=1/0;for(let m=0;m<h.tracks.length;++m)p>h.tracks[m].times[0]&&(p=h.tracks[m].times[0]);for(let m=0;m<h.tracks.length;++m)h.tracks[m].shift(-1*p);return h.resetDuration(),h},makeClipAdditive:function(e,t,n,o){void 0===t&&(t=0),void 0===n&&(n=e),(void 0===o||o<=0)&&(o=30);const c=e.tracks.length,h=t/o;for(let d=0;d<c;++d){const t=n.tracks[d],o=t.ValueTypeName;if("bool"===o||"string"===o)continue;const c=e.tracks.find((function(e){return e.name===t.name&&e.ValueTypeName===o}));if(void 0===c)continue;const p=t.getValueSize(),m=t.times.length-1;let g;if(h<=t.times[0])g=uc.arraySlice(t.values,0,t.valueSize);else if(h>=t.times[m]){const e=m*p;g=uc.arraySlice(t.values,e)}else{const e=t.createInterpolant();e.evaluate(h),g=e.resultBuffer}if("quaternion"===o){const e=new Quaternion(g[0],g[1],g[2],g[3]).normalize().conjugate();e.toArray(g)}const y=c.times.length;for(let e=0;e<y;++e){const t=e*p;if("quaternion"===o)Quaternion.multiplyQuaternionsFlat(c.values,t,g,0,c.values,t);else for(let e=0;e<p;++e)c.values[t+e]-=g[e]}}return e.blendMode=nn,e}};function Interpolant(e,t,n,o){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==o?o:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function CubicInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function LinearInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function DiscreteInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function KeyframeTrack(e,t,n,o){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=uc.convertArray(t,this.TimeBufferType),this.values=uc.convertArray(n,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}function BooleanKeyframeTrack(e,t,n){KeyframeTrack.call(this,e,t,n)}function ColorKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function NumberKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function QuaternionLinearInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function QuaternionKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function StringKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function VectorKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function AnimationClip(e,t,n,o){this.name=e,this.tracks=n,this.duration=void 0!==t?t:-1,this.blendMode=void 0!==o?o:tn,this.uuid=Wn.generateUUID(),this.duration<0&&this.resetDuration()}function getTrackTypeForValueTypeName(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function parseKeyframeTrack(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=getTrackTypeForValueTypeName(e.type);if(void 0===e.times){const t=[],n=[];uc.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(Interpolant.prototype,{evaluate:function(e){let t=this.parameterPositions,n=this._cachedIndex,o=t[n],c=t[n-1];e:{t:{let h;n:{r:if(!(e<o)){for(let h=n+2;;){if(void 0===o){if(e<c)break r;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,c)}if(n===h)break;if(c=o,o=t[++n],e<o)break t}h=t.length;break n}if(e>=c)break e;{const d=t[1];e<d&&(n=2,c=d);for(let h=n-2;;){if(void 0===c)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(n===h)break;if(o=c,c=t[--n-1],e>=c)break t}h=n,n=0}}while(n<h){const o=n+h>>>1;e<t[o]?h=o:n=o+1}if(o=t[n],c=t[n-1],void 0===c)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(void 0===o)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,c,e)}this._cachedIndex=n,this.intervalChanged_(n,c,o)}return this.interpolate_(n,c,e,o)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,o=this.valueSize,c=e*o;for(let h=0;h!==o;++h)t[h]=n[c+h];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(Interpolant.prototype,{beforeStart_:Interpolant.prototype.copySampleValue_,afterEnd_:Interpolant.prototype.copySampleValue_}),CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:Kt,endingEnd:Kt},intervalChanged_:function(e,t,n){let o=this.parameterPositions,c=e-2,h=e+1,d=o[c],p=o[h];if(void 0===d)switch(this.getSettings_().endingStart){case $t:c=e,d=2*t-n;break;case en:c=o.length-2,d=t+o[c]-o[c+1];break;default:c=e,d=n}if(void 0===p)switch(this.getSettings_().endingEnd){case $t:h=e,p=2*n-t;break;case en:h=1,p=n+o[1]-o[0];break;default:h=e-1,p=t}const m=.5*(n-t),g=this.valueSize;this._weightPrev=m/(t-d),this._weightNext=m/(p-n),this._offsetPrev=c*g,this._offsetNext=h*g},interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=e*d,m=p-d,g=this._offsetPrev,y=this._offsetNext,x=this._weightPrev,b=this._weightNext,M=(n-t)/(o-t),_=M*M,w=_*M,S=-x*w+2*x*_-x*M,T=(1+x)*w+(-1.5-2*x)*_+(-.5+x)*M+1,E=(-1-b)*w+(1.5+b)*_+.5*M,L=b*w-b*_;for(let A=0;A!==d;++A)c[A]=S*h[g+A]+T*h[m+A]+E*h[p+A]+L*h[y+A];return c}}),LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=e*d,m=p-d,g=(n-t)/(o-t),y=1-g;for(let x=0;x!==d;++x)c[x]=h[m+x]*y+h[p+x]*g;return c}}),DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(KeyframeTrack,{toJSON:function(e){const t=e.constructor;let n;if(void 0!==t.toJSON)n=t.toJSON(e);else{n={name:e.name,times:uc.convertArray(e.times,Array),values:uc.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}}),Object.assign(KeyframeTrack.prototype,{constructor:KeyframeTrack,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Jt,InterpolantFactoryMethodDiscrete:function(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case Zt:t=this.InterpolantFactoryMethodDiscrete;break;case Jt:t=this.InterpolantFactoryMethodLinear;break;case Qt:t=this.InterpolantFactoryMethodSmooth;break}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Zt;case this.InterpolantFactoryMethodLinear:return Jt;case this.InterpolantFactoryMethodSmooth:return Qt}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(0!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]+=e}return this},scale:function(e){if(1!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,o=n.length;let c=0,h=o-1;while(c!==o&&n[c]<e)++c;while(-1!==h&&n[h]>t)--h;if(++h,0!==c||h!==o){c>=h&&(h=Math.max(h,1),c=h-1);const e=this.getValueSize();this.times=uc.arraySlice(n,c,h),this.values=uc.arraySlice(this.values,c*e,h*e)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,o=this.values,c=n.length;0===c&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let h=null;for(let d=0;d!==c;d++){const t=n[d];if("number"===typeof t&&isNaN(t)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,d,t),e=!1;break}if(null!==h&&h>t){console.error("THREE.KeyframeTrack: Out of order keys.",this,d,t,h),e=!1;break}h=t}if(void 0!==o&&uc.isTypedArray(o))for(let d=0,p=o.length;d!==p;++d){const t=o[d];if(isNaN(t)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,d,t),e=!1;break}}return e},optimize:function(){const e=uc.arraySlice(this.times),t=uc.arraySlice(this.values),n=this.getValueSize(),o=this.getInterpolation()===Qt,c=e.length-1;let h=1;for(let d=1;d<c;++d){let c=!1;const p=e[d],m=e[d+1];if(p!==m&&(1!==d||p!==p[0]))if(o)c=!0;else{const e=d*n,o=e-n,h=e+n;for(let d=0;d!==n;++d){const n=t[e+d];if(n!==t[o+d]||n!==t[h+d]){c=!0;break}}}if(c){if(d!==h){e[h]=e[d];const o=d*n,c=h*n;for(let e=0;e!==n;++e)t[c+e]=t[o+e]}++h}}if(c>0){e[h]=e[c];for(let e=c*n,o=h*n,d=0;d!==n;++d)t[o+d]=t[e+d];++h}return h!==e.length?(this.times=uc.arraySlice(e,0,h),this.values=uc.arraySlice(t,0,h*n)):(this.times=e,this.values=t),this},clone:function(){const e=uc.arraySlice(this.times,0),t=uc.arraySlice(this.values,0),n=this.constructor,o=new n(this.name,e,t);return o.createInterpolant=this.createInterpolant,o}}),BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:BooleanKeyframeTrack,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:Zt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:ColorKeyframeTrack,ValueTypeName:"color"}),NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:NumberKeyframeTrack,ValueTypeName:"number"}),QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=(n-t)/(o-t);let m=e*d;for(let g=m+d;m!==g;m+=4)Quaternion.slerpFlat(c,0,h,m-d,h,m,p);return c}}),QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:"quaternion",DefaultInterpolation:Jt,InterpolantFactoryMethodLinear:function(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:StringKeyframeTrack,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:Zt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:VectorKeyframeTrack,ValueTypeName:"vector"}),Object.assign(AnimationClip,{parse:function(e){const t=[],n=e.tracks,o=1/(e.fps||1);for(let c=0,h=n.length;c!==h;++c)t.push(parseKeyframeTrack(n[c]).scale(o));return new AnimationClip(e.name,e.duration,t,e.blendMode)},toJSON:function(e){const t=[],n=e.tracks,o={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let c=0,h=n.length;c!==h;++c)t.push(KeyframeTrack.toJSON(n[c]));return o},CreateFromMorphTargetSequence:function(e,t,n,o){const c=t.length,h=[];for(let d=0;d<c;d++){let e=[],p=[];e.push((d+c-1)%c,d,(d+1)%c),p.push(0,1,0);const m=uc.getKeyframeOrder(e);e=uc.sortedArray(e,1,m),p=uc.sortedArray(p,1,m),o||0!==e[0]||(e.push(c),p.push(p[0])),h.push(new NumberKeyframeTrack(".morphTargetInfluences["+t[d].name+"]",e,p).scale(1/n))}return new AnimationClip(e,-1,h)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let o=0;o<n.length;o++)if(n[o].name===t)return n[o];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const o={},c=/^([\w-]*?)([\d]+)$/;for(let d=0,p=e.length;d<p;d++){const t=e[d],n=t.name.match(c);if(n&&n.length>1){const e=n[1];let c=o[e];c||(o[e]=c=[]),c.push(t)}}const h=[];for(const d in o)h.push(AnimationClip.CreateFromMorphTargetSequence(d,o[d],t,n));return h},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(e,t,n,o,c){if(0!==n.length){const h=[],d=[];uc.flattenJSON(n,h,d,o),0!==h.length&&c.push(new e(t,h,d))}},n=[],o=e.name||"default",c=e.fps||30,h=e.blendMode;let d=e.length||-1;const p=e.hierarchy||[];for(let g=0;g<p.length;g++){const e=p[g].keys;if(e&&0!==e.length)if(e[0].morphTargets){const t={};let o;for(o=0;o<e.length;o++)if(e[o].morphTargets)for(let n=0;n<e[o].morphTargets.length;n++)t[e[o].morphTargets[n]]=-1;for(const c in t){const t=[],h=[];for(let n=0;n!==e[o].morphTargets.length;++n){const n=e[o];t.push(n.time),h.push(n.morphTarget===c?1:0)}n.push(new NumberKeyframeTrack(".morphTargetInfluence["+c+"]",t,h))}d=t.length*(c||1)}else{const o=".bones["+t[g].name+"]";addNonemptyTrack(VectorKeyframeTrack,o+".position",e,"pos",n),addNonemptyTrack(QuaternionKeyframeTrack,o+".quaternion",e,"rot",n),addNonemptyTrack(VectorKeyframeTrack,o+".scale",e,"scl",n)}}if(0===n.length)return null;const m=new AnimationClip(o,d,n,h);return m}}),Object.assign(AnimationClip.prototype,{resetDuration:function(){const e=this.tracks;let t=0;for(let n=0,o=e.length;n!==o;++n){const e=this.tracks[n];t=Math.max(t,e.times[e.times.length-1])}return this.duration=t,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new AnimationClip(this.name,this.duration,e,this.blendMode)}});const hc={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function LoadingManager(e,t,n){const o=this;let c=!1,h=0,d=0,p=void 0;const m=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){d++,!1===c&&void 0!==o.onStart&&o.onStart(e,h,d),c=!0},this.itemEnd=function(e){h++,void 0!==o.onProgress&&o.onProgress(e,h,d),h===d&&(c=!1,void 0!==o.onLoad&&o.onLoad())},this.itemError=function(e){void 0!==o.onError&&o.onError(e)},this.resolveURL=function(e){return p?p(e):e},this.setURLModifier=function(e){return p=e,this},this.addHandler=function(e,t){return m.push(e,t),this},this.removeHandler=function(e){const t=m.indexOf(e);return-1!==t&&m.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=m.length;t<n;t+=2){const n=m[t],o=m[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return o}return null}}const dc=new LoadingManager;function Loader(e){this.manager=void 0!==e?e:dc,this.crossOrigin="anonymous",this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Loader.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise((function(o,c){n.load(e,o,t,c)}))},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const pc={};function FileLoader(e){Loader.call(this,e)}function AnimationLoader(e){Loader.call(this,e)}function CompressedTextureLoader(e){Loader.call(this,e)}function DataTextureLoader(e){Loader.call(this,e)}function ImageLoader(e){Loader.call(this,e)}function CubeTextureLoader(e){Loader.call(this,e)}function TextureLoader(e){Loader.call(this,e)}function Curve(){this.type="Curve",this.arcLengthDivisions=200}function EllipseCurve(e,t,n,o,c,h,d,p){Curve.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=o||1,this.aStartAngle=c||0,this.aEndAngle=h||2*Math.PI,this.aClockwise=d||!1,this.aRotation=p||0}function ArcCurve(e,t,n,o,c,h){EllipseCurve.call(this,e,t,n,n,o,c,h),this.type="ArcCurve"}function CubicPoly(){let e=0,t=0,n=0,o=0;function init(c,h,d,p){e=c,t=d,n=-3*c+3*h-2*d-p,o=2*c-2*h+d+p}return{initCatmullRom:function(e,t,n,o,c){init(t,n,c*(n-e),c*(o-t))},initNonuniformCatmullRom:function(e,t,n,o,c,h,d){let p=(t-e)/c-(n-e)/(c+h)+(n-t)/h,m=(n-t)/h-(o-t)/(h+d)+(o-n)/d;p*=h,m*=h,init(t,n,p,m)},calc:function(c){const h=c*c,d=h*c;return e+t*c+n*h+o*d}}}FileLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:FileLoader,load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=hc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;if(void 0!==pc[e])return void pc[e].push({onLoad:t,onProgress:n,onError:o});const d=/^data:(.*?)(;base64)?,(.*)$/,p=e.match(d);let m;if(p){const n=p[1],h=!!p[2];let d=p[3];d=decodeURIComponent(d),h&&(d=atob(d));try{let o;const h=(this.responseType||"").toLowerCase();switch(h){case"arraybuffer":case"blob":const e=new Uint8Array(d.length);for(let n=0;n<d.length;n++)e[n]=d.charCodeAt(n);o="blob"===h?new Blob([e.buffer],{type:n}):e.buffer;break;case"document":const t=new DOMParser;o=t.parseFromString(d,n);break;case"json":o=JSON.parse(d);break;default:o=d;break}setTimeout((function(){t&&t(o),c.manager.itemEnd(e)}),0)}catch(g){setTimeout((function(){o&&o(g),c.manager.itemError(e),c.manager.itemEnd(e)}),0)}}else{pc[e]=[],pc[e].push({onLoad:t,onProgress:n,onError:o}),m=new XMLHttpRequest,m.open("GET",e,!0),m.addEventListener("load",(function(t){const n=this.response,o=pc[e];if(delete pc[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),hc.add(e,n);for(let e=0,t=o.length;e<t;e++){const t=o[e];t.onLoad&&t.onLoad(n)}c.manager.itemEnd(e)}else{for(let e=0,n=o.length;e<n;e++){const n=o[e];n.onError&&n.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}}),!1),m.addEventListener("progress",(function(t){const n=pc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onProgress&&o.onProgress(t)}}),!1),m.addEventListener("error",(function(t){const n=pc[e];delete pc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}),!1),m.addEventListener("abort",(function(t){const n=pc[e];delete pc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(m.responseType=this.responseType),void 0!==this.withCredentials&&(m.withCredentials=this.withCredentials),m.overrideMimeType&&m.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeader)m.setRequestHeader(e,this.requestHeader[e]);m.send(null)}return c.manager.itemStart(e),m},setResponseType:function(e){return this.responseType=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setMimeType:function(e){return this.mimeType=e,this}}),AnimationLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:AnimationLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const o=AnimationClip.parse(e[n]);t.push(o)}return t}}),CompressedTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:CompressedTextureLoader,load:function(e,t,n,o){const c=this,h=[],d=new CompressedTexture;d.image=h;const p=new FileLoader(this.manager);p.setPath(this.path),p.setResponseType("arraybuffer");let m=0;function loadTexture(g){p.load(e[g],(function(e){const n=c.parse(e,!0);h[g]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},m+=1,6===m&&(1===n.mipmapCount&&(d.minFilter=Ce),d.format=n.format,d.needsUpdate=!0,t&&t(d))}),n,o)}if(Array.isArray(e))for(let g=0,y=e.length;g<y;++g)loadTexture(g);else p.load(e,(function(e){const n=c.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){h[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)h[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),h[t].format=n.format,h[t].width=n.width,h[t].height=n.height}}else d.image.width=n.width,d.image.height=n.height,d.mipmaps=n.mipmaps;1===n.mipmapCount&&(d.minFilter=Ce),d.format=n.format,d.needsUpdate=!0,t&&t(d)}),n,o);return d}}),DataTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:DataTextureLoader,load:function(e,t,n,o){const c=this,h=new DataTexture,d=new FileLoader(this.manager);return d.setResponseType("arraybuffer"),d.setPath(this.path),d.load(e,(function(e){const n=c.parse(e);n&&(void 0!==n.image?h.image=n.image:void 0!==n.data&&(h.image.width=n.width,h.image.height=n.height,h.image.data=n.data),h.wrapS=void 0!==n.wrapS?n.wrapS:_e,h.wrapT=void 0!==n.wrapT?n.wrapT:_e,h.magFilter=void 0!==n.magFilter?n.magFilter:Ce,h.minFilter=void 0!==n.minFilter?n.minFilter:Ce,h.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.format&&(h.format=n.format),void 0!==n.type&&(h.type=n.type),void 0!==n.mipmaps&&(h.mipmaps=n.mipmaps,h.minFilter=Be),1===n.mipmapCount&&(h.minFilter=Ce),h.needsUpdate=!0,t&&t(h,n))}),n,o),h}}),ImageLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ImageLoader,load:function(e,t,n,o){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=hc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;const d=document.createElementNS("http://www.w3.org/1999/xhtml","img");function onImageLoad(){d.removeEventListener("load",onImageLoad,!1),d.removeEventListener("error",onImageError,!1),hc.add(e,this),t&&t(this),c.manager.itemEnd(e)}function onImageError(t){d.removeEventListener("load",onImageLoad,!1),d.removeEventListener("error",onImageError,!1),o&&o(t),c.manager.itemError(e),c.manager.itemEnd(e)}return d.addEventListener("load",onImageLoad,!1),d.addEventListener("error",onImageError,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(d.crossOrigin=this.crossOrigin),c.manager.itemStart(e),d.src=e,d}}),CubeTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:CubeTextureLoader,load:function(e,t,n,o){const c=new CubeTexture,h=new ImageLoader(this.manager);h.setCrossOrigin(this.crossOrigin),h.setPath(this.path);let d=0;function loadTexture(n){h.load(e[n],(function(e){c.images[n]=e,d++,6===d&&(c.needsUpdate=!0,t&&t(c))}),void 0,o)}for(let p=0;p<e.length;++p)loadTexture(p);return c}}),TextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:TextureLoader,load:function(e,t,n,o){const c=new Texture,h=new ImageLoader(this.manager);return h.setCrossOrigin(this.crossOrigin),h.setPath(this.path),h.load(e,(function(n){c.image=n;const o=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);c.format=o?Xe:Ye,c.needsUpdate=!0,void 0!==t&&t(c)}),n,o),c}}),Object.assign(Curve.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e){void 0===e&&(e=5);const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e){void 0===e&&(e=5);const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,o=this.getPoint(0),c=0;t.push(0);for(let h=1;h<=e;h++)n=this.getPoint(h/e),c+=n.distanceTo(o),t.push(c),o=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let o,c=0,h=n.length;o=t||e*n[h-1];let d,p=0,m=h-1;while(p<=m)if(c=Math.floor(p+(m-p)/2),d=n[c]-o,d<0)p=c+1;else{if(!(d>0)){m=c;break}m=c-1}if(c=m,n[c]===o)return c/(h-1);const g=n[c],y=n[c+1],x=y-g,b=(o-g)/x,M=(c+b)/(h-1);return M},getTangent:function(e,t){const n=1e-4;let o=e-n,c=e+n;o<0&&(o=0),c>1&&(c=1);const h=this.getPoint(o),d=this.getPoint(c),p=t||(h.isVector2?new Vector2:new Vector3);return p.copy(d).sub(h).normalize(),p},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new Vector3,o=[],c=[],h=[],d=new Vector3,p=new Matrix4;for(let b=0;b<=e;b++){const t=b/e;o[b]=this.getTangentAt(t,new Vector3),o[b].normalize()}c[0]=new Vector3,h[0]=new Vector3;let m=Number.MAX_VALUE;const g=Math.abs(o[0].x),y=Math.abs(o[0].y),x=Math.abs(o[0].z);g<=m&&(m=g,n.set(1,0,0)),y<=m&&(m=y,n.set(0,1,0)),x<=m&&n.set(0,0,1),d.crossVectors(o[0],n).normalize(),c[0].crossVectors(o[0],d),h[0].crossVectors(o[0],c[0]);for(let b=1;b<=e;b++){if(c[b]=c[b-1].clone(),h[b]=h[b-1].clone(),d.crossVectors(o[b-1],o[b]),d.length()>Number.EPSILON){d.normalize();const e=Math.acos(Wn.clamp(o[b-1].dot(o[b]),-1,1));c[b].applyMatrix4(p.makeRotationAxis(d,e))}h[b].crossVectors(o[b],c[b])}if(!0===t){let t=Math.acos(Wn.clamp(c[0].dot(c[e]),-1,1));t/=e,o[0].dot(d.crossVectors(c[0],c[e]))>0&&(t=-t);for(let n=1;n<=e;n++)c[n].applyMatrix4(p.makeRotationAxis(o[n],t*n)),h[n].crossVectors(o[n],c[n])}return{tangents:o,normals:c,binormals:h}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),EllipseCurve.prototype=Object.create(Curve.prototype),EllipseCurve.prototype.constructor=EllipseCurve,EllipseCurve.prototype.isEllipseCurve=!0,EllipseCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=2*Math.PI;let c=this.aEndAngle-this.aStartAngle;const h=Math.abs(c)<Number.EPSILON;while(c<0)c+=o;while(c>o)c-=o;c<Number.EPSILON&&(c=h?0:o),!0!==this.aClockwise||h||(c===o?c=-o:c-=o);const d=this.aStartAngle+e*c;let p=this.aX+this.xRadius*Math.cos(d),m=this.aY+this.yRadius*Math.sin(d);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=p-this.aX,o=m-this.aY;p=n*e-o*t+this.aX,m=n*t+o*e+this.aY}return n.set(p,m)},EllipseCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},EllipseCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},EllipseCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},ArcCurve.prototype=Object.create(EllipseCurve.prototype),ArcCurve.prototype.constructor=ArcCurve,ArcCurve.prototype.isArcCurve=!0;const fc=new Vector3,mc=new CubicPoly,gc=new CubicPoly,yc=new CubicPoly;function CatmullRomCurve3(e,t,n,o){Curve.call(this),this.type="CatmullRomCurve3",this.points=e||[],this.closed=t||!1,this.curveType=n||"centripetal",this.tension=o||.5}function CatmullRom(e,t,n,o,c){const h=.5*(o-t),d=.5*(c-n),p=e*e,m=e*p;return(2*n-2*o+h+d)*m+(-3*n+3*o-2*h-d)*p+h*e+n}function QuadraticBezierP0(e,t){const n=1-e;return n*n*t}function QuadraticBezierP1(e,t){return 2*(1-e)*e*t}function QuadraticBezierP2(e,t){return e*e*t}function QuadraticBezier(e,t,n,o){return QuadraticBezierP0(e,t)+QuadraticBezierP1(e,n)+QuadraticBezierP2(e,o)}function CubicBezierP0(e,t){const n=1-e;return n*n*n*t}function CubicBezierP1(e,t){const n=1-e;return 3*n*n*e*t}function CubicBezierP2(e,t){return 3*(1-e)*e*e*t}function CubicBezierP3(e,t){return e*e*e*t}function CubicBezier(e,t,n,o,c){return CubicBezierP0(e,t)+CubicBezierP1(e,n)+CubicBezierP2(e,o)+CubicBezierP3(e,c)}function CubicBezierCurve(e,t,n,o){Curve.call(this),this.type="CubicBezierCurve",this.v0=e||new Vector2,this.v1=t||new Vector2,this.v2=n||new Vector2,this.v3=o||new Vector2}function CubicBezierCurve3(e,t,n,o){Curve.call(this),this.type="CubicBezierCurve3",this.v0=e||new Vector3,this.v1=t||new Vector3,this.v2=n||new Vector3,this.v3=o||new Vector3}function LineCurve(e,t){Curve.call(this),this.type="LineCurve",this.v1=e||new Vector2,this.v2=t||new Vector2}function LineCurve3(e,t){Curve.call(this),this.type="LineCurve3",this.v1=e||new Vector3,this.v2=t||new Vector3}function QuadraticBezierCurve(e,t,n){Curve.call(this),this.type="QuadraticBezierCurve",this.v0=e||new Vector2,this.v1=t||new Vector2,this.v2=n||new Vector2}function QuadraticBezierCurve3(e,t,n){Curve.call(this),this.type="QuadraticBezierCurve3",this.v0=e||new Vector3,this.v1=t||new Vector3,this.v2=n||new Vector3}function SplineCurve(e){Curve.call(this),this.type="SplineCurve",this.points=e||[]}CatmullRomCurve3.prototype=Object.create(Curve.prototype),CatmullRomCurve3.prototype.constructor=CatmullRomCurve3,CatmullRomCurve3.prototype.isCatmullRomCurve3=!0,CatmullRomCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.points,c=o.length,h=(c-(this.closed?0:1))*e;let d,p,m,g,y=Math.floor(h),x=h-y;if(this.closed?y+=y>0?0:(Math.floor(Math.abs(y)/c)+1)*c:0===x&&y===c-1&&(y=c-2,x=1),this.closed||y>0?d=o[(y-1)%c]:(fc.subVectors(o[0],o[1]).add(o[0]),d=fc),p=o[y%c],m=o[(y+1)%c],this.closed||y+2<c?g=o[(y+2)%c]:(fc.subVectors(o[c-1],o[c-2]).add(o[c-1]),g=fc),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(d.distanceToSquared(p),e),n=Math.pow(p.distanceToSquared(m),e),o=Math.pow(m.distanceToSquared(g),e);n<1e-4&&(n=1),t<1e-4&&(t=n),o<1e-4&&(o=n),mc.initNonuniformCatmullRom(d.x,p.x,m.x,g.x,t,n,o),gc.initNonuniformCatmullRom(d.y,p.y,m.y,g.y,t,n,o),yc.initNonuniformCatmullRom(d.z,p.z,m.z,g.z,t,n,o)}else"catmullrom"===this.curveType&&(mc.initCatmullRom(d.x,p.x,m.x,g.x,this.tension),gc.initCatmullRom(d.y,p.y,m.y,g.y,this.tension),yc.initCatmullRom(d.z,p.z,m.z,g.z,this.tension));return n.set(mc.calc(x),gc.calc(x),yc.calc(x)),n},CatmullRomCurve3.prototype.copy=function(e){Curve.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},CatmullRomCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},CatmullRomCurve3.prototype.fromJSON=function(e){Curve.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector3).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},CubicBezierCurve.prototype=Object.create(Curve.prototype),CubicBezierCurve.prototype.constructor=CubicBezierCurve,CubicBezierCurve.prototype.isCubicBezierCurve=!0,CubicBezierCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.v0,c=this.v1,h=this.v2,d=this.v3;return n.set(CubicBezier(e,o.x,c.x,h.x,d.x),CubicBezier(e,o.y,c.y,h.y,d.y)),n},CubicBezierCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},CubicBezierCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},CubicBezierCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},CubicBezierCurve3.prototype=Object.create(Curve.prototype),CubicBezierCurve3.prototype.constructor=CubicBezierCurve3,CubicBezierCurve3.prototype.isCubicBezierCurve3=!0,CubicBezierCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.v0,c=this.v1,h=this.v2,d=this.v3;return n.set(CubicBezier(e,o.x,c.x,h.x,d.x),CubicBezier(e,o.y,c.y,h.y,d.y),CubicBezier(e,o.z,c.z,h.z,d.z)),n},CubicBezierCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},CubicBezierCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},CubicBezierCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},LineCurve.prototype=Object.create(Curve.prototype),LineCurve.prototype.constructor=LineCurve,LineCurve.prototype.isLineCurve=!0,LineCurve.prototype.getPoint=function(e,t){const n=t||new Vector2;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},LineCurve.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},LineCurve.prototype.getTangent=function(e,t){const n=t||new Vector2;return n.copy(this.v2).sub(this.v1).normalize(),n},LineCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},LineCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},LineCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},LineCurve3.prototype=Object.create(Curve.prototype),LineCurve3.prototype.constructor=LineCurve3,LineCurve3.prototype.isLineCurve3=!0,LineCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},LineCurve3.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},LineCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},LineCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},LineCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},QuadraticBezierCurve.prototype=Object.create(Curve.prototype),QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve,QuadraticBezierCurve.prototype.isQuadraticBezierCurve=!0,QuadraticBezierCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.v0,c=this.v1,h=this.v2;return n.set(QuadraticBezier(e,o.x,c.x,h.x),QuadraticBezier(e,o.y,c.y,h.y)),n},QuadraticBezierCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},QuadraticBezierCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},QuadraticBezierCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},QuadraticBezierCurve3.prototype=Object.create(Curve.prototype),QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3,QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=!0,QuadraticBezierCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.v0,c=this.v1,h=this.v2;return n.set(QuadraticBezier(e,o.x,c.x,h.x),QuadraticBezier(e,o.y,c.y,h.y),QuadraticBezier(e,o.z,c.z,h.z)),n},QuadraticBezierCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},QuadraticBezierCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},QuadraticBezierCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},SplineCurve.prototype=Object.create(Curve.prototype),SplineCurve.prototype.constructor=SplineCurve,SplineCurve.prototype.isSplineCurve=!0,SplineCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.points,c=(o.length-1)*e,h=Math.floor(c),d=c-h,p=o[0===h?h:h-1],m=o[h],g=o[h>o.length-2?o.length-1:h+1],y=o[h>o.length-3?o.length-1:h+2];return n.set(CatmullRom(d,p.x,m.x,g.x,y.x),CatmullRom(d,p.y,m.y,g.y,y.y)),n},SplineCurve.prototype.copy=function(e){Curve.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this},SplineCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e},SplineCurve.prototype.fromJSON=function(e){Curve.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector2).fromArray(n))}return this};var vc=Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});function CurvePath(){Curve.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Path(e){CurvePath.call(this),this.type="Path",this.currentPoint=new Vector2,e&&this.setFromPoints(e)}function Shape(e){Path.call(this,e),this.uuid=Wn.generateUUID(),this.type="Shape",this.holes=[]}function Light(e,t){Object3D.call(this),this.type="Light",this.color=new Color(e),this.intensity=void 0!==t?t:1,this.receiveShadow=void 0}function HemisphereLight(e,t,n){Light.call(this,e,n),this.type="HemisphereLight",this.castShadow=void 0,this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.groundColor=new Color(t)}function LightShadow(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,.5,500))}function SpotLight(e,t,n,o,c,h){Light.call(this,e,t),this.type="SpotLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(e){this.intensity=e/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==o?o:Math.PI/3,this.penumbra=void 0!==c?c:0,this.decay=void 0!==h?h:1,this.shadow=new SpotLightShadow}function PointLightShadow(){LightShadow.call(this,new PerspectiveCamera(90,1,.5,500)),this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}function PointLight(e,t,n,o){Light.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(e){this.intensity=e/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==o?o:1,this.shadow=new PointLightShadow}function OrthographicCamera(e,t,n,o,c,h){Camera.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=void 0!==e?e:-1,this.right=void 0!==t?t:1,this.top=void 0!==n?n:1,this.bottom=void 0!==o?o:-1,this.near=void 0!==c?c:.1,this.far=void 0!==h?h:2e3,this.updateProjectionMatrix()}function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,.5,500))}function DirectionalLight(e,t){Light.call(this,e,t),this.type="DirectionalLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}function AmbientLight(e,t){Light.call(this,e,t),this.type="AmbientLight",this.castShadow=void 0}function RectAreaLight(e,t,n,o){Light.call(this,e,t),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==o?o:10}function SphericalHarmonics3(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Vector3)}function LightProbe(e,t){Light.call(this,void 0,t),this.type="LightProbe",this.sh=void 0!==e?e:new SphericalHarmonics3}function MaterialLoader(e){Loader.call(this,e),this.textures={}}CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new LineCurve(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let o=0;while(o<n.length){if(n[o]>=t){const e=n[o]-t,c=this.curves[o],h=c.getLength(),d=0===h?0:1-e/h;return c.getPointAt(d)}o++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,o=this.curves.length;n<o;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e){void 0===e&&(e=40);const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e){e=e||12;const t=[];let n;for(let o=0,c=this.curves;o<c.length;o++){const h=c[o],d=h&&h.isEllipseCurve?2*e:h&&(h.isLineCurve||h.isLineCurve3)?1:h&&h.isSplineCurve?e*h.points.length:e,p=h.getPoints(d);for(let e=0;e<p.length;e++){const o=p[e];n&&n.equals(o)||(t.push(o),n=o)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){Curve.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=Curve.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e},fromJSON:function(e){Curve.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new vc[n.type]).fromJSON(n))}return this}}),Path.prototype=Object.assign(Object.create(CurvePath.prototype),{constructor:Path,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new LineCurve(this.currentPoint.clone(),new Vector2(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,o){const c=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,o));return this.curves.push(c),this.currentPoint.set(n,o),this},bezierCurveTo:function(e,t,n,o,c,h){const d=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,o),new Vector2(c,h));return this.curves.push(d),this.currentPoint.set(c,h),this},splineThru:function(e){const t=[this.currentPoint.clone()].concat(e),n=new SplineCurve(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,o,c,h){const d=this.currentPoint.x,p=this.currentPoint.y;return this.absarc(e+d,t+p,n,o,c,h),this},absarc:function(e,t,n,o,c,h){return this.absellipse(e,t,n,n,o,c,h),this},ellipse:function(e,t,n,o,c,h,d,p){const m=this.currentPoint.x,g=this.currentPoint.y;return this.absellipse(e+m,t+g,n,o,c,h,d,p),this},absellipse:function(e,t,n,o,c,h,d,p){const m=new EllipseCurve(e,t,n,o,c,h,d,p);if(this.curves.length>0){const e=m.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(m);const g=m.getPoint(1);return this.currentPoint.copy(g),this},copy:function(e){return CurvePath.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=CurvePath.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return CurvePath.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),Shape.prototype=Object.assign(Object.create(Path.prototype),{constructor:Shape,getPointsHoles:function(e){const t=[];for(let n=0,o=this.holes.length;n<o;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){Path.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this},toJSON:function(){const e=Path.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e},fromJSON:function(e){Path.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new Path).fromJSON(n))}return this}}),Light.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Light,isLight:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}),HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(LightShadow.prototype,{_projScreenMatrix:new Matrix4,_lightPositionWorld:new Vector3,_lookTarget:new Vector3,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,o=this._projScreenMatrix,c=this._lookTarget,h=this._lightPositionWorld;h.setFromMatrixPosition(e.matrixWorld),t.position.copy(h),c.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(c),t.updateMatrixWorld(),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=2*Wn.RAD2DEG*e.angle,o=this.mapSize.width/this.mapSize.height,c=e.distance||t.far;n===t.fov&&o===t.aspect&&c===t.far||(t.fov=n,t.aspect=o,t.far=c,t.updateProjectionMatrix()),LightShadow.prototype.updateMatrices.call(this,e)}}),SpotLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:SpotLight,isSpotLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),PointLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:PointLightShadow,isPointLightShadow:!0,updateMatrices:function(e,t){void 0===t&&(t=0);const n=this.camera,o=this.matrix,c=this._lightPositionWorld,h=this._lookTarget,d=this._projScreenMatrix;c.setFromMatrixPosition(e.matrixWorld),n.position.copy(c),h.copy(n.position),h.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(h),n.updateMatrixWorld(),o.makeTranslation(-c.x,-c.y,-c.z),d.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(d)}}),PointLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:PointLight,isPointLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:!0,copy:function(e,t){return Camera.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,o,c,h){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,o=(this.top+this.bottom)/2;let c=n-e,h=n+e,d=o+t,p=o-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;c+=e*this.view.offsetX,h=c+e*this.view.width,d-=t*this.view.offsetY,p=d-t*this.view.height}this.projectionMatrix.makeOrthographic(c,h,d,p,this.near,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}),DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow,isDirectionalLightShadow:!0,updateMatrices:function(e){LightShadow.prototype.updateMatrices.call(this,e)}}),DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:AmbientLight,isAmbientLight:!0}),RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=Light.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}}),Object.assign(SphericalHarmonics3.prototype,{isSphericalHarmonics3:!0,set:function(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this},zero:function(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this},getAt:function(e,t){const n=e.x,o=e.y,c=e.z,h=this.coefficients;return t.copy(h[0]).multiplyScalar(.282095),t.addScaledVector(h[1],.488603*o),t.addScaledVector(h[2],.488603*c),t.addScaledVector(h[3],.488603*n),t.addScaledVector(h[4],n*o*1.092548),t.addScaledVector(h[5],o*c*1.092548),t.addScaledVector(h[6],.315392*(3*c*c-1)),t.addScaledVector(h[7],n*c*1.092548),t.addScaledVector(h[8],.546274*(n*n-o*o)),t},getIrradianceAt:function(e,t){const n=e.x,o=e.y,c=e.z,h=this.coefficients;return t.copy(h[0]).multiplyScalar(.886227),t.addScaledVector(h[1],1.023328*o),t.addScaledVector(h[2],1.023328*c),t.addScaledVector(h[3],1.023328*n),t.addScaledVector(h[4],.858086*n*o),t.addScaledVector(h[5],.858086*o*c),t.addScaledVector(h[6],.743125*c*c-.247708),t.addScaledVector(h[7],.858086*n*c),t.addScaledVector(h[8],.429043*(n*n-o*o)),t},add:function(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this},addScaledSH:function(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this},scale:function(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this},lerp:function(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this},equals:function(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0},copy:function(e){return this.set(e.coefficients)},clone:function(){return(new this.constructor).copy(this)},fromArray:function(e,t){void 0===t&&(t=0);const n=this.coefficients;for(let o=0;o<9;o++)n[o].fromArray(e,t+3*o);return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.coefficients;for(let o=0;o<9;o++)n[o].toArray(e,t+3*o);return e}}),Object.assign(SphericalHarmonics3,{getBasisAt:function(e,t){const n=e.x,o=e.y,c=e.z;t[0]=.282095,t[1]=.488603*o,t[2]=.488603*c,t[3]=.488603*n,t[4]=1.092548*n*o,t[5]=1.092548*o*c,t[6]=.315392*(3*c*c-1),t[7]=1.092548*n*c,t[8]=.546274*(n*n-o*o)}}),LightProbe.prototype=Object.assign(Object.create(Light.prototype),{constructor:LightProbe,isLightProbe:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=Light.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),MaterialLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:MaterialLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t=this.textures;function getTexture(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const n=new lc[e.type];if(void 0!==e.uuid&&(n.uuid=e.uuid),void 0!==e.name&&(n.name=e.name),void 0!==e.color&&n.color.setHex(e.color),void 0!==e.roughness&&(n.roughness=e.roughness),void 0!==e.metalness&&(n.metalness=e.metalness),void 0!==e.sheen&&(n.sheen=(new Color).setHex(e.sheen)),void 0!==e.emissive&&n.emissive.setHex(e.emissive),void 0!==e.specular&&n.specular.setHex(e.specular),void 0!==e.shininess&&(n.shininess=e.shininess),void 0!==e.clearcoat&&(n.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(n.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(n.fog=e.fog),void 0!==e.flatShading&&(n.flatShading=e.flatShading),void 0!==e.blending&&(n.blending=e.blending),void 0!==e.combine&&(n.combine=e.combine),void 0!==e.side&&(n.side=e.side),void 0!==e.opacity&&(n.opacity=e.opacity),void 0!==e.transparent&&(n.transparent=e.transparent),void 0!==e.alphaTest&&(n.alphaTest=e.alphaTest),void 0!==e.depthTest&&(n.depthTest=e.depthTest),void 0!==e.depthWrite&&(n.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(n.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(n.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(n.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(n.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(n.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(n.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(n.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(n.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(n.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(n.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(n.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(n.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(n.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(n.rotation=e.rotation),1!==e.linewidth&&(n.linewidth=e.linewidth),void 0!==e.dashSize&&(n.dashSize=e.dashSize),void 0!==e.gapSize&&(n.gapSize=e.gapSize),void 0!==e.scale&&(n.scale=e.scale),void 0!==e.polygonOffset&&(n.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(n.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(n.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(n.skinning=e.skinning),void 0!==e.morphTargets&&(n.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(n.morphNormals=e.morphNormals),void 0!==e.dithering&&(n.dithering=e.dithering),void 0!==e.vertexTangents&&(n.vertexTangents=e.vertexTangents),void 0!==e.visible&&(n.visible=e.visible),void 0!==e.toneMapped&&(n.toneMapped=e.toneMapped),void 0!==e.userData&&(n.userData=e.userData),void 0!==e.vertexColors&&("number"===typeof e.vertexColors?n.vertexColors=e.vertexColors>0:n.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const o in e.uniforms){const t=e.uniforms[o];switch(n.uniforms[o]={},t.type){case"t":n.uniforms[o].value=getTexture(t.value);break;case"c":n.uniforms[o].value=(new Color).setHex(t.value);break;case"v2":n.uniforms[o].value=(new Vector2).fromArray(t.value);break;case"v3":n.uniforms[o].value=(new Vector3).fromArray(t.value);break;case"v4":n.uniforms[o].value=(new Vector4).fromArray(t.value);break;case"m3":n.uniforms[o].value=(new Matrix3).fromArray(t.value);case"m4":n.uniforms[o].value=(new Matrix4).fromArray(t.value);break;default:n.uniforms[o].value=t.value}}if(void 0!==e.defines&&(n.defines=e.defines),void 0!==e.vertexShader&&(n.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(n.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const o in e.extensions)n.extensions[o]=e.extensions[o];if(void 0!==e.shading&&(n.flatShading=1===e.shading),void 0!==e.size&&(n.size=e.size),void 0!==e.sizeAttenuation&&(n.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(n.map=getTexture(e.map)),void 0!==e.matcap&&(n.matcap=getTexture(e.matcap)),void 0!==e.alphaMap&&(n.alphaMap=getTexture(e.alphaMap)),void 0!==e.bumpMap&&(n.bumpMap=getTexture(e.bumpMap)),void 0!==e.bumpScale&&(n.bumpScale=e.bumpScale),void 0!==e.normalMap&&(n.normalMap=getTexture(e.normalMap)),void 0!==e.normalMapType&&(n.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),n.normalScale=(new Vector2).fromArray(t)}return void 0!==e.displacementMap&&(n.displacementMap=getTexture(e.displacementMap)),void 0!==e.displacementScale&&(n.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(n.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(n.roughnessMap=getTexture(e.roughnessMap)),void 0!==e.metalnessMap&&(n.metalnessMap=getTexture(e.metalnessMap)),void 0!==e.emissiveMap&&(n.emissiveMap=getTexture(e.emissiveMap)),void 0!==e.emissiveIntensity&&(n.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(n.specularMap=getTexture(e.specularMap)),void 0!==e.envMap&&(n.envMap=getTexture(e.envMap)),void 0!==e.envMapIntensity&&(n.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(n.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(n.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(n.lightMap=getTexture(e.lightMap)),void 0!==e.lightMapIntensity&&(n.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(n.aoMap=getTexture(e.aoMap)),void 0!==e.aoMapIntensity&&(n.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(n.gradientMap=getTexture(e.gradientMap)),void 0!==e.clearcoatMap&&(n.clearcoatMap=getTexture(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=getTexture(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(n.clearcoatNormalMap=getTexture(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(n.clearcoatNormalScale=(new Vector2).fromArray(e.clearcoatNormalScale)),n},setTextures:function(e){return this.textures=e,this}});const xc={decodeText:function(e){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let o=0,c=e.length;o<c;o++)t+=String.fromCharCode(e[o]);try{return decodeURIComponent(escape(t))}catch(n){return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}};function InstancedBufferGeometry(){BufferGeometry.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function InstancedBufferAttribute(e,t,n,o){"number"===typeof n&&(o=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),BufferAttribute.call(this,e,t,n),this.meshPerAttribute=o||1}function BufferGeometryLoader(e){Loader.call(this,e)}InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:!0,copy:function(e){return BufferGeometry.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e=BufferGeometry.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:!0,copy:function(e){return BufferAttribute.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=BufferAttribute.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),BufferGeometryLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:BufferGeometryLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t={},n={};function getInterleavedBuffer(e,n){if(void 0!==t[n])return t[n];const o=e.interleavedBuffers,c=o[n],h=getArrayBuffer(e,c.buffer),d=new bc[c.type](h),p=new InterleavedBuffer(d,c.stride);return p.uuid=c.uuid,t[n]=p,p}function getArrayBuffer(e,t){if(void 0!==n[t])return n[t];const o=e.arrayBuffers,c=o[t],h=new Uint32Array(c).buffer;return n[t]=h,h}const o=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,c=e.data.index;if(void 0!==c){const e=new bc[c.type](c.array);o.setIndex(new BufferAttribute(e,1))}const h=e.data.attributes;for(const y in h){const t=h[y];let n;if(t.isInterleavedBufferAttribute){const o=getInterleavedBuffer(e.data,t.data);n=new InterleavedBufferAttribute(o,t.itemSize,t.offset,t.normalized)}else{const e=new bc[t.type](t.array),o=t.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;n=new o(e,t.itemSize,t.normalized)}void 0!==t.name&&(n.name=t.name),o.setAttribute(y,n)}const d=e.data.morphAttributes;if(d)for(const y in d){const t=d[y],n=[];for(let o=0,c=t.length;o<c;o++){const c=t[o];let h;if(c.isInterleavedBufferAttribute){const t=getInterleavedBuffer(e.data,c.data);h=new InterleavedBufferAttribute(t,c.itemSize,c.offset,c.normalized)}else{const e=new bc[c.type](c.array);h=new BufferAttribute(e,c.itemSize,c.normalized)}void 0!==c.name&&(h.name=c.name),n.push(h)}o.morphAttributes[y]=n}const p=e.data.morphTargetsRelative;p&&(o.morphTargetsRelative=!0);const m=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==m)for(let y=0,x=m.length;y!==x;++y){const e=m[y];o.addGroup(e.start,e.count,e.materialIndex)}const g=e.data.boundingSphere;if(void 0!==g){const e=new Vector3;void 0!==g.center&&e.fromArray(g.center),o.boundingSphere=new Sphere(e,g.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}});const bc={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!==typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function ObjectLoader(e){Loader.call(this,e)}ObjectLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ObjectLoader,load:function(e,t,n,o){const c=this,h=""===this.path?xc.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||h;const d=new FileLoader(c.manager);d.setPath(this.path),d.load(e,(function(n){let h=null;try{h=JSON.parse(n)}catch(p){return void 0!==o&&o(p),void console.error("THREE:ObjectLoader: Can't parse "+e+".",p.message)}const d=h.metadata;void 0!==d&&void 0!==d.type&&"geometry"!==d.type.toLowerCase()?c.parse(h,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,o)},parse:function(e,t){const n=this.parseShape(e.shapes),o=this.parseGeometries(e.geometries,n),c=this.parseImages(e.images,(function(){void 0!==t&&t(p)})),h=this.parseTextures(e.textures,c),d=this.parseMaterials(e.materials,h),p=this.parseObject(e.object,o,d);return e.animations&&(p.animations=this.parseAnimations(e.animations)),void 0!==e.images&&0!==e.images.length||void 0!==t&&t(p),p},parseShape:function(e){const t={};if(void 0!==e)for(let n=0,o=e.length;n<o;n++){const o=(new Shape).fromJSON(e[n]);t[o.uuid]=o}return t},parseGeometries:function(e,t){const n={};let o;if(void 0!==e){const c=new BufferGeometryLoader;for(let h=0,d=e.length;h<d;h++){let d;const p=e[h];switch(p.type){case"PlaneGeometry":case"PlaneBufferGeometry":d=new cc[p.type](p.width,p.height,p.widthSegments,p.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":d=new cc[p.type](p.width,p.height,p.depth,p.widthSegments,p.heightSegments,p.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":d=new cc[p.type](p.radius,p.segments,p.thetaStart,p.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":d=new cc[p.type](p.radiusTop,p.radiusBottom,p.height,p.radialSegments,p.heightSegments,p.openEnded,p.thetaStart,p.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":d=new cc[p.type](p.radius,p.height,p.radialSegments,p.heightSegments,p.openEnded,p.thetaStart,p.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":d=new cc[p.type](p.radius,p.widthSegments,p.heightSegments,p.phiStart,p.phiLength,p.thetaStart,p.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":d=new cc[p.type](p.radius,p.detail);break;case"RingGeometry":case"RingBufferGeometry":d=new cc[p.type](p.innerRadius,p.outerRadius,p.thetaSegments,p.phiSegments,p.thetaStart,p.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":d=new cc[p.type](p.radius,p.tube,p.radialSegments,p.tubularSegments,p.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":d=new cc[p.type](p.radius,p.tube,p.tubularSegments,p.radialSegments,p.p,p.q);break;case"TubeGeometry":case"TubeBufferGeometry":d=new cc[p.type]((new vc[p.path.type]).fromJSON(p.path),p.tubularSegments,p.radius,p.radialSegments,p.closed);break;case"LatheGeometry":case"LatheBufferGeometry":d=new cc[p.type](p.points,p.segments,p.phiStart,p.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":d=new cc[p.type](p.vertices,p.indices,p.radius,p.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":o=[];for(let n=0,c=p.shapes.length;n<c;n++){const e=t[p.shapes[n]];o.push(e)}d=new cc[p.type](o,p.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":o=[];for(let n=0,c=p.shapes.length;n<c;n++){const e=t[p.shapes[n]];o.push(e)}const e=p.options.extrudePath;void 0!==e&&(p.options.extrudePath=(new vc[e.type]).fromJSON(e)),d=new cc[p.type](o,p.options);break;case"BufferGeometry":case"InstancedBufferGeometry":d=c.parse(p);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+p.type+'"');continue}d.uuid=p.uuid,void 0!==p.name&&(d.name=p.name),!0===d.isBufferGeometry&&void 0!==p.userData&&(d.userData=p.userData),n[p.uuid]=d}}return n},parseMaterials:function(e,t){const n={},o={};if(void 0!==e){const c=new MaterialLoader;c.setTextures(t);for(let t=0,h=e.length;t<h;t++){const h=e[t];if("MultiMaterial"===h.type){const e=[];for(let t=0;t<h.materials.length;t++){const o=h.materials[t];void 0===n[o.uuid]&&(n[o.uuid]=c.parse(o)),e.push(n[o.uuid])}o[h.uuid]=e}else void 0===n[h.uuid]&&(n[h.uuid]=c.parse(h)),o[h.uuid]=n[h.uuid]}}return o},parseAnimations:function(e){const t=[];for(let n=0;n<e.length;n++){const o=e[n],c=AnimationClip.parse(o);void 0!==o.uuid&&(c.uuid=o.uuid),t.push(c)}return t},parseImages:function(e,t){const n=this,o={};let c;function loadImage(e){return n.manager.itemStart(e),c.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}if(void 0!==e&&e.length>0){const h=new LoadingManager(t);c=new ImageLoader(h),c.setCrossOrigin(this.crossOrigin);for(let t=0,c=e.length;t<c;t++){const c=e[t],h=c.url;if(Array.isArray(h)){o[c.uuid]=[];for(let e=0,t=h.length;e<t;e++){const t=h[e],d=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t;o[c.uuid].push(loadImage(d))}}else{const e=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)?c.url:n.resourcePath+c.url;o[c.uuid]=loadImage(e)}}}return o},parseTextures:function(e,t){function parseConstant(e,t){return"number"===typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const n={};if(void 0!==e)for(let o=0,c=e.length;o<c;o++){const c=e[o];let h;void 0===c.image&&console.warn('THREE.ObjectLoader: No "image" specified for',c.uuid),void 0===t[c.image]&&console.warn("THREE.ObjectLoader: Undefined image",c.image),h=Array.isArray(t[c.image])?new CubeTexture(t[c.image]):new Texture(t[c.image]),h.needsUpdate=!0,h.uuid=c.uuid,void 0!==c.name&&(h.name=c.name),void 0!==c.mapping&&(h.mapping=parseConstant(c.mapping,Mc)),void 0!==c.offset&&h.offset.fromArray(c.offset),void 0!==c.repeat&&h.repeat.fromArray(c.repeat),void 0!==c.center&&h.center.fromArray(c.center),void 0!==c.rotation&&(h.rotation=c.rotation),void 0!==c.wrap&&(h.wrapS=parseConstant(c.wrap[0],_c),h.wrapT=parseConstant(c.wrap[1],_c)),void 0!==c.format&&(h.format=c.format),void 0!==c.type&&(h.type=c.type),void 0!==c.encoding&&(h.encoding=c.encoding),void 0!==c.minFilter&&(h.minFilter=parseConstant(c.minFilter,wc)),void 0!==c.magFilter&&(h.magFilter=parseConstant(c.magFilter,wc)),void 0!==c.anisotropy&&(h.anisotropy=c.anisotropy),void 0!==c.flipY&&(h.flipY=c.flipY),void 0!==c.premultiplyAlpha&&(h.premultiplyAlpha=c.premultiplyAlpha),void 0!==c.unpackAlignment&&(h.unpackAlignment=c.unpackAlignment),n[c.uuid]=h}return n},parseObject:function(e,t,n){let o,c,h;function getGeometry(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function getMaterial(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let o=0,c=e.length;o<c;o++){const c=e[o];void 0===n[c]&&console.warn("THREE.ObjectLoader: Undefined material",c),t.push(n[c])}return t}return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),n[e]}}switch(e.type){case"Scene":o=new Scene,void 0!==e.background&&Number.isInteger(e.background)&&(o.background=new Color(e.background)),void 0!==e.fog&&("Fog"===e.fog.type?o.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(o.fog=new FogExp2(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":o=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(o.focus=e.focus),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.filmGauge&&(o.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(o.filmOffset=e.filmOffset),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":o=new DirectionalLight(e.color,e.intensity);break;case"PointLight":o=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=(new LightProbe).fromJSON(e);break;case"SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case"Mesh":c=getGeometry(e.geometry),h=getMaterial(e.material),o=new Mesh(c,h);break;case"InstancedMesh":c=getGeometry(e.geometry),h=getMaterial(e.material);const t=e.count,n=e.instanceMatrix;o=new InstancedMesh(c,h,t),o.instanceMatrix=new BufferAttribute(new Float32Array(n.array),16);break;case"LOD":o=new LOD;break;case"Line":o=new Line(getGeometry(e.geometry),getMaterial(e.material),e.mode);break;case"LineLoop":o=new LineLoop(getGeometry(e.geometry),getMaterial(e.material));break;case"LineSegments":o=new LineSegments(getGeometry(e.geometry),getMaterial(e.material));break;case"PointCloud":case"Points":o=new Points(getGeometry(e.geometry),getMaterial(e.material));break;case"Sprite":o=new Sprite(getMaterial(e.material));break;case"Group":o=new Group;break;default:o=new Object3D}if(o.uuid=e.uuid,void 0!==e.name&&(o.name=e.name),void 0!==e.matrix?(o.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(void 0!==e.position&&o.position.fromArray(e.position),void 0!==e.rotation&&o.rotation.fromArray(e.rotation),void 0!==e.quaternion&&o.quaternion.fromArray(e.quaternion),void 0!==e.scale&&o.scale.fromArray(e.scale)),void 0!==e.castShadow&&(o.castShadow=e.castShadow),void 0!==e.receiveShadow&&(o.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(o.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(o.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(o.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&o.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(o.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(o.visible=e.visible),void 0!==e.frustumCulled&&(o.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(o.renderOrder=e.renderOrder),void 0!==e.userData&&(o.userData=e.userData),void 0!==e.layers&&(o.layers.mask=e.layers),void 0!==e.children){const c=e.children;for(let e=0;e<c.length;e++)o.add(this.parseObject(c[e],t,n))}if("LOD"===e.type){void 0!==e.autoUpdate&&(o.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e],c=o.getObjectByProperty("uuid",n.object);void 0!==c&&o.addLevel(c,n.distance)}}return o}});const Mc={UVMapping:fe,CubeReflectionMapping:me,CubeRefractionMapping:ge,EquirectangularReflectionMapping:ye,EquirectangularRefractionMapping:ve,CubeUVReflectionMapping:xe,CubeUVRefractionMapping:be},_c={RepeatWrapping:Me,ClampToEdgeWrapping:_e,MirroredRepeatWrapping:we},wc={NearestFilter:Se,NearestMipmapNearestFilter:Te,NearestMipmapLinearFilter:Le,LinearFilter:Ce,LinearMipmapNearestFilter:Pe,LinearMipmapLinearFilter:Be};function ImageBitmapLoader(e){"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Loader.call(this,e),this.options={premultiplyAlpha:"none"}}function ShapePath(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}function Font(e){this.type="Font",this.data=e}function createPaths(e,t,n){const o=Array.from?Array.from(e):String(e).split(""),c=t/n.resolution,h=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*c,d=[];let p=0,m=0;for(let g=0;g<o.length;g++){const e=o[g];if("\n"===e)p=0,m-=h;else{const t=createPath(e,c,p,m,n);p+=t.offsetX,d.push(t.path)}}return d}function createPath(e,t,n,o,c){const h=c.glyphs[e]||c.glyphs["?"];if(!h)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+c.familyName+".");const d=new ShapePath;let p,m,g,y,x,b,M,_;if(h.o){const e=h._cachedOutline||(h._cachedOutline=h.o.split(" "));for(let c=0,h=e.length;c<h;){const h=e[c++];switch(h){case"m":p=e[c++]*t+n,m=e[c++]*t+o,d.moveTo(p,m);break;case"l":p=e[c++]*t+n,m=e[c++]*t+o,d.lineTo(p,m);break;case"q":g=e[c++]*t+n,y=e[c++]*t+o,x=e[c++]*t+n,b=e[c++]*t+o,d.quadraticCurveTo(x,b,g,y);break;case"b":g=e[c++]*t+n,y=e[c++]*t+o,x=e[c++]*t+n,b=e[c++]*t+o,M=e[c++]*t+n,_=e[c++]*t+o,d.bezierCurveTo(x,b,M,_,g,y);break}}}return{offsetX:h.ha*t,path:d}}function FontLoader(e){Loader.call(this,e)}let Sc;ImageBitmapLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ImageBitmapLoader,isImageBitmapLoader:!0,setOptions:function setOptions(e){return this.options=e,this},load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=hc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;fetch(e).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,c.options)})).then((function(n){hc.add(e,n),t&&t(n),c.manager.itemEnd(e)})).catch((function(t){o&&o(t),c.manager.itemError(e),c.manager.itemEnd(e)})),c.manager.itemStart(e)}}),Object.assign(ShapePath.prototype,{moveTo:function(e,t){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,o){return this.currentPath.quadraticCurveTo(e,t,n,o),this},bezierCurveTo:function(e,t,n,o,c,h){return this.currentPath.bezierCurveTo(e,t,n,o,c,h),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function toShapesNoHoles(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n],c=new Shape;c.curves=o.curves,t.push(c)}return t}function isPointInsidePolygon(e,t){const n=t.length;let o=!1;for(let c=n-1,h=0;h<n;c=h++){let n=t[c],d=t[h],p=d.x-n.x,m=d.y-n.y;if(Math.abs(m)>Number.EPSILON){if(m<0&&(n=t[h],p=-p,d=t[c],m=-m),e.y<n.y||e.y>d.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=m*(e.x-n.x)-p*(e.y-n.y);if(0===t)return!0;if(t<0)continue;o=!o}}else{if(e.y!==n.y)continue;if(d.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=d.x)return!0}}return o}const n=ac.isClockWise,o=this.subPaths;if(0===o.length)return[];if(!0===t)return toShapesNoHoles(o);let c,h,d,p=[];if(1===o.length)return h=o[0],d=new Shape,d.curves=h.curves,p.push(d),p;let m=!n(o[0].getPoints());m=e?!m:m;const g=[],y=[];let x,b,M=[],_=0;y[_]=void 0,M[_]=[];for(let w=0,S=o.length;w<S;w++)h=o[w],x=h.getPoints(),c=n(x),c=e?!c:c,c?(!m&&y[_]&&_++,y[_]={s:new Shape,p:x},y[_].s.curves=h.curves,m&&_++,M[_]=[]):M[_].push({h:h,p:x[0]});if(!y[0])return toShapesNoHoles(o);if(y.length>1){let e=!1;const t=[];for(let n=0,o=y.length;n<o;n++)g[n]=[];for(let n=0,o=y.length;n<o;n++){const o=M[n];for(let c=0;c<o.length;c++){const h=o[c];let d=!0;for(let o=0;o<y.length;o++)isPointInsidePolygon(h.p,y[o].p)&&(n!==o&&t.push({froms:n,tos:o,hole:c}),d?(d=!1,g[o].push(h)):e=!0);d&&g[n].push(h)}}t.length>0&&(e||(M=g))}for(let w=0,S=y.length;w<S;w++){d=y[w].s,p.push(d),b=M[w];for(let e=0,t=b.length;e<t;e++)d.holes.push(b[e].h)}return p}}),Object.assign(Font.prototype,{isFont:!0,generateShapes:function(e,t){void 0===t&&(t=100);const n=[],o=createPaths(e,t,this.data);for(let c=0,h=o.length;c<h;c++)Array.prototype.push.apply(n,o[c].toShapes());return n}}),FontLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:FontLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(this.manager);h.setPath(this.path),h.load(e,(function(e){let n;try{n=JSON.parse(e)}catch(h){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(e.substring(65,e.length-2))}const o=c.parse(n);t&&t(o)}),n,o)},parse:function(e){return new Font(e)}});const Tc={getContext:function(){return void 0===Sc&&(Sc=new(window.AudioContext||window.webkitAudioContext)),Sc},setContext:function(e){Sc=e}};function AudioLoader(e){Loader.call(this,e)}function HemisphereLightProbe(e,t,n){LightProbe.call(this,void 0,n);const o=(new Color).set(e),c=(new Color).set(t),h=new Vector3(o.r,o.g,o.b),d=new Vector3(c.r,c.g,c.b),p=Math.sqrt(Math.PI),m=p*Math.sqrt(.75);this.sh.coefficients[0].copy(h).add(d).multiplyScalar(p),this.sh.coefficients[1].copy(h).sub(d).multiplyScalar(m)}function AmbientLightProbe(e,t){LightProbe.call(this,void 0,t);const n=(new Color).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}AudioLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:AudioLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setResponseType("arraybuffer"),h.setPath(c.path),h.load(e,(function(n){try{const e=n.slice(0),o=Tc.getContext();o.decodeAudioData(e,(function(e){t(e)}))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)}}),HemisphereLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{constructor:HemisphereLightProbe,isHemisphereLightProbe:!0,copy:function(e){return LightProbe.prototype.copy.call(this,e),this},toJSON:function(e){const t=LightProbe.prototype.toJSON.call(this,e);return t}}),AmbientLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{constructor:AmbientLightProbe,isAmbientLightProbe:!0,copy:function(e){return LightProbe.prototype.copy.call(this,e),this},toJSON:function(e){const t=LightProbe.prototype.toJSON.call(this,e);return t}});const Ec=new Matrix4,Lc=new Matrix4;function StereoCamera(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}function Clock(e){this.autoStart=void 0===e||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}Object.assign(StereoCamera.prototype,{update:function(e){const t=this._cache,n=t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep;if(n){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),o=t.eyeSep/2,c=o*t.near/t.focus,h=t.near*Math.tan(Wn.DEG2RAD*t.fov*.5)/t.zoom;let d,p;Lc.elements[12]=-o,Ec.elements[12]=o,d=-h*t.aspect+c,p=h*t.aspect+c,n.elements[0]=2*t.near/(p-d),n.elements[8]=(p+d)/(p-d),this.cameraL.projectionMatrix.copy(n),d=-h*t.aspect-c,p=h*t.aspect-c,n.elements[0]=2*t.near/(p-d),n.elements[8]=(p+d)/(p-d),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Lc),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ec)}}),Object.assign(Clock.prototype,{start:function(){this.startTime=("undefined"===typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0},stop:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1},getElapsedTime:function(){return this.getDelta(),this.elapsedTime},getDelta:function(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=("undefined"===typeof performance?Date:performance).now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}});const Ac=new Vector3,Cc=new Quaternion,Pc=new Vector3,Rc=new Vector3;function AudioListener(){Object3D.call(this),this.type="AudioListener",this.context=Tc.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}function Audio(e){Object3D.call(this),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.sourceType="empty",this._startedAt=0,this._progress=0,this.filters=[]}AudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:AudioListener,getInput:function(){return this.gain},removeFilter:function(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this},getFilter:function(){return this.filter},setFilter:function(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this},updateMatrixWorld:function(e){Object3D.prototype.updateMatrixWorld.call(this,e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ac,Cc,Pc),Rc.set(0,0,-1).applyQuaternion(Cc),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Ac.x,e),t.positionY.linearRampToValueAtTime(Ac.y,e),t.positionZ.linearRampToValueAtTime(Ac.z,e),t.forwardX.linearRampToValueAtTime(Rc.x,e),t.forwardY.linearRampToValueAtTime(Rc.y,e),t.forwardZ.linearRampToValueAtTime(Rc.z,e),t.upX.linearRampToValueAtTime(n.x,e),t.upY.linearRampToValueAtTime(n.y,e),t.upZ.linearRampToValueAtTime(n.z,e)}else t.setPosition(Ac.x,Ac.y,Ac.z),t.setOrientation(Rc.x,Rc.y,Rc.z,n.x,n.y,n.z)}}),Audio.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Audio,getOutput:function(){return this.gain},setNodeSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this},setMediaElementSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this},setMediaStreamSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this},setBuffer:function(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this},play:function(e){if(void 0===e&&(e=0),!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()},pause:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")},stop:function(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")},connect:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(e){return e||(e=[]),!0===this.isPlaying?(this.disconnect(),this.filters=e,this.connect()):this.filters=e,this},setDetune:function(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this},getDetune:function(){return this.detune},getFilter:function(){return this.getFilters()[0]},setFilter:function(e){return this.setFilters(e?[e]:[])},setPlaybackRate:function(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop},setLoop:function(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")},setLoopStart:function(e){return this.loopStart=e,this},setLoopEnd:function(e){return this.loopEnd=e,this},getVolume:function(){return this.gain.gain.value},setVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}});const Bc=new Vector3,Dc=new Quaternion,Gc=new Vector3,Ic=new Vector3;function PositionalAudio(e){Audio.call(this,e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}function AudioAnalyser(e,t){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=void 0!==t?t:2048,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}function PropertyMixer(e,t,n){let o,c,h;switch(this.binding=e,this.valueSize=n,t){case"quaternion":o=this._slerp,c=this._slerpAdditive,h=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":o=this._select,c=this._select,h=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:o=this._lerp,c=this._lerpAdditive,h=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=o,this._mixBufferRegionAdditive=c,this._setIdentity=h,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}PositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{constructor:PositionalAudio,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(e){return this.panner.refDistance=e,this},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(e){return this.panner.rolloffFactor=e,this},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(e){return this.panner.distanceModel=e,this},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(e){return this.panner.maxDistance=e,this},setDirectionalCone:function(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this},updateMatrixWorld:function(e){if(Object3D.prototype.updateMatrixWorld.call(this,e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Bc,Dc,Gc),Ic.set(0,0,1).applyQuaternion(Dc);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Bc.x,e),t.positionY.linearRampToValueAtTime(Bc.y,e),t.positionZ.linearRampToValueAtTime(Bc.z,e),t.orientationX.linearRampToValueAtTime(Ic.x,e),t.orientationY.linearRampToValueAtTime(Ic.y,e),t.orientationZ.linearRampToValueAtTime(Ic.z,e)}else t.setPosition(Bc.x,Bc.y,Bc.z),t.setOrientation(Ic.x,Ic.y,Ic.z)}}),Object.assign(AudioAnalyser.prototype,{getFrequencyData:function(){return this.analyser.getByteFrequencyData(this.data),this.data},getAverageFrequency:function(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}),Object.assign(PropertyMixer.prototype,{accumulate:function(e,t){const n=this.buffer,o=this.valueSize,c=e*o+o;let h=this.cumulativeWeight;if(0===h){for(let e=0;e!==o;++e)n[c+e]=n[e];h=t}else{h+=t;const e=t/h;this._mixBufferRegion(n,c,0,e,o)}this.cumulativeWeight=h},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,o=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,o,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,o=e*t+t,c=this.cumulativeWeight,h=this.cumulativeWeightAdditive,d=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,c<1){const e=t*this._origIndex;this._mixBufferRegion(n,o,e,1-c,t)}h>0&&this._mixBufferRegionAdditive(n,o,this._addIndex*t,1,t);for(let p=t,m=t+t;p!==m;++p)if(n[p]!==n[p+t]){d.setValue(n,o);break}},saveOriginalState:function(){const e=this.binding,t=this.buffer,n=this.valueSize,o=n*this._origIndex;e.getValue(t,o);for(let c=n,h=o;c!==h;++c)t[c]=t[o+c%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[4*this._addIndex+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,o,c){if(o>=.5)for(let h=0;h!==c;++h)e[t+h]=e[n+h]},_slerp:function(e,t,n,o){Quaternion.slerpFlat(e,t,e,t,e,n,o)},_slerpAdditive:function(e,t,n,o,c){const h=this._workIndex*c;Quaternion.multiplyQuaternionsFlat(e,h,e,t,e,n),Quaternion.slerpFlat(e,t,e,t,e,h,o)},_lerp:function(e,t,n,o,c){const h=1-o;for(let d=0;d!==c;++d){const c=t+d;e[c]=e[c]*h+e[n+d]*o}},_lerpAdditive:function(e,t,n,o,c){for(let h=0;h!==c;++h){const c=t+h;e[c]=e[c]+e[n+h]*o}}});const Oc="\\[\\]\\.:\\/",Vc=new RegExp("["+Oc+"]","g"),Nc="[^"+Oc+"]",Fc="[^"+Oc.replace("\\.","")+"]",Uc=/((?:WC+[\/:])*)/.source.replace("WC",Nc),zc=/(WCOD+)?/.source.replace("WCOD",Fc),Hc=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Nc),kc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Nc),jc=new RegExp("^"+Uc+zc+Hc+kc+"$"),Wc=["material","materials","bones"];function Composite(e,t,n){const o=n||PropertyBinding.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,o)}function PropertyBinding(e,t,n){this.path=t,this.parsedPath=n||PropertyBinding.parseTrackName(t),this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}function AnimationObjectGroup(){this.uuid=Wn.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,o=arguments.length;n!==o;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}function AnimationAction(e,t,n,o){this._mixer=e,this._clip=t,this._localRoot=n||null,this.blendMode=o||t.blendMode;const c=t.tracks,h=c.length,d=new Array(h),p={endingStart:Kt,endingEnd:Kt};for(let m=0;m!==h;++m){const e=c[m].createInterpolant(null);d[m]=e,e.settings=p}this._interpolantSettings=p,this._interpolants=d,this._propertyBindings=new Array(h),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Xt,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}function AnimationMixer(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}function Uniform(e){"string"===typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}function InstancedInterleavedBuffer(e,t,n){InterleavedBuffer.call(this,e,t),this.meshPerAttribute=n||1}function Raycaster(e,t,n,o){this.ray=new Ray(e,t),this.near=n||0,this.far=o||1/0,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function ascSort(e,t){return e.distance-t.distance}function intersectObject(e,t,n,o){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===o){const o=e.children;for(let e=0,c=o.length;e<c;e++)intersectObject(o[e],t,n,!0)}}function Spherical(e,t,n){return this.radius=void 0!==e?e:1,this.phi=void 0!==t?t:0,this.theta=void 0!==n?n:0,this}function Cylindrical(e,t,n){return this.radius=void 0!==e?e:1,this.theta=void 0!==t?t:0,this.y=void 0!==n?n:0,this}Object.assign(Composite.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,o=this._bindings[n];void 0!==o&&o.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let o=this._targetGroup.nCachedObjects_,c=n.length;o!==c;++o)n[o].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(PropertyBinding,{Composite:Composite,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,t,n):new PropertyBinding(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(Vc,"")},parseTrackName:function(e){const t=jc.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},o=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){const e=n.nodeName.substring(o+1);-1!==Wc.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,o),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const searchNodeSubtree=function(e){for(let n=0;n<e.length;n++){const o=e[n];if(o.name===t||o.uuid===t)return o;const c=searchNodeSubtree(o.children);if(c)return c}return null},n=searchNodeSubtree(e.children);if(n)return n}return null}}),Object.assign(PropertyBinding.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(e,t){e[t]=this.node[this.propertyName]},function getValue_array(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)e[t++]=n[o]},function getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]},function setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_array(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++]},function setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++];this.targetObject.needsUpdate=!0},function setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)},function setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function getValue_unbound(e,t){this.bind(),this.getValue(e,t)},setValue:function getValue_unbound(e,t){this.bind(),this.setValue(e,t)},bind:function(){let e=this.node,t=this.parsedPath,n=t.objectName,o=t.propertyName,c=t.propertyIndex;if(e||(e=PropertyBinding.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let o=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===o){o=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==o){if(void 0===e[o])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[o]}}const h=e[o];if(void 0===h){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+o+" but it wasn't found.",e)}let d=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?d=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(d=this.Versioning.MatrixWorldNeedsUpdate);let p=this.BindingType.Direct;if(void 0!==c){if("morphTargetInfluences"===o){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[c]&&(c=e.morphTargetDictionary[c])}p=this.BindingType.ArrayElement,this.resolvedProperty=h,this.propertyIndex=c}else void 0!==h.fromArray&&void 0!==h.toArray?(p=this.BindingType.HasFromToArray,this.resolvedProperty=h):Array.isArray(h)?(p=this.BindingType.EntireArray,this.resolvedProperty=h):this.propertyName=o;this.getValue=this.GetterByBindingType[p],this.setValue=this.SetterByBindingTypeAndVersioning[p][d]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(PropertyBinding.prototype,{_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue}),Object.assign(AnimationObjectGroup.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,o=this._parsedPaths,c=this._bindings,h=c.length;let d=void 0,p=e.length,m=this.nCachedObjects_;for(let g=0,y=arguments.length;g!==y;++g){const y=arguments[g],x=y.uuid;let b=t[x];if(void 0===b){b=p++,t[x]=b,e.push(y);for(let e=0,t=h;e!==t;++e)c[e].push(new PropertyBinding(y,n[e],o[e]))}else if(b<m){d=e[b];const p=--m,g=e[p];t[g.uuid]=b,e[b]=g,t[x]=p,e[p]=y;for(let e=0,t=h;e!==t;++e){const t=c[e],h=t[p];let d=t[b];t[b]=h,void 0===d&&(d=new PropertyBinding(y,n[e],o[e])),t[p]=d}}else e[b]!==d&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=m},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let c=this.nCachedObjects_;for(let h=0,d=arguments.length;h!==d;++h){const d=arguments[h],p=d.uuid,m=t[p];if(void 0!==m&&m>=c){const h=c++,g=e[h];t[g.uuid]=m,e[m]=g,t[p]=h,e[h]=d;for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[h],c=t[m];t[m]=o,t[h]=c}}}this.nCachedObjects_=c},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let c=this.nCachedObjects_,h=e.length;for(let d=0,p=arguments.length;d!==p;++d){const p=arguments[d],m=p.uuid,g=t[m];if(void 0!==g)if(delete t[m],g<c){const d=--c,p=e[d],m=--h,y=e[m];t[p.uuid]=g,e[g]=p,t[y.uuid]=d,e[d]=y,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[d],c=t[m];t[g]=o,t[d]=c,t.pop()}}else{const c=--h,d=e[c];t[d.uuid]=g,e[g]=d,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e];t[g]=t[c],t.pop()}}}this.nCachedObjects_=c},subscribe_:function(e,t){let n=this._bindingsIndicesByPath,o=n[e],c=this._bindings;if(void 0!==o)return c[o];const h=this._paths,d=this._parsedPaths,p=this._objects,m=p.length,g=this.nCachedObjects_,y=new Array(m);o=c.length,n[e]=o,h.push(e),d.push(t),c.push(y);for(let x=g,b=p.length;x!==b;++x){const n=p[x];y[x]=new PropertyBinding(n,e,t)}return y},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const o=this._paths,c=this._parsedPaths,h=this._bindings,d=h.length-1,p=h[d],m=e[d];t[m]=n,h[n]=p,h.pop(),c[n]=c[d],c.pop(),o[n]=o[d],o.pop()}}}),Object.assign(AnimationAction.prototype,{play:function(){return this._mixer._activateAction(this),this},stop:function(){return this._mixer._deactivateAction(this),this.reset()},reset:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(e){return this._startTime=e,this},setLoop:function(e,t){return this.loop=e,this.repetitions=t,this},setEffectiveWeight:function(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(e){return this._scheduleFading(e,0,1)},fadeOut:function(e){return this._scheduleFading(e,1,0)},crossFadeFrom:function(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,o=e._clip.duration,c=o/n,h=n/o;e.warp(1,c,t),this.warp(h,1,t)}return this},crossFadeTo:function(e,t,n){return e.crossFadeFrom(this,t,n)},stopFading:function(){let e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},setEffectiveTimeScale:function(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(e){return this.timeScale=this._clip.duration/e,this.stopWarping()},syncWith:function(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()},halt:function(e){return this.warp(this._effectiveTimeScale,0,e)},warp:function(e,t,n){const o=this._mixer,c=o.time,h=this.timeScale;let d=this._timeScaleInterpolant;null===d&&(d=o._lendControlInterpolant(),this._timeScaleInterpolant=d);const p=d.parameterPositions,m=d.sampleValues;return p[0]=c,p[1]=c+n,m[0]=e/h,m[1]=t/h,this},stopWarping:function(){let e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(e,t,n,o){if(!this.enabled)return void this._updateWeight(e);const c=this._startTime;if(null!==c){const o=(e-c)*n;if(o<0||0===n)return;this._startTime=null,t=n*o}t*=this._updateTimeScale(e);const h=this._updateTime(t),d=this._updateWeight(e);if(d>0){const e=this._interpolants,t=this._propertyBindings;switch(this.blendMode){case nn:for(let n=0,o=e.length;n!==o;++n)e[n].evaluate(h),t[n].accumulateAdditive(d);break;case tn:default:for(let n=0,c=e.length;n!==c;++n)e[n].evaluate(h),t[n].accumulate(o,d)}}},_updateWeight:function(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const o=n.evaluate(e)[0];t*=o,e>n.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this._effectiveWeight=t,t},_updateTimeScale:function(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){const o=n.evaluate(e)[0];t*=o,e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t},_updateTime:function(e){const t=this._clip.duration,n=this.loop;let o=this.time+e,c=this._loopCount;const h=n===Yt;if(0===e)return-1===c?o:h&&1===(1&c)?t-o:o;if(n===qt){-1===c&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(o>=t)o=t;else{if(!(o<0)){this.time=o;break e}o=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===c&&(e>=0?(c=0,this._setEndings(!0,0===this.repetitions,h)):this._setEndings(0===this.repetitions,!0,h)),o>=t||o<0){const n=Math.floor(o/t);o-=t*n,c+=Math.abs(n);const d=this.repetitions-c;if(d<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,o=e>0?t:0,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===d){const t=e<0;this._setEndings(t,!t,h)}else this._setEndings(!1,!1,h);this._loopCount=c,this.time=o,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=o;if(h&&1===(1&c))return t-o}return o},_setEndings:function(e,t,n){const o=this._interpolantSettings;n?(o.endingStart=$t,o.endingEnd=$t):(o.endingStart=e?this.zeroSlopeAtStart?$t:Kt:en,o.endingEnd=t?this.zeroSlopeAtEnd?$t:Kt:en)},_scheduleFading:function(e,t,n){const o=this._mixer,c=o.time;let h=this._weightInterpolant;null===h&&(h=o._lendControlInterpolant(),this._weightInterpolant=h);const d=h.parameterPositions,p=h.sampleValues;return d[0]=c,p[0]=t,d[1]=c+e,p[1]=n,this}}),AnimationMixer.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:AnimationMixer,_bindAction:function(e,t){const n=e._localRoot||this._root,o=e._clip.tracks,c=o.length,h=e._propertyBindings,d=e._interpolants,p=n.uuid,m=this._bindingsByRootAndName;let g=m[p];void 0===g&&(g={},m[p]=g);for(let y=0;y!==c;++y){const e=o[y],c=e.name;let m=g[c];if(void 0!==m)h[y]=m;else{if(m=h[y],void 0!==m){null===m._cacheIndex&&(++m.referenceCount,this._addInactiveBinding(m,p,c));continue}const o=t&&t._propertyBindings[y].binding.parsedPath;m=new PropertyMixer(PropertyBinding.create(n,c,o),e.ValueTypeName,e.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,p,c),h[y]=m}d[y].resultBuffer=m.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,o=this._actionsByClip[n];this._bindAction(e,o&&o.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0===n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0===--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const o=this._actions,c=this._actionsByClip;let h=c[t];if(void 0===h)h={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,c[t]=h;else{const t=h.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=o.length,o.push(e),h.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],o=e._cacheIndex;n._cacheIndex=o,t[o]=n,t.pop(),e._cacheIndex=null;const c=e._clip.uuid,h=this._actionsByClip,d=h[c],p=d.knownActions,m=p[p.length-1],g=e._byClipCacheIndex;m._byClipCacheIndex=g,p[g]=m,p.pop(),e._byClipCacheIndex=null;const y=d.actionByRoot,x=(e._localRoot||this._root).uuid;delete y[x],0===p.length&&delete h[c],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let n=0,o=t.length;n!==o;++n){const e=t[n];0===--e.referenceCount&&this._removeInactiveBinding(e)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,o=this._nActiveActions++,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,o=--this._nActiveActions,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_addInactiveBinding:function(e,t,n){const o=this._bindingsByRootAndName,c=this._bindings;let h=o[t];void 0===h&&(h={},o[t]=h),h[n]=e,e._cacheIndex=c.length,c.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,o=n.rootNode.uuid,c=n.path,h=this._bindingsByRootAndName,d=h[o],p=t[t.length-1],m=e._cacheIndex;p._cacheIndex=m,t[m]=p,t.pop(),delete d[c],0===Object.keys(d).length&&delete h[o]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,o=this._nActiveBindings++,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,o=--this._nActiveBindings,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,o=--this._nActiveControlInterpolants,c=t[o];e.__cacheIndex=o,t[o]=e,c.__cacheIndex=n,t[n]=c},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const o=t||this._root,c=o.uuid;let h="string"===typeof e?AnimationClip.findByName(o,e):e;const d=null!==h?h.uuid:e;let p=this._actionsByClip[d],m=null;if(void 0===n&&(n=null!==h?h.blendMode:tn),void 0!==p){const e=p.actionByRoot[c];if(void 0!==e&&e.blendMode===n)return e;m=p.knownActions[0],null===h&&(h=m._clip)}if(null===h)return null;const g=new AnimationAction(this,h,t,n);return this._bindAction(g,m),this._addInactiveAction(g,d,c),g},existingAction:function(e,t){const n=t||this._root,o=n.uuid,c="string"===typeof e?AnimationClip.findByName(n,e):e,h=c?c.uuid:e,d=this._actionsByClip[h];return void 0!==d&&d.actionByRoot[o]||null},stopAllAction:function(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this},update:function(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,o=this.time+=e,c=Math.sign(e),h=this._accuIndex^=1;for(let m=0;m!==n;++m){const n=t[m];n._update(o,e,c,h)}const d=this._bindings,p=this._nActiveBindings;for(let m=0;m!==p;++m)d[m].apply(h);return this},setTime:function(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,o=this._actionsByClip,c=o[n];if(void 0!==c){const e=c.knownActions;for(let n=0,o=e.length;n!==o;++n){const o=e[n];this._deactivateAction(o);const c=o._cacheIndex,h=t[t.length-1];o._cacheIndex=null,o._byClipCacheIndex=null,h._cacheIndex=c,t[c]=h,t.pop(),this._removeInactiveBindingsForAction(o)}delete o[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const h in n){const e=n[h].actionByRoot,o=e[t];void 0!==o&&(this._deactivateAction(o),this._removeInactiveAction(o))}const o=this._bindingsByRootAndName,c=o[t];if(void 0!==c)for(const h in c){const e=c[h];e.restoreOriginalState(),this._removeInactiveBinding(e)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}),Uniform.prototype.clone=function(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())},InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:!0,copy:function(e){return InterleavedBuffer.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=InterleavedBuffer.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=InterleavedBuffer.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.assign(Raycaster.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(e,t,n){const o=n||[];return intersectObject(e,this,o,t),o.sort(ascSort),o},intersectObjects:function(e,t,n){const o=n||[];if(!1===Array.isArray(e))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),o;for(let c=0,h=e.length;c<h;c++)intersectObject(e[c],this,o,t);return o.sort(ascSort),o}}),Object.assign(Spherical.prototype,{set:function(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this},makeSafe:function(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this},setFromVector3:function(e){return this.setFromCartesianCoords(e.x,e.y,e.z)},setFromCartesianCoords:function(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Wn.clamp(t/this.radius,-1,1))),this}}),Object.assign(Cylindrical.prototype,{set:function(e,t,n){return this.radius=e,this.theta=t,this.y=n,this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this},setFromVector3:function(e){return this.setFromCartesianCoords(e.x,e.y,e.z)},setFromCartesianCoords:function(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}});const qc=new Vector2;function Box2(e,t){this.min=void 0!==e?e:new Vector2(1/0,1/0),this.max=void 0!==t?t:new Vector2(-1/0,-1/0)}Object.assign(Box2.prototype,{set:function(e,t){return this.min.copy(e),this.max.copy(t),this},setFromPoints:function(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this},setFromCenterAndSize:function(e,t){const n=qc.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new Vector2),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new Vector2),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y},getParameter:function(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new Vector2),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)},clampPoint:function(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new Vector2),t.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){const t=qc.copy(e).clamp(this.min,this.max);return t.sub(e).length()},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});const Xc=new Vector3,Yc=new Vector3;function Line3(e,t){this.start=void 0!==e?e:new Vector3,this.end=void 0!==t?t:new Vector3}function ImmediateRenderObject(e){Object3D.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Object.assign(Line3.prototype,{set:function(e,t){return this.start.copy(e),this.end.copy(t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.start.copy(e.start),this.end.copy(e.end),this},getCenter:function(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Vector3),e.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Vector3),e.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new Vector3),this.delta(t).multiplyScalar(e).add(this.start)},closestPointToPointParameter:function(e,t){Xc.subVectors(e,this.start),Yc.subVectors(this.end,this.start);const n=Yc.dot(Yc),o=Yc.dot(Xc);let c=o/n;return t&&(c=Wn.clamp(c,0,1)),c},closestPointToPoint:function(e,t,n){const o=this.closestPointToPointParameter(e,t);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new Vector3),this.delta(n).multiplyScalar(o).add(this.start)},applyMatrix4:function(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this},equals:function(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}),ImmediateRenderObject.prototype=Object.create(Object3D.prototype),ImmediateRenderObject.prototype.constructor=ImmediateRenderObject,ImmediateRenderObject.prototype.isImmediateRenderObject=!0;const Zc=new Vector3;function SpotLightHelper(e,t){Object3D.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new BufferGeometry,o=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let h=0,d=1,p=32;h<p;h++,d++){const e=h/p*Math.PI*2,t=d/p*Math.PI*2;o.push(Math.cos(e),Math.sin(e),1,Math.cos(t),Math.sin(t),1)}n.setAttribute("position",new Float32BufferAttribute(o,3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(n,c),this.add(this.cone),this.update()}SpotLightHelper.prototype=Object.create(Object3D.prototype),SpotLightHelper.prototype.constructor=SpotLightHelper,SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose(),this.cone.material.dispose()},SpotLightHelper.prototype.update=function(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Zc.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Zc),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)};const Jc=new Vector3,Qc=new Matrix4,Kc=new Matrix4;function getBoneList(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,getBoneList(e.children[n]));return t}function SkeletonHelper(e){const t=getBoneList(e),n=new BufferGeometry,o=[],c=[],h=new Color(0,0,1),d=new Color(0,1,0);for(let m=0;m<t.length;m++){const e=t[m];e.parent&&e.parent.isBone&&(o.push(0,0,0),o.push(0,0,0),c.push(h.r,h.g,h.b),c.push(d.r,d.g,d.b))}n.setAttribute("position",new Float32BufferAttribute(o,3)),n.setAttribute("color",new Float32BufferAttribute(c,3));const p=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});LineSegments.call(this,n,p),this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}function PointLightHelper(e,t,n){this.light=e,this.light.updateMatrixWorld(),this.color=n;const o=new SphereBufferGeometry(t,4,2),c=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});Mesh.call(this,o,c),this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}SkeletonHelper.prototype=Object.create(LineSegments.prototype),SkeletonHelper.prototype.constructor=SkeletonHelper,SkeletonHelper.prototype.isSkeletonHelper=!0,SkeletonHelper.prototype.updateMatrixWorld=function(e){const t=this.bones,n=this.geometry,o=n.getAttribute("position");Kc.getInverse(this.root.matrixWorld);for(let c=0,h=0;c<t.length;c++){const e=t[c];e.parent&&e.parent.isBone&&(Qc.multiplyMatrices(Kc,e.matrixWorld),Jc.setFromMatrixPosition(Qc),o.setXYZ(h,Jc.x,Jc.y,Jc.z),Qc.multiplyMatrices(Kc,e.parent.matrixWorld),Jc.setFromMatrixPosition(Qc),o.setXYZ(h+1,Jc.x,Jc.y,Jc.z),h+=2)}n.getAttribute("position").needsUpdate=!0,Object3D.prototype.updateMatrixWorld.call(this,e)},PointLightHelper.prototype=Object.create(Mesh.prototype),PointLightHelper.prototype.constructor=PointLightHelper,PointLightHelper.prototype.dispose=function(){this.geometry.dispose(),this.material.dispose()},PointLightHelper.prototype.update=function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)};const $c=new Vector3,el=new Color,tl=new Color;function HemisphereLightHelper(e,t,n){Object3D.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const o=new OctahedronBufferGeometry(t);o.rotateY(.5*Math.PI),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const c=o.getAttribute("position"),h=new Float32Array(3*c.count);o.setAttribute("color",new BufferAttribute(h,3)),this.add(new Mesh(o,this.material)),this.update()}function GridHelper(e,t,n,o){e=e||10,t=t||10,n=new Color(void 0!==n?n:4473924),o=new Color(void 0!==o?o:8947848);const c=t/2,h=e/t,d=e/2,p=[],m=[];for(let x=0,b=0,M=-d;x<=t;x++,M+=h){p.push(-d,0,M,d,0,M),p.push(M,0,-d,M,0,d);const e=x===c?n:o;e.toArray(m,b),b+=3,e.toArray(m,b),b+=3,e.toArray(m,b),b+=3,e.toArray(m,b),b+=3}const g=new BufferGeometry;g.setAttribute("position",new Float32BufferAttribute(p,3)),g.setAttribute("color",new Float32BufferAttribute(m,3));const y=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});LineSegments.call(this,g,y),this.type="GridHelper"}function PolarGridHelper(e,t,n,o,c,h){e=e||10,t=t||16,n=n||8,o=o||64,c=new Color(void 0!==c?c:4473924),h=new Color(void 0!==h?h:8947848);const d=[],p=[];for(let y=0;y<=t;y++){const n=y/t*(2*Math.PI),o=Math.sin(n)*e,m=Math.cos(n)*e;d.push(0,0,0),d.push(o,0,m);const g=1&y?c:h;p.push(g.r,g.g,g.b),p.push(g.r,g.g,g.b)}for(let y=0;y<=n;y++){const t=1&y?c:h,m=e-e/n*y;for(let e=0;e<o;e++){let n=e/o*(2*Math.PI),c=Math.sin(n)*m,h=Math.cos(n)*m;d.push(c,0,h),p.push(t.r,t.g,t.b),n=(e+1)/o*(2*Math.PI),c=Math.sin(n)*m,h=Math.cos(n)*m,d.push(c,0,h),p.push(t.r,t.g,t.b)}}const m=new BufferGeometry;m.setAttribute("position",new Float32BufferAttribute(d,3)),m.setAttribute("color",new Float32BufferAttribute(p,3));const g=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});LineSegments.call(this,m,g),this.type="PolarGridHelper"}HemisphereLightHelper.prototype=Object.create(Object3D.prototype),HemisphereLightHelper.prototype.constructor=HemisphereLightHelper,HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()},HemisphereLightHelper.prototype.update=function(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");el.copy(this.light.color),tl.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const o=e<n/2?el:tl;t.setXYZ(e,o.r,o.g,o.b)}t.needsUpdate=!0}e.lookAt($c.setFromMatrixPosition(this.light.matrixWorld).negate())},GridHelper.prototype=Object.assign(Object.create(LineSegments.prototype),{constructor:GridHelper,copy:function(e){return LineSegments.prototype.copy.call(this,e),this.geometry.copy(e.geometry),this.material.copy(e.material),this},clone:function(){return(new this.constructor).copy(this)}}),PolarGridHelper.prototype=Object.create(LineSegments.prototype),PolarGridHelper.prototype.constructor=PolarGridHelper;const nl=new Vector3,rl=new Vector3,il=new Vector3;function DirectionalLightHelper(e,t,n){Object3D.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===t&&(t=1);let o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(o,c),this.add(this.lightPlane),o=new BufferGeometry,o.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(o,c),this.add(this.targetLine),this.update()}DirectionalLightHelper.prototype=Object.create(Object3D.prototype),DirectionalLightHelper.prototype.constructor=DirectionalLightHelper,DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()},DirectionalLightHelper.prototype.update=function(){nl.setFromMatrixPosition(this.light.matrixWorld),rl.setFromMatrixPosition(this.light.target.matrixWorld),il.subVectors(rl,nl),this.lightPlane.lookAt(rl),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(rl),this.targetLine.scale.z=il.length()};const ol=new Vector3,al=new Camera;function CameraHelper(e){const t=new BufferGeometry,n=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),o=[],c=[],h={},d=new Color(16755200),p=new Color(16711680),m=new Color(43775),g=new Color(16777215),y=new Color(3355443);function addLine(e,t,n){addPoint(e,n),addPoint(t,n)}function addPoint(e,t){o.push(0,0,0),c.push(t.r,t.g,t.b),void 0===h[e]&&(h[e]=[]),h[e].push(o.length/3-1)}addLine("n1","n2",d),addLine("n2","n4",d),addLine("n4","n3",d),addLine("n3","n1",d),addLine("f1","f2",d),addLine("f2","f4",d),addLine("f4","f3",d),addLine("f3","f1",d),addLine("n1","f1",d),addLine("n2","f2",d),addLine("n3","f3",d),addLine("n4","f4",d),addLine("p","n1",p),addLine("p","n2",p),addLine("p","n3",p),addLine("p","n4",p),addLine("u1","u2",m),addLine("u2","u3",m),addLine("u3","u1",m),addLine("c","t",g),addLine("p","c",y),addLine("cn1","cn2",y),addLine("cn3","cn4",y),addLine("cf1","cf2",y),addLine("cf3","cf4",y),t.setAttribute("position",new Float32BufferAttribute(o,3)),t.setAttribute("color",new Float32BufferAttribute(c,3)),LineSegments.call(this,t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=h,this.update()}function setPoint(e,t,n,o,c,h,d){ol.set(c,h,d).unproject(o);const p=t[e];if(void 0!==p){const e=n.getAttribute("position");for(let t=0,n=p.length;t<n;t++)e.setXYZ(p[t],ol.x,ol.y,ol.z)}}CameraHelper.prototype=Object.create(LineSegments.prototype),CameraHelper.prototype.constructor=CameraHelper,CameraHelper.prototype.update=function(){const e=this.geometry,t=this.pointMap,n=1,o=1;al.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",t,e,al,0,0,-1),setPoint("t",t,e,al,0,0,1),setPoint("n1",t,e,al,-n,-o,-1),setPoint("n2",t,e,al,n,-o,-1),setPoint("n3",t,e,al,-n,o,-1),setPoint("n4",t,e,al,n,o,-1),setPoint("f1",t,e,al,-n,-o,1),setPoint("f2",t,e,al,n,-o,1),setPoint("f3",t,e,al,-n,o,1),setPoint("f4",t,e,al,n,o,1),setPoint("u1",t,e,al,.7*n,1.1*o,-1),setPoint("u2",t,e,al,.7*-n,1.1*o,-1),setPoint("u3",t,e,al,0,2*o,-1),setPoint("cf1",t,e,al,-n,0,1),setPoint("cf2",t,e,al,n,0,1),setPoint("cf3",t,e,al,0,-o,1),setPoint("cf4",t,e,al,0,o,1),setPoint("cn1",t,e,al,-n,0,-1),setPoint("cn2",t,e,al,n,0,-1),setPoint("cn3",t,e,al,0,-o,-1),setPoint("cn4",t,e,al,0,o,-1),e.getAttribute("position").needsUpdate=!0};const sl=new Box3;function BoxHelper(e,t){this.object=e,void 0===t&&(t=16776960);const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Float32Array(24),c=new BufferGeometry;c.setIndex(new BufferAttribute(n,1)),c.setAttribute("position",new BufferAttribute(o,3)),LineSegments.call(this,c,new LineBasicMaterial({color:t,toneMapped:!1})),this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}function Box3Helper(e,t){this.type="Box3Helper",this.box=e,t=t||16776960;const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],c=new BufferGeometry;c.setIndex(new BufferAttribute(n,1)),c.setAttribute("position",new Float32BufferAttribute(o,3)),LineSegments.call(this,c,new LineBasicMaterial({color:t,toneMapped:!1})),this.type="Box3Helper",this.geometry.computeBoundingSphere()}function PlaneHelper(e,t,n){this.plane=e,this.size=void 0===t?1:t;const o=void 0!==n?n:16776960,c=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],h=new BufferGeometry;h.setAttribute("position",new Float32BufferAttribute(c,3)),h.computeBoundingSphere(),Line.call(this,h,new LineBasicMaterial({color:o,toneMapped:!1})),this.type="PlaneHelper";const d=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],p=new BufferGeometry;p.setAttribute("position",new Float32BufferAttribute(d,3)),p.computeBoundingSphere(),this.add(new Mesh(p,new MeshBasicMaterial({color:o,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}BoxHelper.prototype=Object.create(LineSegments.prototype),BoxHelper.prototype.constructor=BoxHelper,BoxHelper.prototype.update=function(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&sl.setFromObject(this.object),sl.isEmpty())return;const t=sl.min,n=sl.max,o=this.geometry.attributes.position,c=o.array;c[0]=n.x,c[1]=n.y,c[2]=n.z,c[3]=t.x,c[4]=n.y,c[5]=n.z,c[6]=t.x,c[7]=t.y,c[8]=n.z,c[9]=n.x,c[10]=t.y,c[11]=n.z,c[12]=n.x,c[13]=n.y,c[14]=t.z,c[15]=t.x,c[16]=n.y,c[17]=t.z,c[18]=t.x,c[19]=t.y,c[20]=t.z,c[21]=n.x,c[22]=t.y,c[23]=t.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()},BoxHelper.prototype.setFromObject=function(e){return this.object=e,this.update(),this},BoxHelper.prototype.copy=function(e){return LineSegments.prototype.copy.call(this,e),this.object=e.object,this},BoxHelper.prototype.clone=function(){return(new this.constructor).copy(this)},Box3Helper.prototype=Object.create(LineSegments.prototype),Box3Helper.prototype.constructor=Box3Helper,Box3Helper.prototype.updateMatrixWorld=function(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),Object3D.prototype.updateMatrixWorld.call(this,e))},PlaneHelper.prototype=Object.create(Line.prototype),PlaneHelper.prototype.constructor=PlaneHelper,PlaneHelper.prototype.updateMatrixWorld=function(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?T:S,this.lookAt(this.plane.normal),Object3D.prototype.updateMatrixWorld.call(this,e)};const cl=new Vector3;let ll,ul;function ArrowHelper(e,t,n,o,c,h){Object3D.call(this),this.type="ArrowHelper",void 0===e&&(e=new Vector3(0,0,1)),void 0===t&&(t=new Vector3(0,0,0)),void 0===n&&(n=1),void 0===o&&(o=16776960),void 0===c&&(c=.2*n),void 0===h&&(h=.2*c),void 0===ll&&(ll=new BufferGeometry,ll.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),ul=new CylinderBufferGeometry(0,.5,1,5,1),ul.translate(0,-.5,0)),this.position.copy(t),this.line=new Line(ll,new LineBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(ul,new MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,c,h)}function AxesHelper(e){e=e||1;const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute(t,3)),o.setAttribute("color",new Float32BufferAttribute(n,3));const c=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});LineSegments.call(this,o,c),this.type="AxesHelper"}ArrowHelper.prototype=Object.create(Object3D.prototype),ArrowHelper.prototype.constructor=ArrowHelper,ArrowHelper.prototype.setDirection=function(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{cl.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(cl,t)}},ArrowHelper.prototype.setLength=function(e,t,n){void 0===t&&(t=.2*e),void 0===n&&(n=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()},ArrowHelper.prototype.setColor=function(e){this.line.material.color.set(e),this.cone.material.color.set(e)},ArrowHelper.prototype.copy=function(e){return Object3D.prototype.copy.call(this,e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this},ArrowHelper.prototype.clone=function(){return(new this.constructor).copy(this)},AxesHelper.prototype=Object.create(LineSegments.prototype),AxesHelper.prototype.constructor=AxesHelper;const hl=4,dl=8,pl=Math.pow(2,dl),fl=[.125,.215,.35,.446,.526,.582],ml=dl-hl+1+fl.length,gl=20,yl={[sn]:0,[cn]:1,[un]:2,[dn]:3,[pn]:4,[fn]:5,[ln]:6},vl=new OrthographicCamera,{_lodPlanes:xl,_sizeLods:bl,_sigmas:Ml}=_createPlanes();let _l=null;const wl=(1+Math.sqrt(5))/2,Sl=1/wl,Tl=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,wl,Sl),new Vector3(0,wl,-Sl),new Vector3(Sl,0,wl),new Vector3(-Sl,0,wl),new Vector3(wl,Sl,0),new Vector3(-wl,Sl,0)];function PMREMGenerator(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=_getBlurShader(gl),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}function _isLDR(e){return void 0!==e&&e.type===Ge&&(e.encoding===sn||e.encoding===cn||e.encoding===ln)}function _createPlanes(){const e=[],t=[],n=[];let o=dl;for(let c=0;c<ml;c++){const h=Math.pow(2,o);t.push(h);let d=1/h;c>dl-hl?d=fl[c-dl+hl-1]:0==c&&(d=0),n.push(d);const p=1/(h-1),m=-p/2,g=1+p/2,y=[m,m,g,m,g,g,m,m,g,g,m,g],x=6,b=6,M=3,_=2,w=1,S=new Float32Array(M*b*x),T=new Float32Array(_*b*x),E=new Float32Array(w*b*x);for(let e=0;e<x;e++){const t=e%3*2/3-1,n=e>2?0:-1,o=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];S.set(o,M*b*e),T.set(y,_*b*e);const c=[e,e,e,e,e,e];E.set(c,w*b*e)}const L=new BufferGeometry;L.setAttribute("position",new BufferAttribute(S,M)),L.setAttribute("uv",new BufferAttribute(T,_)),L.setAttribute("faceIndex",new BufferAttribute(E,w)),e.push(L),o>hl&&o--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function _createRenderTarget(e){const t=new WebGLRenderTarget(3*pl,3*pl,e);return t.texture.mapping=xe,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function _setViewport(e,t,n,o,c){e.viewport.set(t,n,o,c),e.scissor.set(t,n,o,c)}function _getBlurShader(e){const t=new Float32Array(e),n=new Vector3(0,1,0),o=new RawShaderMaterial({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:yl[sn]},outputEncoding:{value:yl[sn]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n${_getEncodings()}\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:C,depthTest:!1,depthWrite:!1});return o}function _getEquirectShader(){const e=new Vector2(1,1),t=new RawShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:yl[sn]},outputEncoding:{value:yl[sn]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n${_getEncodings()}\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:C,depthTest:!1,depthWrite:!1});return t}function _getCubemapShader(){const e=new RawShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:yl[sn]},outputEncoding:{value:yl[sn]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n${_getEncodings()}\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t`,blending:C,depthTest:!1,depthWrite:!1});return e}function _getCommonVertexShader(){return"\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t"}function _getEncodings(){return"\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t"}function Face4(e,t,n,o,c,h,d){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Face3(e,t,n,c,h,d)}PMREMGenerator.prototype={constructor:PMREMGenerator,fromScene:function(e,t=0,n=.1,o=100){_l=this._renderer.getRenderTarget();const c=this._allocateTargets();return this._sceneToCubeUV(e,n,o,c),t>0&&this._blur(c,0,0,t),this._applyPMREM(c),this._cleanup(c),c},fromEquirectangular:function(e){return this._fromTexture(e)},fromCubemap:function(e){return this._fromTexture(e)},compileCubemapShader:function(){null===this._cubemapShader&&(this._cubemapShader=_getCubemapShader(),this._compileMaterial(this._cubemapShader))},compileEquirectangularShader:function(){null===this._equirectShader&&(this._equirectShader=_getEquirectShader(),this._compileMaterial(this._equirectShader))},dispose:function(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let e=0;e<xl.length;e++)xl[e].dispose()},_cleanup:function(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(_l),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)},_fromTexture:function(e){_l=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t},_allocateTargets:function(e){const t={magFilter:Se,minFilter:Se,generateMipmaps:!1,type:Ge,format:Qe,encoding:_isLDR(e)?e.encoding:un,depthBuffer:!1,stencilBuffer:!1},n=_createRenderTarget(t);return n.depthBuffer=!e,this._pingPongRenderTarget=_createRenderTarget(t),n},_compileMaterial:function(e){const t=new Mesh(xl[0],e);this._renderer.compile(t,vl)},_sceneToCubeUV:function(e,t,n,o){const c=90,h=1,d=new PerspectiveCamera(c,h,t,n),p=[1,-1,1,1,1,1],m=[1,1,1,-1,-1,-1],g=this._renderer,y=g.outputEncoding,x=g.toneMapping,b=g.getClearColor(),M=g.getClearAlpha();g.toneMapping=ce,g.outputEncoding=sn;let _=e.background;if(_&&_.isColor){_.convertSRGBToLinear();const t=Math.max(_.r,_.g,_.b),n=Math.min(Math.max(Math.ceil(Math.log2(t)),-128),127);_=_.multiplyScalar(Math.pow(2,-n));const o=(n+128)/255;g.setClearColor(_,o),e.background=null}for(let w=0;w<6;w++){const t=w%3;0==t?(d.up.set(0,p[w],0),d.lookAt(m[w],0,0)):1==t?(d.up.set(0,0,p[w]),d.lookAt(0,m[w],0)):(d.up.set(0,p[w],0),d.lookAt(0,0,m[w])),_setViewport(o,t*pl,w>2?pl:0,pl,pl),g.setRenderTarget(o),g.render(e,d)}g.toneMapping=x,g.outputEncoding=y,g.setClearColor(b,M)},_textureToCubeUV:function(e,t){const n=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=_getCubemapShader()):null==this._equirectShader&&(this._equirectShader=_getEquirectShader());const o=e.isCubeTexture?this._cubemapShader:this._equirectShader,c=new Mesh(xl[0],o),h=o.uniforms;h["envMap"].value=e,e.isCubeTexture||h["texelSize"].value.set(1/e.image.width,1/e.image.height),h["inputEncoding"].value=yl[e.encoding],h["outputEncoding"].value=yl[t.texture.encoding],_setViewport(t,0,0,3*pl,2*pl),n.setRenderTarget(t),n.render(c,vl)},_applyPMREM:function(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let o=1;o<ml;o++){const t=Math.sqrt(Ml[o]*Ml[o]-Ml[o-1]*Ml[o-1]),n=Tl[(o-1)%Tl.length];this._blur(e,o-1,o,t,n)}t.autoClear=n},_blur:function(e,t,n,o,c){const h=this._pingPongRenderTarget;this._halfBlur(e,h,t,n,o,"latitudinal",c),this._halfBlur(h,e,n,n,o,"longitudinal",c)},_halfBlur:function(e,t,n,o,c,h,d){const p=this._renderer,m=this._blurMaterial;"latitudinal"!==h&&"longitudinal"!==h&&console.error("blur direction must be either latitudinal or longitudinal!");const g=3,y=new Mesh(xl[o],m),x=m.uniforms,b=bl[n]-1,M=isFinite(c)?Math.PI/(2*b):2*Math.PI/(2*gl-1),_=c/M,w=isFinite(c)?1+Math.floor(g*_):gl;w>gl&&console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${gl}`);const S=[];let T=0;for(let C=0;C<gl;++C){const e=C/_,t=Math.exp(-e*e/2);S.push(t),0==C?T+=t:C<w&&(T+=2*t)}for(let C=0;C<S.length;C++)S[C]=S[C]/T;x["envMap"].value=e.texture,x["samples"].value=w,x["weights"].value=S,x["latitudinal"].value="latitudinal"===h,d&&(x["poleAxis"].value=d),x["dTheta"].value=M,x["mipInt"].value=dl-n,x["inputEncoding"].value=yl[e.texture.encoding],x["outputEncoding"].value=yl[e.texture.encoding];const E=bl[o],L=3*Math.max(0,pl-2*E),A=(0===o?0:2*pl)+2*E*(o>dl-hl?o-dl+hl:0);_setViewport(t,L,A,3*E,2*E),p.setRenderTarget(t),p.render(y,vl)}};const El=0,Ll=1,Al=0,Cl=1,Pl=2;function MeshFaceMaterial(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function MultiMaterial(e){return void 0===e&&(e=[]),console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function PointCloud(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Points(e,t)}function Particle(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Sprite(e)}function ParticleSystem(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Points(e,t)}function PointCloudMaterial(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function ParticleBasicMaterial(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function ParticleSystemMaterial(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function Vertex(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Vector3(e,t,n)}function DynamicBufferAttribute(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new BufferAttribute(e,t).setUsage(On)}function Int8Attribute(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Int8BufferAttribute(e,t)}function Uint8Attribute(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Uint8BufferAttribute(e,t)}function Uint8ClampedAttribute(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Uint8ClampedBufferAttribute(e,t)}function Int16Attribute(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Int16BufferAttribute(e,t)}function Uint16Attribute(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Uint16BufferAttribute(e,t)}function Int32Attribute(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new Int32BufferAttribute(e,t)}function Uint32Attribute(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Uint32BufferAttribute(e,t)}function Float32Attribute(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Float32BufferAttribute(e,t)}function Float64Attribute(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Float64BufferAttribute(e,t)}function ClosedSplineCurve3(e){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom",this.closed=!0}function SplineCurve3(e){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom"}function Spline(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom"}function AxisHelper(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new AxesHelper(e)}function BoundingBoxHelper(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new BoxHelper(e,t)}function EdgesHelper(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new LineSegments(new EdgesGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}function WireframeHelper(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new LineSegments(new WireframeGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}function XHRLoader(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new FileLoader(e)}function BinaryTextureLoader(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new DataTextureLoader(e)}function WebGLRenderTargetCube(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new WebGLCubeRenderTarget(e,n)}Curve.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Curve.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(CurvePath.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=new Geometry;for(let n=0,o=e.length;n<o;n++){const o=e[n];t.vertices.push(new Vector3(o.x,o.y,o.z||0))}return t}}),Object.assign(Path.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),ClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype),SplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype),Spline.prototype=Object.create(CatmullRomCurve3.prototype),Object.assign(Spline.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),GridHelper.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},SkeletonHelper.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(Loader.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),xc.extractUrlBase(e)}}),Loader.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(ObjectLoader.prototype,{setTexturePath:function(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}),Object.assign(Box2.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Box3.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Sphere.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Frustum.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},Line3.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(Wn,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Wn.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Wn.ceilPowerOfTwo(e)}}),Object.assign(Matrix3.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}}),Object.assign(Matrix4.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new Vector3).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,o,c,h){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,o,n,c,h)}}),Plane.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Quaternion.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},Object.assign(Ray.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(Triangle.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(Triangle,{barycoordFromPoint:function(e,t,n,o,c){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Triangle.getBarycoord(e,t,n,o,c)},normal:function(e,t,n,o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Triangle.getNormal(e,t,n,o)}}),Object.assign(Shape.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new ExtrudeGeometry(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ShapeGeometry(this,e)}}),Object.assign(Vector2.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Vector3.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Vector4.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Geometry.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(Object3D.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Mesh.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Mesh.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),rn},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(LOD.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(Skeleton.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),SkinnedMesh.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Curve.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),PerspectiveCamera.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===On},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(On)}}}),Object.assign(BufferAttribute.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?On:In),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(BufferGeometry.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new BufferAttribute(arguments[1],arguments[2])))},addDrawCall:function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(InstancedBufferGeometry.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(Raycaster.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(InterleavedBuffer.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===On},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(InterleavedBuffer.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?On:In),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(ExtrudeBufferGeometry.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.defineProperties(Uniform.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Color}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===L}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(MeshPhongMaterial.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(WebGLRenderer.prototype,{clearTarget:function(e,t,n,o){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,o)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?cn:sn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Audio.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this,n=new AudioLoader;return n.load(e,(function(e){t.setBuffer(e)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),AudioAnalyser.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},CubeCamera.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)};const Rl={merge:function(e,t,n){let o;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),o=t.matrix,t=t.geometry),e.merge(t,o,n)},center:function(e){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),e.center()}};function CanvasRenderer(){console.error("THREE.CanvasRenderer has been removed")}function JSONLoader(){console.error("THREE.JSONLoader has been removed.")}Xn.crossOrigin=void 0,Xn.loadTexture=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const c=new TextureLoader;c.setCrossOrigin(this.crossOrigin);const h=c.load(e,n,void 0,o);return t&&(h.mapping=t),h},Xn.loadTextureCube=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const c=new CubeTextureLoader;c.setCrossOrigin(this.crossOrigin);const h=c.load(e,n,void 0,o);return t&&(h.mapping=t),h},Xn.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Xn.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const Bl={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function LensFlare(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:o}}))},"./node_modules/mini-css-extract-plugin/dist/loader.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=style&index=0&id=502b953a&scoped=true&lang=css&":function(e,t,n){},"./node_modules/three-orbitcontrols/OrbitControls.js":function(e,t,n){var o=n("./node_modules/three/build/three.module.js");o.OrbitControls=function(e,t){void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new o.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!1,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:o.MOUSE.ROTATE,MIDDLE:o.MOUSE.DOLLY,RIGHT:o.MOUSE.PAN},this.touches={ONE:o.TOUCH.ROTATE,TWO:o.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return y.phi},this.getAzimuthalAngle=function(){return y.theta},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(c),n.update(),m=p.NONE},this.update=function(){var t=new o.Vector3,h=(new o.Quaternion).setFromUnitVectors(e.up,new o.Vector3(0,1,0)),d=h.clone().inverse(),w=new o.Vector3,S=new o.Quaternion;return function update(){var e=n.object.position;return t.copy(e).sub(n.target),t.applyQuaternion(h),y.setFromVector3(t),n.autoRotate&&m===p.NONE&&rotateLeft(getAutoRotationAngle()),n.enableDamping?(y.theta+=x.theta*n.dampingFactor,y.phi+=x.phi*n.dampingFactor):(y.theta+=x.theta,y.phi+=x.phi),y.theta=Math.max(n.minAzimuthAngle,Math.min(n.maxAzimuthAngle,y.theta)),y.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,y.phi)),y.makeSafe(),y.radius*=b,y.radius=Math.max(n.minDistance,Math.min(n.maxDistance,y.radius)),!0===n.enableDamping?n.target.addScaledVector(M,n.dampingFactor):n.target.add(M),t.setFromSpherical(y),t.applyQuaternion(d),e.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(x.theta*=1-n.dampingFactor,x.phi*=1-n.dampingFactor,M.multiplyScalar(1-n.dampingFactor)):(x.set(0,0,0),M.set(0,0,0)),b=1,!!(_||w.distanceToSquared(n.object.position)>g||8*(1-S.dot(n.object.quaternion))>g)&&(n.dispatchEvent(c),w.copy(n.object.position),S.copy(n.object.quaternion),_=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",onContextMenu,!1),n.domElement.removeEventListener("mousedown",onMouseDown,!1),n.domElement.removeEventListener("wheel",onMouseWheel,!1),n.domElement.removeEventListener("touchstart",onTouchStart,!1),n.domElement.removeEventListener("touchend",onTouchEnd,!1),n.domElement.removeEventListener("touchmove",onTouchMove,!1),document.removeEventListener("mousemove",onMouseMove,!1),document.removeEventListener("mouseup",onMouseUp,!1),n.domElement.removeEventListener("keydown",onKeyDown,!1)};var n=this,c={type:"change"},h={type:"start"},d={type:"end"},p={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},m=p.NONE,g=1e-6,y=new o.Spherical,x=new o.Spherical,b=1,M=new o.Vector3,_=!1,w=new o.Vector2,S=new o.Vector2,T=new o.Vector2,E=new o.Vector2,L=new o.Vector2,A=new o.Vector2,C=new o.Vector2,P=new o.Vector2,R=new o.Vector2;function getAutoRotationAngle(){return 2*Math.PI/60/60*n.autoRotateSpeed}function getZoomScale(){return Math.pow(.95,n.zoomSpeed)}function rotateLeft(e){x.theta-=e}function rotateUp(e){x.phi-=e}var B=function(){var e=new o.Vector3;return function panLeft(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),M.add(e)}}(),D=function(){var e=new o.Vector3;return function panUp(t,o){!0===n.screenSpacePanning?e.setFromMatrixColumn(o,1):(e.setFromMatrixColumn(o,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),M.add(e)}}(),G=function(){var e=new o.Vector3;return function pan(t,o){var c=n.domElement;if(n.object.isPerspectiveCamera){var h=n.object.position;e.copy(h).sub(n.target);var d=e.length();d*=Math.tan(n.object.fov/2*Math.PI/180),B(2*t*d/c.clientHeight,n.object.matrix),D(2*o*d/c.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(B(t*(n.object.right-n.object.left)/n.object.zoom/c.clientWidth,n.object.matrix),D(o*(n.object.top-n.object.bottom)/n.object.zoom/c.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function dollyIn(e){n.object.isPerspectiveCamera?b/=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom*e)),n.object.updateProjectionMatrix(),_=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function dollyOut(e){n.object.isPerspectiveCamera?b*=e:n.object.isOrthographicCamera?(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/e)),n.object.updateProjectionMatrix(),_=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function handleMouseDownRotate(e){w.set(e.clientX,e.clientY)}function handleMouseDownDolly(e){C.set(e.clientX,e.clientY)}function handleMouseDownPan(e){E.set(e.clientX,e.clientY)}function handleMouseMoveRotate(e){S.set(e.clientX,e.clientY),T.subVectors(S,w).multiplyScalar(n.rotateSpeed);var t=n.domElement;rotateLeft(2*Math.PI*T.x/t.clientHeight),rotateUp(2*Math.PI*T.y/t.clientHeight),w.copy(S),n.update()}function handleMouseMoveDolly(e){P.set(e.clientX,e.clientY),R.subVectors(P,C),R.y>0?dollyIn(getZoomScale()):R.y<0&&dollyOut(getZoomScale()),C.copy(P),n.update()}function handleMouseMovePan(e){L.set(e.clientX,e.clientY),A.subVectors(L,E).multiplyScalar(n.panSpeed),G(A.x,A.y),E.copy(L),n.update()}function handleMouseUp(){}function handleMouseWheel(e){e.deltaY<0?dollyOut(getZoomScale()):e.deltaY>0&&dollyIn(getZoomScale()),n.update()}function handleKeyDown(e){var t=!1;switch(e.keyCode){case n.keys.UP:G(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:G(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:G(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:G(-n.keyPanSpeed,0),t=!0;break}t&&(e.preventDefault(),n.update())}function handleTouchStartRotate(e){if(1==e.touches.length)w.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);w.set(t,n)}}function handleTouchStartPan(e){if(1==e.touches.length)E.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);E.set(t,n)}}function handleTouchStartDolly(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(t*t+n*n);C.set(0,o)}function handleTouchStartDollyPan(e){n.enableZoom&&handleTouchStartDolly(e),n.enablePan&&handleTouchStartPan(e)}function handleTouchStartDollyRotate(e){n.enableZoom&&handleTouchStartDolly(e),n.enableRotate&&handleTouchStartRotate(e)}function handleTouchMoveRotate(e){if(1==e.touches.length)S.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);S.set(t,o)}T.subVectors(S,w).multiplyScalar(n.rotateSpeed);var c=n.domElement;rotateLeft(2*Math.PI*T.x/c.clientHeight),rotateUp(2*Math.PI*T.y/c.clientHeight),w.copy(S)}function handleTouchMovePan(e){if(1==e.touches.length)L.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),o=.5*(e.touches[0].pageY+e.touches[1].pageY);L.set(t,o)}A.subVectors(L,E).multiplyScalar(n.panSpeed),G(A.x,A.y),E.copy(L)}function handleTouchMoveDolly(e){var t=e.touches[0].pageX-e.touches[1].pageX,o=e.touches[0].pageY-e.touches[1].pageY,c=Math.sqrt(t*t+o*o);P.set(0,c),R.set(0,Math.pow(P.y/C.y,n.zoomSpeed)),dollyIn(R.y),C.copy(P)}function handleTouchMoveDollyPan(e){n.enableZoom&&handleTouchMoveDolly(e),n.enablePan&&handleTouchMovePan(e)}function handleTouchMoveDollyRotate(e){n.enableZoom&&handleTouchMoveDolly(e),n.enableRotate&&handleTouchMoveRotate(e)}function handleTouchEnd(){}function onMouseDown(e){if(!1!==n.enabled){switch(e.preventDefault(),n.domElement.focus?n.domElement.focus():window.focus(),e.button){case 0:switch(n.mouseButtons.LEFT){case o.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;handleMouseDownPan(e),m=p.PAN}else{if(!1===n.enableRotate)return;handleMouseDownRotate(e),m=p.ROTATE}break;case o.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;handleMouseDownRotate(e),m=p.ROTATE}else{if(!1===n.enablePan)return;handleMouseDownPan(e),m=p.PAN}break;default:m=p.NONE}break;case 1:switch(n.mouseButtons.MIDDLE){case o.MOUSE.DOLLY:if(!1===n.enableZoom)return;handleMouseDownDolly(e),m=p.DOLLY;break;default:m=p.NONE}break;case 2:switch(n.mouseButtons.RIGHT){case o.MOUSE.ROTATE:if(!1===n.enableRotate)return;handleMouseDownRotate(e),m=p.ROTATE;break;case o.MOUSE.PAN:if(!1===n.enablePan)return;handleMouseDownPan(e),m=p.PAN;break;default:m=p.NONE}break}m!==p.NONE&&(document.addEventListener("mousemove",onMouseMove,!1),document.addEventListener("mouseup",onMouseUp,!1),n.dispatchEvent(h))}}function onMouseMove(e){if(!1!==n.enabled)switch(e.preventDefault(),m){case p.ROTATE:if(!1===n.enableRotate)return;handleMouseMoveRotate(e);break;case p.DOLLY:if(!1===n.enableZoom)return;handleMouseMoveDolly(e);break;case p.PAN:if(!1===n.enablePan)return;handleMouseMovePan(e);break}}function onMouseUp(e){!1!==n.enabled&&(handleMouseUp(e),document.removeEventListener("mousemove",onMouseMove,!1),document.removeEventListener("mouseup",onMouseUp,!1),n.dispatchEvent(d),m=p.NONE)}function onMouseWheel(e){!1===n.enabled||!1===n.enableZoom||m!==p.NONE&&m!==p.ROTATE||(e.preventDefault(),e.stopPropagation(),n.dispatchEvent(h),handleMouseWheel(e),n.dispatchEvent(d))}function onKeyDown(e){!1!==n.enabled&&!1!==n.enableKeys&&!1!==n.enablePan&&handleKeyDown(e)}function onTouchStart(e){if(!1!==n.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(n.touches.ONE){case o.TOUCH.ROTATE:if(!1===n.enableRotate)return;handleTouchStartRotate(e),m=p.TOUCH_ROTATE;break;case o.TOUCH.PAN:if(!1===n.enablePan)return;handleTouchStartPan(e),m=p.TOUCH_PAN;break;default:m=p.NONE}break;case 2:switch(n.touches.TWO){case o.TOUCH.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;handleTouchStartDollyPan(e),m=p.TOUCH_DOLLY_PAN;break;case o.TOUCH.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;handleTouchStartDollyRotate(e),m=p.TOUCH_DOLLY_ROTATE;break;default:m=p.NONE}break;default:m=p.NONE}m!==p.NONE&&n.dispatchEvent(h)}}function onTouchMove(e){if(!1!==n.enabled)switch(e.preventDefault(),e.stopPropagation(),m){case p.TOUCH_ROTATE:if(!1===n.enableRotate)return;handleTouchMoveRotate(e),n.update();break;case p.TOUCH_PAN:if(!1===n.enablePan)return;handleTouchMovePan(e),n.update();break;case p.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;handleTouchMoveDollyPan(e),n.update();break;case p.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;handleTouchMoveDollyRotate(e),n.update();break;default:m=p.NONE}}function onTouchEnd(e){!1!==n.enabled&&(handleTouchEnd(e),n.dispatchEvent(d),m=p.NONE)}function onContextMenu(e){!1!==n.enabled&&e.preventDefault()}n.domElement.addEventListener("contextmenu",onContextMenu,!1),n.domElement.addEventListener("mousedown",onMouseDown,!1),n.domElement.addEventListener("wheel",onMouseWheel,!1),n.domElement.addEventListener("touchstart",onTouchStart,!1),n.domElement.addEventListener("touchend",onTouchEnd,!1),n.domElement.addEventListener("touchmove",onTouchMove,!1),n.domElement.addEventListener("keydown",onKeyDown,!1),-1===n.domElement.tabIndex&&(n.domElement.tabIndex=0),this.update()},o.OrbitControls.prototype=Object.create(o.EventDispatcher.prototype),o.OrbitControls.prototype.constructor=o.OrbitControls,o.MapControls=function(e,t){o.OrbitControls.call(this,e,t),this.mouseButtons.LEFT=o.MOUSE.PAN,this.mouseButtons.RIGHT=o.MOUSE.ROTATE,this.touches.ONE=o.TOUCH.PAN,this.touches.TWO=o.TOUCH.DOLLY_ROTATE},o.MapControls.prototype=Object.create(o.EventDispatcher.prototype),o.MapControls.prototype.constructor=o.MapControls,e.exports=t.default=o.OrbitControls},"./node_modules/three/build/three.module.js":function(e,t,n){"use strict";n.r(t),n.d(t,"ACESFilmicToneMapping",(function(){return ue})),n.d(t,"AddEquation",(function(){return D})),n.d(t,"AddOperation",(function(){return oe})),n.d(t,"AdditiveAnimationBlendMode",(function(){return en})),n.d(t,"AdditiveBlending",(function(){return C})),n.d(t,"AlphaFormat",(function(){return je})),n.d(t,"AlwaysDepth",(function(){return J})),n.d(t,"AlwaysStencilFunc",(function(){return Bn})),n.d(t,"AmbientLight",(function(){return AmbientLight})),n.d(t,"AmbientLightProbe",(function(){return AmbientLightProbe})),n.d(t,"AnimationClip",(function(){return AnimationClip})),n.d(t,"AnimationLoader",(function(){return AnimationLoader})),n.d(t,"AnimationMixer",(function(){return AnimationMixer})),n.d(t,"AnimationObjectGroup",(function(){return AnimationObjectGroup})),n.d(t,"AnimationUtils",(function(){return pc})),n.d(t,"ArcCurve",(function(){return ArcCurve})),n.d(t,"ArrayCamera",(function(){return ArrayCamera})),n.d(t,"ArrowHelper",(function(){return ArrowHelper})),n.d(t,"Audio",(function(){return Audio})),n.d(t,"AudioAnalyser",(function(){return AudioAnalyser})),n.d(t,"AudioContext",(function(){return Ac})),n.d(t,"AudioListener",(function(){return AudioListener})),n.d(t,"AudioLoader",(function(){return AudioLoader})),n.d(t,"AxesHelper",(function(){return AxesHelper})),n.d(t,"AxisHelper",(function(){return AxisHelper})),n.d(t,"BackSide",(function(){return w})),n.d(t,"BasicDepthPacking",(function(){return pn})),n.d(t,"BasicShadowMap",(function(){return y})),n.d(t,"BinaryTextureLoader",(function(){return BinaryTextureLoader})),n.d(t,"Bone",(function(){return Bone})),n.d(t,"BooleanKeyframeTrack",(function(){return BooleanKeyframeTrack})),n.d(t,"BoundingBoxHelper",(function(){return BoundingBoxHelper})),n.d(t,"Box2",(function(){return Box2})),n.d(t,"Box3",(function(){return Box3})),n.d(t,"Box3Helper",(function(){return Box3Helper})),n.d(t,"BoxBufferGeometry",(function(){return BoxBufferGeometry})),n.d(t,"BoxGeometry",(function(){return BoxGeometry})),n.d(t,"BoxHelper",(function(){return BoxHelper})),n.d(t,"BufferAttribute",(function(){return BufferAttribute})),n.d(t,"BufferGeometry",(function(){return BufferGeometry})),n.d(t,"BufferGeometryLoader",(function(){return BufferGeometryLoader})),n.d(t,"ByteType",(function(){return De})),n.d(t,"Cache",(function(){return fc})),n.d(t,"Camera",(function(){return Camera})),n.d(t,"CameraHelper",(function(){return CameraHelper})),n.d(t,"CanvasRenderer",(function(){return CanvasRenderer})),n.d(t,"CanvasTexture",(function(){return CanvasTexture})),n.d(t,"CatmullRomCurve3",(function(){return CatmullRomCurve3})),n.d(t,"CineonToneMapping",(function(){return le})),n.d(t,"CircleBufferGeometry",(function(){return CircleBufferGeometry})),n.d(t,"CircleGeometry",(function(){return CircleGeometry})),n.d(t,"ClampToEdgeWrapping",(function(){return be})),n.d(t,"Clock",(function(){return Clock})),n.d(t,"ClosedSplineCurve3",(function(){return ClosedSplineCurve3})),n.d(t,"Color",(function(){return Color})),n.d(t,"ColorKeyframeTrack",(function(){return ColorKeyframeTrack})),n.d(t,"CompressedTexture",(function(){return CompressedTexture})),n.d(t,"CompressedTextureLoader",(function(){return CompressedTextureLoader})),n.d(t,"ConeBufferGeometry",(function(){return ConeBufferGeometry})),n.d(t,"ConeGeometry",(function(){return ConeGeometry})),n.d(t,"CubeCamera",(function(){return CubeCamera})),n.d(t,"CubeGeometry",(function(){return BoxGeometry})),n.d(t,"CubeReflectionMapping",(function(){return pe})),n.d(t,"CubeRefractionMapping",(function(){return fe})),n.d(t,"CubeTexture",(function(){return CubeTexture})),n.d(t,"CubeTextureLoader",(function(){return CubeTextureLoader})),n.d(t,"CubeUVReflectionMapping",(function(){return ye})),n.d(t,"CubeUVRefractionMapping",(function(){return ve})),n.d(t,"CubicBezierCurve",(function(){return CubicBezierCurve})),n.d(t,"CubicBezierCurve3",(function(){return CubicBezierCurve3})),n.d(t,"CubicInterpolant",(function(){return CubicInterpolant})),n.d(t,"CullFaceBack",(function(){return p})),n.d(t,"CullFaceFront",(function(){return m})),n.d(t,"CullFaceFrontBack",(function(){return g})),n.d(t,"CullFaceNone",(function(){return d})),n.d(t,"Curve",(function(){return Curve})),n.d(t,"CurvePath",(function(){return CurvePath})),n.d(t,"CustomBlending",(function(){return B})),n.d(t,"CustomToneMapping",(function(){return he})),n.d(t,"CylinderBufferGeometry",(function(){return CylinderBufferGeometry})),n.d(t,"CylinderGeometry",(function(){return CylinderGeometry})),n.d(t,"Cylindrical",(function(){return Cylindrical})),n.d(t,"DataTexture",(function(){return DataTexture})),n.d(t,"DataTexture2DArray",(function(){return DataTexture2DArray})),n.d(t,"DataTexture3D",(function(){return DataTexture3D})),n.d(t,"DataTextureLoader",(function(){return DataTextureLoader})),n.d(t,"DecrementStencilOp",(function(){return Mn})),n.d(t,"DecrementWrapStencilOp",(function(){return wn})),n.d(t,"DefaultLoadingManager",(function(){return mc})),n.d(t,"DepthFormat",(function(){return Je})),n.d(t,"DepthStencilFormat",(function(){return Qe})),n.d(t,"DepthTexture",(function(){return DepthTexture})),n.d(t,"DirectionalLight",(function(){return DirectionalLight})),n.d(t,"DirectionalLightHelper",(function(){return DirectionalLightHelper})),n.d(t,"DiscreteInterpolant",(function(){return DiscreteInterpolant})),n.d(t,"DodecahedronBufferGeometry",(function(){return DodecahedronBufferGeometry})),n.d(t,"DodecahedronGeometry",(function(){return DodecahedronGeometry})),n.d(t,"DoubleSide",(function(){return S})),n.d(t,"DstAlphaFactor",(function(){return j})),n.d(t,"DstColorFactor",(function(){return q})),n.d(t,"DynamicBufferAttribute",(function(){return DynamicBufferAttribute})),n.d(t,"DynamicCopyUsage",(function(){return Un})),n.d(t,"DynamicDrawUsage",(function(){return Gn})),n.d(t,"DynamicReadUsage",(function(){return Vn})),n.d(t,"EdgesGeometry",(function(){return EdgesGeometry})),n.d(t,"EdgesHelper",(function(){return EdgesHelper})),n.d(t,"EllipseCurve",(function(){return EllipseCurve})),n.d(t,"EqualDepth",(function(){return $})),n.d(t,"EqualStencilFunc",(function(){return Ln})),n.d(t,"EquirectangularReflectionMapping",(function(){return me})),n.d(t,"EquirectangularRefractionMapping",(function(){return ge})),n.d(t,"Euler",(function(){return Euler})),n.d(t,"EventDispatcher",(function(){return EventDispatcher})),n.d(t,"ExtrudeBufferGeometry",(function(){return ExtrudeBufferGeometry})),n.d(t,"ExtrudeGeometry",(function(){return ExtrudeGeometry})),n.d(t,"Face3",(function(){return Face3})),n.d(t,"Face4",(function(){return Face4})),n.d(t,"FaceColors",(function(){return Bl})),n.d(t,"FileLoader",(function(){return FileLoader})),n.d(t,"FlatShading",(function(){return T})),n.d(t,"Float32Attribute",(function(){return Float32Attribute})),n.d(t,"Float32BufferAttribute",(function(){return Float32BufferAttribute})),n.d(t,"Float64Attribute",(function(){return Float64Attribute})),n.d(t,"Float64BufferAttribute",(function(){return Float64BufferAttribute})),n.d(t,"FloatType",(function(){return Ne})),n.d(t,"Fog",(function(){return Fog})),n.d(t,"FogExp2",(function(){return FogExp2})),n.d(t,"Font",(function(){return Font})),n.d(t,"FontLoader",(function(){return FontLoader})),n.d(t,"FrontSide",(function(){return _})),n.d(t,"Frustum",(function(){return Frustum})),n.d(t,"GLBufferAttribute",(function(){return GLBufferAttribute})),n.d(t,"GLSL1",(function(){return Hn})),n.d(t,"GLSL3",(function(){return kn})),n.d(t,"GammaEncoding",(function(){return sn})),n.d(t,"Geometry",(function(){return Geometry})),n.d(t,"GeometryUtils",(function(){return Gl})),n.d(t,"GreaterDepth",(function(){return te})),n.d(t,"GreaterEqualDepth",(function(){return ee})),n.d(t,"GreaterEqualStencilFunc",(function(){return Rn})),n.d(t,"GreaterStencilFunc",(function(){return Cn})),n.d(t,"GridHelper",(function(){return GridHelper})),n.d(t,"Group",(function(){return Group})),n.d(t,"HalfFloatType",(function(){return Fe})),n.d(t,"HemisphereLight",(function(){return HemisphereLight})),n.d(t,"HemisphereLightHelper",(function(){return HemisphereLightHelper})),n.d(t,"HemisphereLightProbe",(function(){return HemisphereLightProbe})),n.d(t,"IcosahedronBufferGeometry",(function(){return IcosahedronBufferGeometry})),n.d(t,"IcosahedronGeometry",(function(){return IcosahedronGeometry})),n.d(t,"ImageBitmapLoader",(function(){return ImageBitmapLoader})),n.d(t,"ImageLoader",(function(){return ImageLoader})),n.d(t,"ImageUtils",(function(){return Yn})),n.d(t,"ImmediateRenderObject",(function(){return ImmediateRenderObject})),n.d(t,"IncrementStencilOp",(function(){return bn})),n.d(t,"IncrementWrapStencilOp",(function(){return _n})),n.d(t,"InstancedBufferAttribute",(function(){return InstancedBufferAttribute})),n.d(t,"InstancedBufferGeometry",(function(){return InstancedBufferGeometry})),n.d(t,"InstancedInterleavedBuffer",(function(){return InstancedInterleavedBuffer})),n.d(t,"InstancedMesh",(function(){return InstancedMesh})),n.d(t,"Int16Attribute",(function(){return Int16Attribute})),n.d(t,"Int16BufferAttribute",(function(){return Int16BufferAttribute})),n.d(t,"Int32Attribute",(function(){return Int32Attribute})),n.d(t,"Int32BufferAttribute",(function(){return Int32BufferAttribute})),n.d(t,"Int8Attribute",(function(){return Int8Attribute})),n.d(t,"Int8BufferAttribute",(function(){return Int8BufferAttribute})),n.d(t,"IntType",(function(){return Oe})),n.d(t,"InterleavedBuffer",(function(){return InterleavedBuffer})),n.d(t,"InterleavedBufferAttribute",(function(){return InterleavedBufferAttribute})),n.d(t,"Interpolant",(function(){return Interpolant})),n.d(t,"InterpolateDiscrete",(function(){return Xt})),n.d(t,"InterpolateLinear",(function(){return Yt})),n.d(t,"InterpolateSmooth",(function(){return Zt})),n.d(t,"InvertStencilOp",(function(){return Sn})),n.d(t,"JSONLoader",(function(){return JSONLoader})),n.d(t,"KeepStencilOp",(function(){return vn})),n.d(t,"KeyframeTrack",(function(){return KeyframeTrack})),n.d(t,"LOD",(function(){return LOD})),n.d(t,"LatheBufferGeometry",(function(){return LatheBufferGeometry})),n.d(t,"LatheGeometry",(function(){return LatheGeometry})),n.d(t,"Layers",(function(){return Layers})),n.d(t,"LensFlare",(function(){return LensFlare})),n.d(t,"LessDepth",(function(){return Q})),n.d(t,"LessEqualDepth",(function(){return K})),n.d(t,"LessEqualStencilFunc",(function(){return An})),n.d(t,"LessStencilFunc",(function(){return En})),n.d(t,"Light",(function(){return Light})),n.d(t,"LightProbe",(function(){return LightProbe})),n.d(t,"LightShadow",(function(){return LightShadow})),n.d(t,"Line",(function(){return Line})),n.d(t,"Line3",(function(){return Line3})),n.d(t,"LineBasicMaterial",(function(){return LineBasicMaterial})),n.d(t,"LineCurve",(function(){return LineCurve})),n.d(t,"LineCurve3",(function(){return LineCurve3})),n.d(t,"LineDashedMaterial",(function(){return LineDashedMaterial})),n.d(t,"LineLoop",(function(){return LineLoop})),n.d(t,"LinePieces",(function(){return Pl})),n.d(t,"LineSegments",(function(){return LineSegments})),n.d(t,"LineStrip",(function(){return Cl})),n.d(t,"LinearEncoding",(function(){return on})),n.d(t,"LinearFilter",(function(){return Le})),n.d(t,"LinearInterpolant",(function(){return LinearInterpolant})),n.d(t,"LinearMipMapLinearFilter",(function(){return Re})),n.d(t,"LinearMipMapNearestFilter",(function(){return Ce})),n.d(t,"LinearMipmapLinearFilter",(function(){return Pe})),n.d(t,"LinearMipmapNearestFilter",(function(){return Ae})),n.d(t,"LinearToneMapping",(function(){return se})),n.d(t,"Loader",(function(){return Loader})),n.d(t,"LoaderUtils",(function(){return _c})),n.d(t,"LoadingManager",(function(){return LoadingManager})),n.d(t,"LogLuvEncoding",(function(){return ln})),n.d(t,"LoopOnce",(function(){return jt})),n.d(t,"LoopPingPong",(function(){return qt})),n.d(t,"LoopRepeat",(function(){return Wt})),n.d(t,"LuminanceAlphaFormat",(function(){return Ye})),n.d(t,"LuminanceFormat",(function(){return Xe})),n.d(t,"MOUSE",(function(){return c})),n.d(t,"Material",(function(){return Material})),n.d(t,"MaterialLoader",(function(){return MaterialLoader})),n.d(t,"Math",(function(){return qn})),n.d(t,"MathUtils",(function(){return qn})),n.d(t,"Matrix3",(function(){return Matrix3})),n.d(t,"Matrix4",(function(){return Matrix4})),n.d(t,"MaxEquation",(function(){return V})),n.d(t,"Mesh",(function(){return Mesh})),n.d(t,"MeshBasicMaterial",(function(){return MeshBasicMaterial})),n.d(t,"MeshDepthMaterial",(function(){return MeshDepthMaterial})),n.d(t,"MeshDistanceMaterial",(function(){return MeshDistanceMaterial})),n.d(t,"MeshFaceMaterial",(function(){return MeshFaceMaterial})),n.d(t,"MeshLambertMaterial",(function(){return MeshLambertMaterial})),n.d(t,"MeshMatcapMaterial",(function(){return MeshMatcapMaterial})),n.d(t,"MeshNormalMaterial",(function(){return MeshNormalMaterial})),n.d(t,"MeshPhongMaterial",(function(){return MeshPhongMaterial})),n.d(t,"MeshPhysicalMaterial",(function(){return MeshPhysicalMaterial})),n.d(t,"MeshStandardMaterial",(function(){return MeshStandardMaterial})),n.d(t,"MeshToonMaterial",(function(){return MeshToonMaterial})),n.d(t,"MinEquation",(function(){return O})),n.d(t,"MirroredRepeatWrapping",(function(){return Me})),n.d(t,"MixOperation",(function(){return ie})),n.d(t,"MultiMaterial",(function(){return MultiMaterial})),n.d(t,"MultiplyBlending",(function(){return R})),n.d(t,"MultiplyOperation",(function(){return re})),n.d(t,"NearestFilter",(function(){return _e})),n.d(t,"NearestMipMapLinearFilter",(function(){return Ee})),n.d(t,"NearestMipMapNearestFilter",(function(){return Se})),n.d(t,"NearestMipmapLinearFilter",(function(){return Te})),n.d(t,"NearestMipmapNearestFilter",(function(){return we})),n.d(t,"NeverDepth",(function(){return Z})),n.d(t,"NeverStencilFunc",(function(){return Tn})),n.d(t,"NoBlending",(function(){return L})),n.d(t,"NoColors",(function(){return Rl})),n.d(t,"NoToneMapping",(function(){return ae})),n.d(t,"NormalAnimationBlendMode",(function(){return $t})),n.d(t,"NormalBlending",(function(){return A})),n.d(t,"NotEqualDepth",(function(){return ne})),n.d(t,"NotEqualStencilFunc",(function(){return Pn})),n.d(t,"NumberKeyframeTrack",(function(){return NumberKeyframeTrack})),n.d(t,"Object3D",(function(){return Object3D})),n.d(t,"ObjectLoader",(function(){return ObjectLoader})),n.d(t,"ObjectSpaceNormalMap",(function(){return gn})),n.d(t,"OctahedronBufferGeometry",(function(){return OctahedronBufferGeometry})),n.d(t,"OctahedronGeometry",(function(){return OctahedronGeometry})),n.d(t,"OneFactor",(function(){return F})),n.d(t,"OneMinusDstAlphaFactor",(function(){return W})),n.d(t,"OneMinusDstColorFactor",(function(){return X})),n.d(t,"OneMinusSrcAlphaFactor",(function(){return k})),n.d(t,"OneMinusSrcColorFactor",(function(){return z})),n.d(t,"OrthographicCamera",(function(){return OrthographicCamera})),n.d(t,"PCFShadowMap",(function(){return x})),n.d(t,"PCFSoftShadowMap",(function(){return b})),n.d(t,"PMREMGenerator",(function(){return PMREMGenerator})),n.d(t,"ParametricBufferGeometry",(function(){return ParametricBufferGeometry})),n.d(t,"ParametricGeometry",(function(){return ParametricGeometry})),n.d(t,"Particle",(function(){return Particle})),n.d(t,"ParticleBasicMaterial",(function(){return ParticleBasicMaterial})),n.d(t,"ParticleSystem",(function(){return ParticleSystem})),n.d(t,"ParticleSystemMaterial",(function(){return ParticleSystemMaterial})),n.d(t,"Path",(function(){return Path})),n.d(t,"PerspectiveCamera",(function(){return PerspectiveCamera})),n.d(t,"Plane",(function(){return Plane})),n.d(t,"PlaneBufferGeometry",(function(){return PlaneBufferGeometry})),n.d(t,"PlaneGeometry",(function(){return PlaneGeometry})),n.d(t,"PlaneHelper",(function(){return PlaneHelper})),n.d(t,"PointCloud",(function(){return PointCloud})),n.d(t,"PointCloudMaterial",(function(){return PointCloudMaterial})),n.d(t,"PointLight",(function(){return PointLight})),n.d(t,"PointLightHelper",(function(){return PointLightHelper})),n.d(t,"Points",(function(){return Points})),n.d(t,"PointsMaterial",(function(){return PointsMaterial})),n.d(t,"PolarGridHelper",(function(){return PolarGridHelper})),n.d(t,"PolyhedronBufferGeometry",(function(){return PolyhedronBufferGeometry})),n.d(t,"PolyhedronGeometry",(function(){return PolyhedronGeometry})),n.d(t,"PositionalAudio",(function(){return PositionalAudio})),n.d(t,"PropertyBinding",(function(){return PropertyBinding})),n.d(t,"PropertyMixer",(function(){return PropertyMixer})),n.d(t,"QuadraticBezierCurve",(function(){return QuadraticBezierCurve})),n.d(t,"QuadraticBezierCurve3",(function(){return QuadraticBezierCurve3})),n.d(t,"Quaternion",(function(){return Quaternion})),n.d(t,"QuaternionKeyframeTrack",(function(){return QuaternionKeyframeTrack})),n.d(t,"QuaternionLinearInterpolant",(function(){return QuaternionLinearInterpolant})),n.d(t,"REVISION",(function(){return o})),n.d(t,"RGBADepthPacking",(function(){return fn})),n.d(t,"RGBAFormat",(function(){return qe})),n.d(t,"RGBAIntegerFormat",(function(){return rt})),n.d(t,"RGBA_ASTC_10x10_Format",(function(){return Et})),n.d(t,"RGBA_ASTC_10x5_Format",(function(){return wt})),n.d(t,"RGBA_ASTC_10x6_Format",(function(){return St})),n.d(t,"RGBA_ASTC_10x8_Format",(function(){return Tt})),n.d(t,"RGBA_ASTC_12x10_Format",(function(){return Lt})),n.d(t,"RGBA_ASTC_12x12_Format",(function(){return At})),n.d(t,"RGBA_ASTC_4x4_Format",(function(){return mt})),n.d(t,"RGBA_ASTC_5x4_Format",(function(){return gt})),n.d(t,"RGBA_ASTC_5x5_Format",(function(){return yt})),n.d(t,"RGBA_ASTC_6x5_Format",(function(){return vt})),n.d(t,"RGBA_ASTC_6x6_Format",(function(){return xt})),n.d(t,"RGBA_ASTC_8x5_Format",(function(){return bt})),n.d(t,"RGBA_ASTC_8x6_Format",(function(){return Mt})),n.d(t,"RGBA_ASTC_8x8_Format",(function(){return _t})),n.d(t,"RGBA_BPTC_Format",(function(){return Ct})),n.d(t,"RGBA_ETC2_EAC_Format",(function(){return ft})),n.d(t,"RGBA_PVRTC_2BPPV1_Format",(function(){return ht})),n.d(t,"RGBA_PVRTC_4BPPV1_Format",(function(){return ut})),n.d(t,"RGBA_S3TC_DXT1_Format",(function(){return ot})),n.d(t,"RGBA_S3TC_DXT3_Format",(function(){return at})),n.d(t,"RGBA_S3TC_DXT5_Format",(function(){return st})),n.d(t,"RGBDEncoding",(function(){return dn})),n.d(t,"RGBEEncoding",(function(){return cn})),n.d(t,"RGBEFormat",(function(){return Ze})),n.d(t,"RGBFormat",(function(){return We})),n.d(t,"RGBIntegerFormat",(function(){return nt})),n.d(t,"RGBM16Encoding",(function(){return hn})),n.d(t,"RGBM7Encoding",(function(){return un})),n.d(t,"RGB_ETC1_Format",(function(){return dt})),n.d(t,"RGB_ETC2_Format",(function(){return pt})),n.d(t,"RGB_PVRTC_2BPPV1_Format",(function(){return lt})),n.d(t,"RGB_PVRTC_4BPPV1_Format",(function(){return ct})),n.d(t,"RGB_S3TC_DXT1_Format",(function(){return it})),n.d(t,"RGFormat",(function(){return et})),n.d(t,"RGIntegerFormat",(function(){return tt})),n.d(t,"RawShaderMaterial",(function(){return RawShaderMaterial})),n.d(t,"Ray",(function(){return Ray})),n.d(t,"Raycaster",(function(){return Raycaster})),n.d(t,"RectAreaLight",(function(){return RectAreaLight})),n.d(t,"RedFormat",(function(){return Ke})),n.d(t,"RedIntegerFormat",(function(){return $e})),n.d(t,"ReinhardToneMapping",(function(){return ce})),n.d(t,"RepeatWrapping",(function(){return xe})),n.d(t,"ReplaceStencilOp",(function(){return xn})),n.d(t,"ReverseSubtractEquation",(function(){return I})),n.d(t,"RingBufferGeometry",(function(){return RingBufferGeometry})),n.d(t,"RingGeometry",(function(){return RingGeometry})),n.d(t,"SRGB8_ALPHA8_ASTC_10x10_Format",(function(){return zt})),n.d(t,"SRGB8_ALPHA8_ASTC_10x5_Format",(function(){return Nt})),n.d(t,"SRGB8_ALPHA8_ASTC_10x6_Format",(function(){return Ft})),n.d(t,"SRGB8_ALPHA8_ASTC_10x8_Format",(function(){return Ut})),n.d(t,"SRGB8_ALPHA8_ASTC_12x10_Format",(function(){return Ht})),n.d(t,"SRGB8_ALPHA8_ASTC_12x12_Format",(function(){return kt})),n.d(t,"SRGB8_ALPHA8_ASTC_4x4_Format",(function(){return Pt})),n.d(t,"SRGB8_ALPHA8_ASTC_5x4_Format",(function(){return Rt})),n.d(t,"SRGB8_ALPHA8_ASTC_5x5_Format",(function(){return Bt})),n.d(t,"SRGB8_ALPHA8_ASTC_6x5_Format",(function(){return Dt})),n.d(t,"SRGB8_ALPHA8_ASTC_6x6_Format",(function(){return Gt})),n.d(t,"SRGB8_ALPHA8_ASTC_8x5_Format",(function(){return It})),n.d(t,"SRGB8_ALPHA8_ASTC_8x6_Format",(function(){return Ot})),n.d(t,"SRGB8_ALPHA8_ASTC_8x8_Format",(function(){return Vt})),n.d(t,"Scene",(function(){return Scene})),n.d(t,"SceneUtils",(function(){return Il})),n.d(t,"ShaderChunk",(function(){return ls})),n.d(t,"ShaderLib",(function(){return hs})),n.d(t,"ShaderMaterial",(function(){return ShaderMaterial})),n.d(t,"ShadowMaterial",(function(){return ShadowMaterial})),n.d(t,"Shape",(function(){return Shape})),n.d(t,"ShapeBufferGeometry",(function(){return ShapeBufferGeometry})),n.d(t,"ShapeGeometry",(function(){return ShapeGeometry})),n.d(t,"ShapePath",(function(){return ShapePath})),n.d(t,"ShapeUtils",(function(){return lc})),n.d(t,"ShortType",(function(){return Ge})),n.d(t,"Skeleton",(function(){return Skeleton})),n.d(t,"SkeletonHelper",(function(){return SkeletonHelper})),n.d(t,"SkinnedMesh",(function(){return SkinnedMesh})),n.d(t,"SmoothShading",(function(){return E})),n.d(t,"Sphere",(function(){return Sphere})),n.d(t,"SphereBufferGeometry",(function(){return SphereBufferGeometry})),n.d(t,"SphereGeometry",(function(){return SphereGeometry})),n.d(t,"Spherical",(function(){return Spherical})),n.d(t,"SphericalHarmonics3",(function(){return SphericalHarmonics3})),n.d(t,"Spline",(function(){return Spline})),n.d(t,"SplineCurve",(function(){return SplineCurve})),n.d(t,"SplineCurve3",(function(){return SplineCurve3})),n.d(t,"SpotLight",(function(){return SpotLight})),n.d(t,"SpotLightHelper",(function(){return SpotLightHelper})),n.d(t,"Sprite",(function(){return Sprite})),n.d(t,"SpriteMaterial",(function(){return SpriteMaterial})),n.d(t,"SrcAlphaFactor",(function(){return H})),n.d(t,"SrcAlphaSaturateFactor",(function(){return Y})),n.d(t,"SrcColorFactor",(function(){return U})),n.d(t,"StaticCopyUsage",(function(){return Fn})),n.d(t,"StaticDrawUsage",(function(){return Dn})),n.d(t,"StaticReadUsage",(function(){return On})),n.d(t,"StereoCamera",(function(){return StereoCamera})),n.d(t,"StreamCopyUsage",(function(){return zn})),n.d(t,"StreamDrawUsage",(function(){return In})),n.d(t,"StreamReadUsage",(function(){return Nn})),n.d(t,"StringKeyframeTrack",(function(){return StringKeyframeTrack})),n.d(t,"SubtractEquation",(function(){return G})),n.d(t,"SubtractiveBlending",(function(){return P})),n.d(t,"TOUCH",(function(){return h})),n.d(t,"TangentSpaceNormalMap",(function(){return mn})),n.d(t,"TetrahedronBufferGeometry",(function(){return TetrahedronBufferGeometry})),n.d(t,"TetrahedronGeometry",(function(){return TetrahedronGeometry})),n.d(t,"TextBufferGeometry",(function(){return TextBufferGeometry})),n.d(t,"TextGeometry",(function(){return TextGeometry})),n.d(t,"Texture",(function(){return Texture})),n.d(t,"TextureLoader",(function(){return TextureLoader})),n.d(t,"TorusBufferGeometry",(function(){return TorusBufferGeometry})),n.d(t,"TorusGeometry",(function(){return TorusGeometry})),n.d(t,"TorusKnotBufferGeometry",(function(){return TorusKnotBufferGeometry})),n.d(t,"TorusKnotGeometry",(function(){return TorusKnotGeometry})),n.d(t,"Triangle",(function(){return Triangle})),n.d(t,"TriangleFanDrawMode",(function(){return rn})),n.d(t,"TriangleStripDrawMode",(function(){return nn})),n.d(t,"TrianglesDrawMode",(function(){return tn})),n.d(t,"TubeBufferGeometry",(function(){return TubeBufferGeometry})),n.d(t,"TubeGeometry",(function(){return TubeGeometry})),n.d(t,"UVMapping",(function(){return de})),n.d(t,"Uint16Attribute",(function(){return Uint16Attribute})),n.d(t,"Uint16BufferAttribute",(function(){return Uint16BufferAttribute})),n.d(t,"Uint32Attribute",(function(){return Uint32Attribute})),n.d(t,"Uint32BufferAttribute",(function(){return Uint32BufferAttribute})),n.d(t,"Uint8Attribute",(function(){return Uint8Attribute})),n.d(t,"Uint8BufferAttribute",(function(){return Uint8BufferAttribute})),n.d(t,"Uint8ClampedAttribute",(function(){return Uint8ClampedAttribute})),n.d(t,"Uint8ClampedBufferAttribute",(function(){return Uint8ClampedBufferAttribute})),n.d(t,"Uniform",(function(){return Uniform})),n.d(t,"UniformsLib",(function(){return us})),n.d(t,"UniformsUtils",(function(){return Gi})),n.d(t,"UnsignedByteType",(function(){return Be})),n.d(t,"UnsignedInt248Type",(function(){return ke})),n.d(t,"UnsignedIntType",(function(){return Ve})),n.d(t,"UnsignedShort4444Type",(function(){return Ue})),n.d(t,"UnsignedShort5551Type",(function(){return ze})),n.d(t,"UnsignedShort565Type",(function(){return He})),n.d(t,"UnsignedShortType",(function(){return Ie})),n.d(t,"VSMShadowMap",(function(){return M})),n.d(t,"Vector2",(function(){return Vector2})),n.d(t,"Vector3",(function(){return Vector3})),n.d(t,"Vector4",(function(){return Vector4})),n.d(t,"VectorKeyframeTrack",(function(){return VectorKeyframeTrack})),n.d(t,"Vertex",(function(){return Vertex})),n.d(t,"VertexColors",(function(){return Dl})),n.d(t,"VideoTexture",(function(){return VideoTexture})),n.d(t,"WebGL1Renderer",(function(){return WebGL1Renderer})),n.d(t,"WebGLCubeRenderTarget",(function(){return WebGLCubeRenderTarget})),n.d(t,"WebGLMultisampleRenderTarget",(function(){return WebGLMultisampleRenderTarget})),n.d(t,"WebGLRenderTarget",(function(){return WebGLRenderTarget})),n.d(t,"WebGLRenderTargetCube",(function(){return WebGLRenderTargetCube})),n.d(t,"WebGLRenderer",(function(){return WebGLRenderer})),n.d(t,"WebGLUtils",(function(){return WebGLUtils})),n.d(t,"WireframeGeometry",(function(){return WireframeGeometry})),n.d(t,"WireframeHelper",(function(){return WireframeHelper})),n.d(t,"WrapAroundEnding",(function(){return Kt})),n.d(t,"XHRLoader",(function(){return XHRLoader})),n.d(t,"ZeroCurvatureEnding",(function(){return Jt})),n.d(t,"ZeroFactor",(function(){return N})),n.d(t,"ZeroSlopeEnding",(function(){return Qt})),n.d(t,"ZeroStencilOp",(function(){return yn})),n.d(t,"sRGBEncoding",(function(){return an})),void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Number.isInteger&&(Number.isInteger=function(e){return"number"===typeof e&&isFinite(e)&&Math.floor(e)===e}),void 0===Math.sign&&(Math.sign=function(e){return e<0?-1:e>0?1:+e}),"name"in Function.prototype===!1&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),void 0===Object.assign&&(Object.assign=function(e){if(void 0===e||null===e)throw new TypeError("Cannot convert undefined or null to object");const t=Object(e);for(let n=1;n<arguments.length;n++){const e=arguments[n];if(void 0!==e&&null!==e)for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])}return t});const o="120",c={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},h={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},d=0,p=1,m=2,g=3,y=0,x=1,b=2,M=3,_=0,w=1,S=2,T=1,E=2,L=0,A=1,C=2,P=3,R=4,B=5,D=100,G=101,I=102,O=103,V=104,N=200,F=201,U=202,z=203,H=204,k=205,j=206,W=207,q=208,X=209,Y=210,Z=0,J=1,Q=2,K=3,$=4,ee=5,te=6,ne=7,re=0,ie=1,oe=2,ae=0,se=1,ce=2,le=3,ue=4,he=5,de=300,pe=301,fe=302,me=303,ge=304,ye=306,ve=307,xe=1e3,be=1001,Me=1002,_e=1003,we=1004,Se=1004,Te=1005,Ee=1005,Le=1006,Ae=1007,Ce=1007,Pe=1008,Re=1008,Be=1009,De=1010,Ge=1011,Ie=1012,Oe=1013,Ve=1014,Ne=1015,Fe=1016,Ue=1017,ze=1018,He=1019,ke=1020,je=1021,We=1022,qe=1023,Xe=1024,Ye=1025,Ze=qe,Je=1026,Qe=1027,Ke=1028,$e=1029,et=1030,tt=1031,nt=1032,rt=1033,it=33776,ot=33777,at=33778,st=33779,ct=35840,lt=35841,ut=35842,ht=35843,dt=36196,pt=37492,ft=37496,mt=37808,gt=37809,yt=37810,vt=37811,xt=37812,bt=37813,Mt=37814,_t=37815,wt=37816,St=37817,Tt=37818,Et=37819,Lt=37820,At=37821,Ct=36492,Pt=37840,Rt=37841,Bt=37842,Dt=37843,Gt=37844,It=37845,Ot=37846,Vt=37847,Nt=37848,Ft=37849,Ut=37850,zt=37851,Ht=37852,kt=37853,jt=2200,Wt=2201,qt=2202,Xt=2300,Yt=2301,Zt=2302,Jt=2400,Qt=2401,Kt=2402,$t=2500,en=2501,tn=0,nn=1,rn=2,on=3e3,an=3001,sn=3007,cn=3002,ln=3003,un=3004,hn=3005,dn=3006,pn=3200,fn=3201,mn=0,gn=1,yn=0,vn=7680,xn=7681,bn=7682,Mn=7683,_n=34055,wn=34056,Sn=5386,Tn=512,En=513,Ln=514,An=515,Cn=516,Pn=517,Rn=518,Bn=519,Dn=35044,Gn=35048,In=35040,On=35045,Vn=35049,Nn=35041,Fn=35046,Un=35050,zn=35042,Hn="100",kn="300 es";function EventDispatcher(){}Object.assign(EventDispatcher.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)},removeEventListener:function(e,t){if(void 0===this._listeners)return;const n=this._listeners,o=n[e];if(void 0!==o){const e=o.indexOf(t);-1!==e&&o.splice(e,1)}},dispatchEvent:function(e){if(void 0===this._listeners)return;const t=this._listeners,n=t[e.type];if(void 0!==n){e.target=this;const t=n.slice(0);for(let n=0,o=t.length;n<o;n++)t[n].call(this,e)}}});const jn=[];for(let Ol=0;Ol<256;Ol++)jn[Ol]=(Ol<16?"0":"")+Ol.toString(16);let Wn=1234567;const qn={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,o=4294967295*Math.random()|0,c=jn[255&e]+jn[e>>8&255]+jn[e>>16&255]+jn[e>>24&255]+"-"+jn[255&t]+jn[t>>8&255]+"-"+jn[t>>16&15|64]+jn[t>>24&255]+"-"+jn[63&n|128]+jn[n>>8&255]+"-"+jn[n>>16&255]+jn[n>>24&255]+jn[255&o]+jn[o>>8&255]+jn[o>>16&255]+jn[o>>24&255];return c.toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,o,c){return o+(e-t)*(c-o)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*(3-2*e))},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*e*(e*(6*e-15)+10))},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return void 0!==e&&(Wn=e%2147483647),Wn=16807*Wn%2147483647,(Wn-1)/2147483646},degToRad:function(e){return e*qn.DEG2RAD},radToDeg:function(e){return e*qn.RAD2DEG},isPowerOfTwo:function(e){return 0===(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,o,c){const h=Math.cos,d=Math.sin,p=h(n/2),m=d(n/2),g=h((t+o)/2),y=d((t+o)/2),x=h((t-o)/2),b=d((t-o)/2),M=h((o-t)/2),_=d((o-t)/2);switch(c){case"XYX":e.set(p*y,m*x,m*b,p*g);break;case"YZY":e.set(m*b,p*y,m*x,p*g);break;case"ZXZ":e.set(m*x,m*b,p*y,p*g);break;case"XZX":e.set(p*y,m*_,m*M,p*g);break;case"YXY":e.set(m*M,p*y,m*_,p*g);break;case"ZYZ":e.set(m*_,m*M,p*y,p*g);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+c)}}};class Vector2{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6],this.y=o[1]*t+o[4]*n+o[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const e=Math.atan2(-this.y,-this.x)+Math.PI;return e}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),o=Math.sin(t),c=this.x-e.x,h=this.y-e.y;return this.x=c*n-h*o+e.x,this.y=c*o+h*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class Matrix3{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,o,c,h,d,p,m){const g=this.elements;return g[0]=e,g[1]=o,g[2]=d,g[3]=t,g[4]=c,g[5]=p,g[6]=n,g[7]=h,g[8]=m,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return(new this.constructor).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,o=t.elements,c=this.elements,h=n[0],d=n[3],p=n[6],m=n[1],g=n[4],y=n[7],x=n[2],b=n[5],M=n[8],_=o[0],w=o[3],S=o[6],T=o[1],E=o[4],L=o[7],A=o[2],C=o[5],P=o[8];return c[0]=h*_+d*T+p*A,c[3]=h*w+d*E+p*C,c[6]=h*S+d*L+p*P,c[1]=m*_+g*T+y*A,c[4]=m*w+g*E+y*C,c[7]=m*S+g*L+y*P,c[2]=x*_+b*T+M*A,c[5]=x*w+b*E+M*C,c[8]=x*S+b*L+M*P,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],o=e[2],c=e[3],h=e[4],d=e[5],p=e[6],m=e[7],g=e[8];return t*h*g-t*d*m-n*c*g+n*d*p+o*c*m-o*h*p}getInverse(e,t){void 0!==t&&console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");const n=e.elements,o=this.elements,c=n[0],h=n[1],d=n[2],p=n[3],m=n[4],g=n[5],y=n[6],x=n[7],b=n[8],M=b*m-g*x,_=g*y-b*p,w=x*p-m*y,S=c*M+h*_+d*w;if(0===S)return this.set(0,0,0,0,0,0,0,0,0);const T=1/S;return o[0]=M*T,o[1]=(d*x-b*h)*T,o[2]=(g*h-d*m)*T,o[3]=_*T,o[4]=(b*c-d*y)*T,o[5]=(d*p-g*c)*T,o[6]=w*T,o[7]=(h*y-x*c)*T,o[8]=(m*c-h*p)*T,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).getInverse(this).transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,o,c,h,d){const p=Math.cos(c),m=Math.sin(c);this.set(n*p,n*m,-n*(p*h+m*d)+h+e,-o*m,o*p,-o*(-m*h+p*d)+d+t,0,0,1)}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),o=this.elements,c=o[0],h=o[3],d=o[6],p=o[1],m=o[4],g=o[7];return o[0]=t*c+n*p,o[3]=t*h+n*m,o[6]=t*d+n*g,o[1]=-n*c+t*p,o[4]=-n*h+t*m,o[7]=-n*d+t*g,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let o=0;o<9;o++)if(t[o]!==n[o])return!1;return!0}fromArray(e,t){void 0===t&&(t=0);for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}}let Xn;const Yn={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===Xn&&(Xn=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Xn.width=e.width,Xn.height=e.height;const n=Xn.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Xn}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let Zn=0;function Texture(e,t,n,o,c,h,d,p,m,g){Object.defineProperty(this,"id",{value:Zn++}),this.uuid=qn.generateUUID(),this.name="",this.image=void 0!==e?e:Texture.DEFAULT_IMAGE,this.mipmaps=[],this.mapping=void 0!==t?t:Texture.DEFAULT_MAPPING,this.wrapS=void 0!==n?n:be,this.wrapT=void 0!==o?o:be,this.magFilter=void 0!==c?c:Le,this.minFilter=void 0!==h?h:Pe,this.anisotropy=void 0!==m?m:1,this.format=void 0!==d?d:qe,this.internalFormat=null,this.type=void 0!==p?p:Be,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=void 0!==g?g:on,this.version=0,this.onUpdate=null}Texture.DEFAULT_IMAGE=void 0,Texture.DEFAULT_MAPPING=de,Texture.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Texture,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=void 0===e||"string"===typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const o=this.image;if(void 0===o.uuid&&(o.uuid=qn.generateUUID()),!t&&void 0===e.images[o.uuid]){let t;if(Array.isArray(o)){t=[];for(let e=0,n=o.length;e<n;e++)t.push(Yn.getDataURL(o[e]))}else t=Yn.getDataURL(o);e.images[o.uuid]={uuid:o.uuid,url:t}}n.image=o.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==de)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case xe:e.x=e.x-Math.floor(e.x);break;case be:e.x=e.x<0?0:1;break;case Me:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case xe:e.y=e.y-Math.floor(e.y);break;case be:e.y=e.y<0?0:1;break;case Me:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(Texture.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}});class Vector4{constructor(e=0,t=0,n=0,o=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=n,this.w=o}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,o){return this.x=e,this.y=t,this.z=n,this.w=o,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,o=this.z,c=this.w,h=e.elements;return this.x=h[0]*t+h[4]*n+h[8]*o+h[12]*c,this.y=h[1]*t+h[5]*n+h[9]*o+h[13]*c,this.z=h[2]*t+h[6]*n+h[10]*o+h[14]*c,this.w=h[3]*t+h[7]*n+h[11]*o+h[15]*c,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,o,c;const h=.01,d=.1,p=e.elements,m=p[0],g=p[4],y=p[8],x=p[1],b=p[5],M=p[9],_=p[2],w=p[6],S=p[10];if(Math.abs(g-x)<h&&Math.abs(y-_)<h&&Math.abs(M-w)<h){if(Math.abs(g+x)<d&&Math.abs(y+_)<d&&Math.abs(M+w)<d&&Math.abs(m+b+S-3)<d)return this.set(1,0,0,0),this;t=Math.PI;const e=(m+1)/2,p=(b+1)/2,T=(S+1)/2,E=(g+x)/4,L=(y+_)/4,A=(M+w)/4;return e>p&&e>T?e<h?(n=0,o=.707106781,c=.707106781):(n=Math.sqrt(e),o=E/n,c=L/n):p>T?p<h?(n=.707106781,o=0,c=.707106781):(o=Math.sqrt(p),n=E/o,c=A/o):T<h?(n=.707106781,o=.707106781,c=0):(c=Math.sqrt(T),n=L/c,o=A/c),this.set(n,o,c,t),this}let T=Math.sqrt((w-M)*(w-M)+(y-_)*(y-_)+(x-g)*(x-g));return Math.abs(T)<.001&&(T=1),this.x=(w-M)/T,this.y=(y-_)/T,this.z=(x-g)/T,this.w=Math.acos((m+b+S-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}function WebGLRenderTarget(e,t,n){this.width=e,this.height=t,this.scissor=new Vector4(0,0,e,t),this.scissorTest=!1,this.viewport=new Vector4(0,0,e,t),n=n||{},this.texture=new Texture(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:Le,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}function WebGLMultisampleRenderTarget(e,t,n){WebGLRenderTarget.call(this,e,t,n),this.samples=4}WebGLRenderTarget.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:WebGLRenderTarget,isWebGLRenderTarget:!0,setSize:function(e,t){this.width===e&&this.height===t||(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),WebGLMultisampleRenderTarget.prototype=Object.assign(Object.create(WebGLRenderTarget.prototype),{constructor:WebGLMultisampleRenderTarget,isWebGLMultisampleRenderTarget:!0,copy:function(e){return WebGLRenderTarget.prototype.copy.call(this,e),this.samples=e.samples,this}});class Quaternion{constructor(e=0,t=0,n=0,o=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=n,this._w=o}static slerp(e,t,n,o){return n.copy(e).slerp(t,o)}static slerpFlat(e,t,n,o,c,h,d){let p=n[o+0],m=n[o+1],g=n[o+2],y=n[o+3];const x=c[h+0],b=c[h+1],M=c[h+2],_=c[h+3];if(y!==_||p!==x||m!==b||g!==M){let e=1-d;const t=p*x+m*b+g*M+y*_,n=t>=0?1:-1,o=1-t*t;if(o>Number.EPSILON){const c=Math.sqrt(o),h=Math.atan2(c,t*n);e=Math.sin(e*h)/c,d=Math.sin(d*h)/c}const c=d*n;if(p=p*e+x*c,m=m*e+b*c,g=g*e+M*c,y=y*e+_*c,e===1-d){const e=1/Math.sqrt(p*p+m*m+g*g+y*y);p*=e,m*=e,g*=e,y*=e}}e[t]=p,e[t+1]=m,e[t+2]=g,e[t+3]=y}static multiplyQuaternionsFlat(e,t,n,o,c,h){const d=n[o],p=n[o+1],m=n[o+2],g=n[o+3],y=c[h],x=c[h+1],b=c[h+2],M=c[h+3];return e[t]=d*M+g*y+p*b-m*x,e[t+1]=p*M+g*x+m*y-d*b,e[t+2]=m*M+g*b+d*x-p*y,e[t+3]=g*M-d*y-p*x-m*b,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._w=o,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,o=e._y,c=e._z,h=e._order,d=Math.cos,p=Math.sin,m=d(n/2),g=d(o/2),y=d(c/2),x=p(n/2),b=p(o/2),M=p(c/2);switch(h){case"XYZ":this._x=x*g*y+m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y-x*b*M;break;case"YXZ":this._x=x*g*y+m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y+x*b*M;break;case"ZXY":this._x=x*g*y-m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y-x*b*M;break;case"ZYX":this._x=x*g*y-m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y+x*b*M;break;case"YZX":this._x=x*g*y+m*b*M,this._y=m*b*y+x*g*M,this._z=m*g*M-x*b*y,this._w=m*g*y-x*b*M;break;case"XZY":this._x=x*g*y-m*b*M,this._y=m*b*y-x*g*M,this._z=m*g*M+x*b*y,this._w=m*g*y+x*b*M;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+h)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,o=Math.sin(n);return this._x=e.x*o,this._y=e.y*o,this._z=e.z*o,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],o=t[4],c=t[8],h=t[1],d=t[5],p=t[9],m=t[2],g=t[6],y=t[10],x=n+d+y;if(x>0){const e=.5/Math.sqrt(x+1);this._w=.25/e,this._x=(g-p)*e,this._y=(c-m)*e,this._z=(h-o)*e}else if(n>d&&n>y){const e=2*Math.sqrt(1+n-d-y);this._w=(g-p)/e,this._x=.25*e,this._y=(o+h)/e,this._z=(c+m)/e}else if(d>y){const e=2*Math.sqrt(1+d-n-y);this._w=(c-m)/e,this._x=(o+h)/e,this._y=.25*e,this._z=(p+g)/e}else{const e=2*Math.sqrt(1+y-n-d);this._w=(h-o)/e,this._x=(c+m)/e,this._y=(p+g)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){const n=1e-6;let o=e.dot(t)+1;return o<n?(o=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=o):(this._x=0,this._y=-e.z,this._z=e.y,this._w=o)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=o),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(qn.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const o=Math.min(1,t/n);return this.slerp(e,o),this}identity(){return this.set(0,0,0,1)}inverse(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,o=e._y,c=e._z,h=e._w,d=t._x,p=t._y,m=t._z,g=t._w;return this._x=n*g+h*d+o*m-c*p,this._y=o*g+h*p+c*d-n*m,this._z=c*g+h*m+n*p-o*d,this._w=h*g-n*d-o*p-c*m,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,o=this._y,c=this._z,h=this._w;let d=h*e._w+n*e._x+o*e._y+c*e._z;if(d<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,d=-d):this.copy(e),d>=1)return this._w=h,this._x=n,this._y=o,this._z=c,this;const p=1-d*d;if(p<=Number.EPSILON){const e=1-t;return this._w=e*h+t*this._w,this._x=e*n+t*this._x,this._y=e*o+t*this._y,this._z=e*c+t*this._z,this.normalize(),this._onChangeCallback(),this}const m=Math.sqrt(p),g=Math.atan2(m,d),y=Math.sin((1-t)*g)/m,x=Math.sin(t*g)/m;return this._w=h*y+this._w*x,this._x=n*y+this._x*x,this._y=o*y+this._y*x,this._z=c*y+this._z*x,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t){return void 0===t&&(t=0),this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class Vector3{constructor(e=0,t=0,n=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Qn.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Qn.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,o=this.z,c=e.elements;return this.x=c[0]*t+c[3]*n+c[6]*o,this.y=c[1]*t+c[4]*n+c[7]*o,this.z=c[2]*t+c[5]*n+c[8]*o,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,o=this.z,c=e.elements,h=1/(c[3]*t+c[7]*n+c[11]*o+c[15]);return this.x=(c[0]*t+c[4]*n+c[8]*o+c[12])*h,this.y=(c[1]*t+c[5]*n+c[9]*o+c[13])*h,this.z=(c[2]*t+c[6]*n+c[10]*o+c[14])*h,this}applyQuaternion(e){const t=this.x,n=this.y,o=this.z,c=e.x,h=e.y,d=e.z,p=e.w,m=p*t+h*o-d*n,g=p*n+d*t-c*o,y=p*o+c*n-h*t,x=-c*t-h*n-d*o;return this.x=m*p+x*-c+g*-d-y*-h,this.y=g*p+x*-h+y*-c-m*-d,this.z=y*p+x*-d+m*-h-g*-c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,o=this.z,c=e.elements;return this.x=c[0]*t+c[4]*n+c[8]*o,this.y=c[1]*t+c[5]*n+c[9]*o,this.z=c[2]*t+c[6]*n+c[10]*o,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,o=e.y,c=e.z,h=t.x,d=t.y,p=t.z;return this.x=o*p-c*d,this.y=c*h-n*p,this.z=n*d-o*h,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Jn.copy(this).projectOnVector(e),this.sub(Jn)}reflect(e){return this.sub(Jn.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(qn.clamp(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,o=this.z-e.z;return t*t+n*n+o*o}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const o=Math.sin(t)*e;return this.x=o*Math.sin(n),this.y=Math.cos(t)*e,this.z=o*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),o=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=o,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const Jn=new Vector3,Qn=new Quaternion;class Box3{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=void 0!==e?e:new Vector3(1/0,1/0,1/0),this.max=void 0!==t?t:new Vector3(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,o=1/0,c=-1/0,h=-1/0,d=-1/0;for(let p=0,m=e.length;p<m;p+=3){const m=e[p],g=e[p+1],y=e[p+2];m<t&&(t=m),g<n&&(n=g),y<o&&(o=y),m>c&&(c=m),g>h&&(h=g),y>d&&(d=y)}return this.min.set(t,n,o),this.max.set(c,h,d),this}setFromBufferAttribute(e){let t=1/0,n=1/0,o=1/0,c=-1/0,h=-1/0,d=-1/0;for(let p=0,m=e.count;p<m;p++){const m=e.getX(p),g=e.getY(p),y=e.getZ(p);m<t&&(t=m),g<n&&(n=g),y<o&&(o=y),m>c&&(c=m),g>h&&(h=g),y>d&&(d=y)}return this.min.set(t,n,o),this.max.set(c,h,d),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=$n.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Vector3),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Vector3),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),er.copy(t.boundingBox),er.applyMatrix4(e.matrixWorld),this.union(er));const n=e.children;for(let o=0,c=n.length;o<c;o++)this.expandByObject(n[o]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Vector3),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,$n),$n.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(sr),cr.subVectors(this.max,sr),tr.subVectors(e.a,sr),nr.subVectors(e.b,sr),rr.subVectors(e.c,sr),ir.subVectors(nr,tr),or.subVectors(rr,nr),ar.subVectors(tr,rr);let t=[0,-ir.z,ir.y,0,-or.z,or.y,0,-ar.z,ar.y,ir.z,0,-ir.x,or.z,0,-or.x,ar.z,0,-ar.x,-ir.y,ir.x,0,-or.y,or.x,0,-ar.y,ar.x,0];return!!satForAxes(t,tr,nr,rr,cr)&&(t=[1,0,0,0,1,0,0,0,1],!!satForAxes(t,tr,nr,rr,cr)&&(lr.crossVectors(ir,or),t=[lr.x,lr.y,lr.z],satForAxes(t,tr,nr,rr,cr)))}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Vector3),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){const t=$n.copy(e).clamp(this.min,this.max);return t.sub(e).length()}getBoundingSphere(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize($n).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(Kn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Kn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Kn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Kn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Kn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Kn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Kn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Kn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Kn)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function satForAxes(e,t,n,o,c){for(let h=0,d=e.length-3;h<=d;h+=3){ur.fromArray(e,h);const d=c.x*Math.abs(ur.x)+c.y*Math.abs(ur.y)+c.z*Math.abs(ur.z),p=t.dot(ur),m=n.dot(ur),g=o.dot(ur);if(Math.max(-Math.max(p,m,g),Math.min(p,m,g))>d)return!1}return!0}const Kn=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],$n=new Vector3,er=new Box3,tr=new Vector3,nr=new Vector3,rr=new Vector3,ir=new Vector3,or=new Vector3,ar=new Vector3,sr=new Vector3,cr=new Vector3,lr=new Vector3,ur=new Vector3,hr=new Box3;class Sphere{constructor(e,t){this.center=void 0!==e?e:new Vector3,this.radius=void 0!==t?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):hr.setFromPoints(e).getCenter(n);let o=0;for(let c=0,h=e.length;c<h;c++)o=Math.max(o,n.distanceToSquared(e[c]));return this.radius=Math.sqrt(o),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Vector3),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Box3),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const dr=new Vector3,pr=new Vector3,fr=new Vector3,mr=new Vector3,gr=new Vector3,yr=new Vector3,vr=new Vector3;class Ray{constructor(e,t){this.origin=void 0!==e?e:new Vector3,this.direction=void 0!==t?t:new Vector3(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new Vector3),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,dr)),this}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Vector3),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=dr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(dr.copy(this.direction).multiplyScalar(t).add(this.origin),dr.distanceToSquared(e))}distanceSqToSegment(e,t,n,o){pr.copy(e).add(t).multiplyScalar(.5),fr.copy(t).sub(e).normalize(),mr.copy(this.origin).sub(pr);const c=.5*e.distanceTo(t),h=-this.direction.dot(fr),d=mr.dot(this.direction),p=-mr.dot(fr),m=mr.lengthSq(),g=Math.abs(1-h*h);let y,x,b,M;if(g>0)if(y=h*p-d,x=h*d-p,M=c*g,y>=0)if(x>=-M)if(x<=M){const e=1/g;y*=e,x*=e,b=y*(y+h*x+2*d)+x*(h*y+x+2*p)+m}else x=c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;else x=-c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;else x<=-M?(y=Math.max(0,-(-h*c+d)),x=y>0?-c:Math.min(Math.max(-c,-p),c),b=-y*y+x*(x+2*p)+m):x<=M?(y=0,x=Math.min(Math.max(-c,-p),c),b=x*(x+2*p)+m):(y=Math.max(0,-(h*c+d)),x=y>0?c:Math.min(Math.max(-c,-p),c),b=-y*y+x*(x+2*p)+m);else x=h>0?-c:c,y=Math.max(0,-(h*x+d)),b=-y*y+x*(x+2*p)+m;return n&&n.copy(this.direction).multiplyScalar(y).add(this.origin),o&&o.copy(fr).multiplyScalar(x).add(pr),b}intersectSphere(e,t){dr.subVectors(e.center,this.origin);const n=dr.dot(this.direction),o=dr.dot(dr)-n*n,c=e.radius*e.radius;if(o>c)return null;const h=Math.sqrt(c-o),d=n-h,p=n+h;return d<0&&p<0?null:d<0?this.at(p,t):this.at(d,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);if(0===t)return!0;const n=e.normal.dot(this.direction);return n*t<0}intersectBox(e,t){let n,o,c,h,d,p;const m=1/this.direction.x,g=1/this.direction.y,y=1/this.direction.z,x=this.origin;return m>=0?(n=(e.min.x-x.x)*m,o=(e.max.x-x.x)*m):(n=(e.max.x-x.x)*m,o=(e.min.x-x.x)*m),g>=0?(c=(e.min.y-x.y)*g,h=(e.max.y-x.y)*g):(c=(e.max.y-x.y)*g,h=(e.min.y-x.y)*g),n>h||c>o?null:((c>n||n!==n)&&(n=c),(h<o||o!==o)&&(o=h),y>=0?(d=(e.min.z-x.z)*y,p=(e.max.z-x.z)*y):(d=(e.max.z-x.z)*y,p=(e.min.z-x.z)*y),n>p||d>o?null:((d>n||n!==n)&&(n=d),(p<o||o!==o)&&(o=p),o<0?null:this.at(n>=0?n:o,t)))}intersectsBox(e){return null!==this.intersectBox(e,dr)}intersectTriangle(e,t,n,o,c){gr.subVectors(t,e),yr.subVectors(n,e),vr.crossVectors(gr,yr);let h,d=this.direction.dot(vr);if(d>0){if(o)return null;h=1}else{if(!(d<0))return null;h=-1,d=-d}mr.subVectors(this.origin,e);const p=h*this.direction.dot(yr.crossVectors(mr,yr));if(p<0)return null;const m=h*this.direction.dot(gr.cross(mr));if(m<0)return null;if(p+m>d)return null;const g=-h*mr.dot(vr);return g<0?null:this.at(g/d,c)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Matrix4{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,o,c,h,d,p,m,g,y,x,b,M,_,w){const S=this.elements;return S[0]=e,S[4]=t,S[8]=n,S[12]=o,S[1]=c,S[5]=h,S[9]=d,S[13]=p,S[2]=m,S[6]=g,S[10]=y,S[14]=x,S[3]=b,S[7]=M,S[11]=_,S[15]=w,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Matrix4).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,o=1/xr.setFromMatrixColumn(e,0).length(),c=1/xr.setFromMatrixColumn(e,1).length(),h=1/xr.setFromMatrixColumn(e,2).length();return t[0]=n[0]*o,t[1]=n[1]*o,t[2]=n[2]*o,t[3]=0,t[4]=n[4]*c,t[5]=n[5]*c,t[6]=n[6]*c,t[7]=0,t[8]=n[8]*h,t[9]=n[9]*h,t[10]=n[10]*h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,o=e.y,c=e.z,h=Math.cos(n),d=Math.sin(n),p=Math.cos(o),m=Math.sin(o),g=Math.cos(c),y=Math.sin(c);if("XYZ"===e.order){const e=h*g,n=h*y,o=d*g,c=d*y;t[0]=p*g,t[4]=-p*y,t[8]=m,t[1]=n+o*m,t[5]=e-c*m,t[9]=-d*p,t[2]=c-e*m,t[6]=o+n*m,t[10]=h*p}else if("YXZ"===e.order){const e=p*g,n=p*y,o=m*g,c=m*y;t[0]=e+c*d,t[4]=o*d-n,t[8]=h*m,t[1]=h*y,t[5]=h*g,t[9]=-d,t[2]=n*d-o,t[6]=c+e*d,t[10]=h*p}else if("ZXY"===e.order){const e=p*g,n=p*y,o=m*g,c=m*y;t[0]=e-c*d,t[4]=-h*y,t[8]=o+n*d,t[1]=n+o*d,t[5]=h*g,t[9]=c-e*d,t[2]=-h*m,t[6]=d,t[10]=h*p}else if("ZYX"===e.order){const e=h*g,n=h*y,o=d*g,c=d*y;t[0]=p*g,t[4]=o*m-n,t[8]=e*m+c,t[1]=p*y,t[5]=c*m+e,t[9]=n*m-o,t[2]=-m,t[6]=d*p,t[10]=h*p}else if("YZX"===e.order){const e=h*p,n=h*m,o=d*p,c=d*m;t[0]=p*g,t[4]=c-e*y,t[8]=o*y+n,t[1]=y,t[5]=h*g,t[9]=-d*g,t[2]=-m*g,t[6]=n*y+o,t[10]=e-c*y}else if("XZY"===e.order){const e=h*p,n=h*m,o=d*p,c=d*m;t[0]=p*g,t[4]=-y,t[8]=m*g,t[1]=e*y+c,t[5]=h*g,t[9]=n*y-o,t[2]=o*y-n,t[6]=d*g,t[10]=c*y+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Mr,e,_r)}lookAt(e,t,n){const o=this.elements;return Tr.subVectors(e,t),0===Tr.lengthSq()&&(Tr.z=1),Tr.normalize(),wr.crossVectors(n,Tr),0===wr.lengthSq()&&(1===Math.abs(n.z)?Tr.x+=1e-4:Tr.z+=1e-4,Tr.normalize(),wr.crossVectors(n,Tr)),wr.normalize(),Sr.crossVectors(Tr,wr),o[0]=wr.x,o[4]=Sr.x,o[8]=Tr.x,o[1]=wr.y,o[5]=Sr.y,o[9]=Tr.y,o[2]=wr.z,o[6]=Sr.z,o[10]=Tr.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,o=t.elements,c=this.elements,h=n[0],d=n[4],p=n[8],m=n[12],g=n[1],y=n[5],x=n[9],b=n[13],M=n[2],_=n[6],w=n[10],S=n[14],T=n[3],E=n[7],L=n[11],A=n[15],C=o[0],P=o[4],R=o[8],B=o[12],D=o[1],G=o[5],I=o[9],O=o[13],V=o[2],N=o[6],F=o[10],U=o[14],z=o[3],H=o[7],k=o[11],j=o[15];return c[0]=h*C+d*D+p*V+m*z,c[4]=h*P+d*G+p*N+m*H,c[8]=h*R+d*I+p*F+m*k,c[12]=h*B+d*O+p*U+m*j,c[1]=g*C+y*D+x*V+b*z,c[5]=g*P+y*G+x*N+b*H,c[9]=g*R+y*I+x*F+b*k,c[13]=g*B+y*O+x*U+b*j,c[2]=M*C+_*D+w*V+S*z,c[6]=M*P+_*G+w*N+S*H,c[10]=M*R+_*I+w*F+S*k,c[14]=M*B+_*O+w*U+S*j,c[3]=T*C+E*D+L*V+A*z,c[7]=T*P+E*G+L*N+A*H,c[11]=T*R+E*I+L*F+A*k,c[15]=T*B+E*O+L*U+A*j,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],o=e[8],c=e[12],h=e[1],d=e[5],p=e[9],m=e[13],g=e[2],y=e[6],x=e[10],b=e[14],M=e[3],_=e[7],w=e[11],S=e[15];return M*(+c*p*y-o*m*y-c*d*x+n*m*x+o*d*b-n*p*b)+_*(+t*p*b-t*m*x+c*h*x-o*h*b+o*m*g-c*p*g)+w*(+t*m*y-t*d*b-c*h*y+n*h*b+c*d*g-n*m*g)+S*(-o*d*g-t*p*y+t*d*x+o*h*y-n*h*x+n*p*g)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const o=this.elements;return e.isVector3?(o[12]=e.x,o[13]=e.y,o[14]=e.z):(o[12]=e,o[13]=t,o[14]=n),this}getInverse(e,t){void 0!==t&&console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");const n=this.elements,o=e.elements,c=o[0],h=o[1],d=o[2],p=o[3],m=o[4],g=o[5],y=o[6],x=o[7],b=o[8],M=o[9],_=o[10],w=o[11],S=o[12],T=o[13],E=o[14],L=o[15],A=M*E*x-T*_*x+T*y*w-g*E*w-M*y*L+g*_*L,C=S*_*x-b*E*x-S*y*w+m*E*w+b*y*L-m*_*L,P=b*T*x-S*M*x+S*g*w-m*T*w-b*g*L+m*M*L,R=S*M*y-b*T*y-S*g*_+m*T*_+b*g*E-m*M*E,B=c*A+h*C+d*P+p*R;if(0===B)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/B;return n[0]=A*D,n[1]=(T*_*p-M*E*p-T*d*w+h*E*w+M*d*L-h*_*L)*D,n[2]=(g*E*p-T*y*p+T*d*x-h*E*x-g*d*L+h*y*L)*D,n[3]=(M*y*p-g*_*p-M*d*x+h*_*x+g*d*w-h*y*w)*D,n[4]=C*D,n[5]=(b*E*p-S*_*p+S*d*w-c*E*w-b*d*L+c*_*L)*D,n[6]=(S*y*p-m*E*p-S*d*x+c*E*x+m*d*L-c*y*L)*D,n[7]=(m*_*p-b*y*p+b*d*x-c*_*x-m*d*w+c*y*w)*D,n[8]=P*D,n[9]=(S*M*p-b*T*p-S*h*w+c*T*w+b*h*L-c*M*L)*D,n[10]=(m*T*p-S*g*p+S*h*x-c*T*x-m*h*L+c*g*L)*D,n[11]=(b*g*p-m*M*p-b*h*x+c*M*x+m*h*w-c*g*w)*D,n[12]=R*D,n[13]=(b*T*d-S*M*d+S*h*_-c*T*_-b*h*E+c*M*E)*D,n[14]=(S*g*d-m*T*d-S*h*y+c*T*y+m*h*E-c*g*E)*D,n[15]=(m*M*d-b*g*d+b*h*y-c*M*y-m*h*_+c*g*_)*D,this}scale(e){const t=this.elements,n=e.x,o=e.y,c=e.z;return t[0]*=n,t[4]*=o,t[8]*=c,t[1]*=n,t[5]*=o,t[9]*=c,t[2]*=n,t[6]*=o,t[10]*=c,t[3]*=n,t[7]*=o,t[11]*=c,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],o=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,o))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),o=Math.sin(t),c=1-n,h=e.x,d=e.y,p=e.z,m=c*h,g=c*d;return this.set(m*h+n,m*d-o*p,m*p+o*d,0,m*d+o*p,g*d+n,g*p-o*h,0,m*p-o*d,g*p+o*h,c*p*p+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const o=this.elements,c=t._x,h=t._y,d=t._z,p=t._w,m=c+c,g=h+h,y=d+d,x=c*m,b=c*g,M=c*y,_=h*g,w=h*y,S=d*y,T=p*m,E=p*g,L=p*y,A=n.x,C=n.y,P=n.z;return o[0]=(1-(_+S))*A,o[1]=(b+L)*A,o[2]=(M-E)*A,o[3]=0,o[4]=(b-L)*C,o[5]=(1-(x+S))*C,o[6]=(w+T)*C,o[7]=0,o[8]=(M+E)*P,o[9]=(w-T)*P,o[10]=(1-(x+_))*P,o[11]=0,o[12]=e.x,o[13]=e.y,o[14]=e.z,o[15]=1,this}decompose(e,t,n){const o=this.elements;let c=xr.set(o[0],o[1],o[2]).length();const h=xr.set(o[4],o[5],o[6]).length(),d=xr.set(o[8],o[9],o[10]).length(),p=this.determinant();p<0&&(c=-c),e.x=o[12],e.y=o[13],e.z=o[14],br.copy(this);const m=1/c,g=1/h,y=1/d;return br.elements[0]*=m,br.elements[1]*=m,br.elements[2]*=m,br.elements[4]*=g,br.elements[5]*=g,br.elements[6]*=g,br.elements[8]*=y,br.elements[9]*=y,br.elements[10]*=y,t.setFromRotationMatrix(br),n.x=c,n.y=h,n.z=d,this}makePerspective(e,t,n,o,c,h){void 0===h&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const d=this.elements,p=2*c/(t-e),m=2*c/(n-o),g=(t+e)/(t-e),y=(n+o)/(n-o),x=-(h+c)/(h-c),b=-2*h*c/(h-c);return d[0]=p,d[4]=0,d[8]=g,d[12]=0,d[1]=0,d[5]=m,d[9]=y,d[13]=0,d[2]=0,d[6]=0,d[10]=x,d[14]=b,d[3]=0,d[7]=0,d[11]=-1,d[15]=0,this}makeOrthographic(e,t,n,o,c,h){const d=this.elements,p=1/(t-e),m=1/(n-o),g=1/(h-c),y=(t+e)*p,x=(n+o)*m,b=(h+c)*g;return d[0]=2*p,d[4]=0,d[8]=0,d[12]=-y,d[1]=0,d[5]=2*m,d[9]=0,d[13]=-x,d[2]=0,d[6]=0,d[10]=-2*g,d[14]=-b,d[3]=0,d[7]=0,d[11]=0,d[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let o=0;o<16;o++)if(t[o]!==n[o])return!1;return!0}fromArray(e,t){void 0===t&&(t=0);for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const xr=new Vector3,br=new Matrix4,Mr=new Vector3(0,0,0),_r=new Vector3(1,1,1),wr=new Vector3,Sr=new Vector3,Tr=new Vector3;class Euler{constructor(e=0,t=0,n=0,o=Euler.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=n,this._order=o}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,o){return this._x=e,this._y=t,this._z=n,this._order=o||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const o=qn.clamp,c=e.elements,h=c[0],d=c[4],p=c[8],m=c[1],g=c[5],y=c[9],x=c[2],b=c[6],M=c[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(o(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(-y,M),this._z=Math.atan2(-d,h)):(this._x=Math.atan2(b,g),this._z=0);break;case"YXZ":this._x=Math.asin(-o(y,-1,1)),Math.abs(y)<.9999999?(this._y=Math.atan2(p,M),this._z=Math.atan2(m,g)):(this._y=Math.atan2(-x,h),this._z=0);break;case"ZXY":this._x=Math.asin(o(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(-x,M),this._z=Math.atan2(-d,g)):(this._y=0,this._z=Math.atan2(m,h));break;case"ZYX":this._y=Math.asin(-o(x,-1,1)),Math.abs(x)<.9999999?(this._x=Math.atan2(b,M),this._z=Math.atan2(m,h)):(this._x=0,this._z=Math.atan2(-d,g));break;case"YZX":this._z=Math.asin(o(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(-y,g),this._y=Math.atan2(-x,h)):(this._x=0,this._y=Math.atan2(p,M));break;case"XZY":this._z=Math.asin(-o(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(b,g),this._y=Math.atan2(p,h)):(this._x=Math.atan2(-y,M),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Er.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Er,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return Lr.setFromEuler(this),this.setFromQuaternion(Lr,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Vector3(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Euler.DefaultOrder="XYZ",Euler.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const Er=new Matrix4,Lr=new Quaternion;class Layers{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!==(this.mask&e.mask)}}let Ar=0;const Cr=new Vector3,Pr=new Quaternion,Rr=new Matrix4,Br=new Vector3,Dr=new Vector3,Gr=new Vector3,Ir=new Quaternion,Or=new Vector3(1,0,0),Vr=new Vector3(0,1,0),Nr=new Vector3(0,0,1),Fr={type:"added"},Ur={type:"removed"};function Object3D(){Object.defineProperty(this,"id",{value:Ar++}),this.uuid=qn.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DefaultUp.clone();const e=new Vector3,t=new Euler,n=new Quaternion,o=new Vector3(1,1,1);function onRotationChange(){n.setFromEuler(t,!1)}function onQuaternionChange(){t.setFromQuaternion(n,void 0,!1)}t._onChange(onRotationChange),n._onChange(onQuaternionChange),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:o},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}Object3D.DefaultUp=new Vector3(0,1,0),Object3D.DefaultMatrixAutoUpdate=!0,Object3D.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Object3D,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return Pr.setFromAxisAngle(e,t),this.quaternion.multiply(Pr),this},rotateOnWorldAxis:function(e,t){return Pr.setFromAxisAngle(e,t),this.quaternion.premultiply(Pr),this},rotateX:function(e){return this.rotateOnAxis(Or,e)},rotateY:function(e){return this.rotateOnAxis(Vr,e)},rotateZ:function(e){return this.rotateOnAxis(Nr,e)},translateOnAxis:function(e,t){return Cr.copy(e).applyQuaternion(this.quaternion),this.position.add(Cr.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(Or,e)},translateY:function(e){return this.translateOnAxis(Vr,e)},translateZ:function(e){return this.translateOnAxis(Nr,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(Rr.getInverse(this.matrixWorld))},lookAt:function(e,t,n){e.isVector3?Br.copy(e):Br.set(e,t,n);const o=this.parent;this.updateWorldMatrix(!0,!1),Dr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Rr.lookAt(Dr,Br,this.up):Rr.lookAt(Br,Dr,this.up),this.quaternion.setFromRotationMatrix(Rr),o&&(Rr.extractRotation(o.matrixWorld),Pr.setFromRotationMatrix(Rr),this.quaternion.premultiply(Pr.inverse()))},add:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Fr)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Ur)),this},attach:function(e){return this.updateWorldMatrix(!0,!1),Rr.getInverse(this.matrixWorld),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),Rr.multiply(e.parent.matrixWorld)),e.applyMatrix4(Rr),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,o=this.children.length;n<o;n++){const o=this.children[n],c=o.getObjectByProperty(e,t);if(void 0!==c)return c}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new Vector3),this.updateMatrixWorld(!0),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Quaternion),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Dr,e,Gr),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new Vector3),this.updateMatrixWorld(!0),this.matrixWorld.decompose(Dr,Ir,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new Vector3),this.updateMatrixWorld(!0);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverse(e)},traverseVisible:function(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,o=t.length;n<o;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=void 0===e||"string"===typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const o={};function serialize(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(o.uuid=this.uuid,o.type=this.type,""!==this.name&&(o.name=this.name),!0===this.castShadow&&(o.castShadow=!0),!0===this.receiveShadow&&(o.receiveShadow=!0),!1===this.visible&&(o.visible=!1),!1===this.frustumCulled&&(o.frustumCulled=!1),0!==this.renderOrder&&(o.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){o.geometry=serialize(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,o=n.length;t<o;t++){const o=n[t];serialize(e.shapes,o)}else serialize(e.shapes,n)}}if(void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,o=this.material.length;n<o;n++)t.push(serialize(e.materials,this.material[n]));o.material=t}else o.material=serialize(e.materials,this.material);if(this.children.length>0){o.children=[];for(let t=0;t<this.children.length;t++)o.children.push(this.children[t].toJSON(e).object)}if(t){const t=extractFromCache(e.geometries),o=extractFromCache(e.materials),c=extractFromCache(e.textures),h=extractFromCache(e.images),d=extractFromCache(e.shapes);t.length>0&&(n.geometries=t),o.length>0&&(n.materials=o),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),d.length>0&&(n.shapes=d)}return n.object=o,n;function extractFromCache(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t){if(void 0===t&&(t=!0),this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let n=0;n<e.children.length;n++){const t=e.children[n];this.add(t.clone())}return this}});const zr=new Vector3,Hr=new Vector3,kr=new Matrix3;class Plane{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=void 0!==e?e:new Vector3(1,0,0),this.constant=void 0!==t?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,o){return this.normal.set(e,t,n),this.constant=o,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const o=zr.subVectors(n,t).cross(Hr.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(o,e),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Vector3),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Vector3);const n=e.delta(zr),o=this.normal.dot(n);if(0===o)return 0===this.distanceToPoint(e.start)?t.copy(e.start):void 0;const c=-(e.start.dot(this.normal)+this.constant)/o;return c<0||c>1?void 0:t.copy(n).multiplyScalar(c).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Vector3),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||kr.getNormalMatrix(e),o=this.coplanarPoint(zr).applyMatrix4(e),c=this.normal.applyMatrix3(n).normalize();return this.constant=-o.dot(c),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const jr=new Vector3,Wr=new Vector3,qr=new Vector3,Xr=new Vector3,Yr=new Vector3,Zr=new Vector3,Jr=new Vector3,Qr=new Vector3,Kr=new Vector3,$r=new Vector3;class Triangle{constructor(e,t,n){this.a=void 0!==e?e:new Vector3,this.b=void 0!==t?t:new Vector3,this.c=void 0!==n?n:new Vector3}static getNormal(e,t,n,o){void 0===o&&(console.warn("THREE.Triangle: .getNormal() target is now required"),o=new Vector3),o.subVectors(n,t),jr.subVectors(e,t),o.cross(jr);const c=o.lengthSq();return c>0?o.multiplyScalar(1/Math.sqrt(c)):o.set(0,0,0)}static getBarycoord(e,t,n,o,c){jr.subVectors(o,t),Wr.subVectors(n,t),qr.subVectors(e,t);const h=jr.dot(jr),d=jr.dot(Wr),p=jr.dot(qr),m=Wr.dot(Wr),g=Wr.dot(qr),y=h*m-d*d;if(void 0===c&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),c=new Vector3),0===y)return c.set(-2,-1,-1);const x=1/y,b=(m*p-d*g)*x,M=(h*g-d*p)*x;return c.set(1-b-M,M,b)}static containsPoint(e,t,n,o){return this.getBarycoord(e,t,n,o,Xr),Xr.x>=0&&Xr.y>=0&&Xr.x+Xr.y<=1}static getUV(e,t,n,o,c,h,d,p){return this.getBarycoord(e,t,n,o,Xr),p.set(0,0),p.addScaledVector(c,Xr.x),p.addScaledVector(h,Xr.y),p.addScaledVector(d,Xr.z),p}static isFrontFacing(e,t,n,o){return jr.subVectors(n,t),Wr.subVectors(e,t),jr.cross(Wr).dot(o)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,o){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[o]),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return jr.subVectors(this.c,this.b),Wr.subVectors(this.a,this.b),.5*jr.cross(Wr).length()}getMidpoint(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Vector3),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Triangle.getNormal(this.a,this.b,this.c,e)}getPlane(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Plane),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Triangle.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,o,c){return Triangle.getUV(e,this.a,this.b,this.c,t,n,o,c)}containsPoint(e){return Triangle.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Vector3);const n=this.a,o=this.b,c=this.c;let h,d;Yr.subVectors(o,n),Zr.subVectors(c,n),Qr.subVectors(e,n);const p=Yr.dot(Qr),m=Zr.dot(Qr);if(p<=0&&m<=0)return t.copy(n);Kr.subVectors(e,o);const g=Yr.dot(Kr),y=Zr.dot(Kr);if(g>=0&&y<=g)return t.copy(o);const x=p*y-g*m;if(x<=0&&p>=0&&g<=0)return h=p/(p-g),t.copy(n).addScaledVector(Yr,h);$r.subVectors(e,c);const b=Yr.dot($r),M=Zr.dot($r);if(M>=0&&b<=M)return t.copy(c);const _=b*m-p*M;if(_<=0&&m>=0&&M<=0)return d=m/(m-M),t.copy(n).addScaledVector(Zr,d);const w=g*M-b*y;if(w<=0&&y-g>=0&&b-M>=0)return Jr.subVectors(c,o),d=(y-g)/(y-g+(b-M)),t.copy(o).addScaledVector(Jr,d);const S=1/(w+_+x);return h=_*S,d=x*S,t.copy(n).addScaledVector(Yr,h).addScaledVector(Zr,d)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const ei={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ti={h:0,s:0,l:0},ni={h:0,s:0,l:0};function hue2rgb(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function SRGBToLinear(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function LinearToSRGB(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class Color{constructor(e,t,n){return Object.defineProperty(this,"isColor",{value:!0}),void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"===typeof e?this.setHex(e):"string"===typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=qn.euclideanModulo(e,1),t=qn.clamp(t,0,1),n=qn.clamp(n,0,1),0===t)this.r=this.g=this.b=n;else{const o=n<=.5?n*(1+t):n+t-n*t,c=2*n-o;this.r=hue2rgb(c,o,e+1/3),this.g=hue2rgb(c,o,e),this.b=hue2rgb(c,o,e-1/3)}return this}setStyle(e){function handleAlpha(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let t;if(t=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){let e;const n=t[1],o=t[2];switch(n){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,handleAlpha(e[5]),this;if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,handleAlpha(e[5]),this;break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)){const t=parseFloat(e[1])/360,n=parseInt(e[2],10)/100,o=parseInt(e[3],10)/100;return handleAlpha(e[5]),this.setHSL(t,n,o)}break}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],n=e.length;if(3===n)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,this;if(6===n)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=ei[e];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t){return void 0===t&&(t=2),this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t){void 0===t&&(t=2);const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this}copyLinearToSRGB(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,o=this.b,c=Math.max(t,n,o),h=Math.min(t,n,o);let d,p;const m=(h+c)/2;if(h===c)d=0,p=0;else{const e=c-h;switch(p=m<=.5?e/(c+h):e/(2-c-h),c){case t:d=(n-o)/e+(n<o?6:0);break;case n:d=(o-t)/e+2;break;case o:d=(t-n)/e+4;break}d/=6}return e.h=d,e.s=p,e.l=m,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(ti),ti.h+=e,ti.s+=t,ti.l+=n,this.setHSL(ti.h,ti.s,ti.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpHSL(e,t){this.getHSL(ti),e.getHSL(ni);const n=qn.lerp(ti.h,ni.h,t),o=qn.lerp(ti.s,ni.s,t),c=qn.lerp(ti.l,ni.l,t);return this.setHSL(n,o,c),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t){return void 0===t&&(t=0),this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Color.NAMES=ei,Color.prototype.r=1,Color.prototype.g=1,Color.prototype.b=1;class Face3{constructor(e,t,n,o,c,h){this.a=e,this.b=t,this.c=n,this.normal=o&&o.isVector3?o:new Vector3,this.vertexNormals=Array.isArray(o)?o:[],this.color=c&&c.isColor?c:new Color,this.vertexColors=Array.isArray(c)?c:[],this.materialIndex=void 0!==h?h:0}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let ri=0;function Material(){Object.defineProperty(this,"id",{value:ri++}),this.uuid=qn.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=A,this.side=_,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=H,this.blendDst=k,this.blendEquation=D,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=K,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Bn,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=vn,this.stencilZFail=vn,this.stencilZPass=vn,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function MeshBasicMaterial(e){Material.call(this),this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=re,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Material.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Material,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===T;continue}const o=this[t];void 0!==o?o&&o.isColor?o.set(n):o&&o.isVector3&&n&&n.isVector3?o.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"===typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function extractFromCache(e){const t=[];for(const n in e){const o=e[n];delete o.metadata,t.push(o)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,void 0!==this.combine&&(n.combine=this.combine),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==A&&(n.blending=this.blending),!0===this.flatShading&&(n.flatShading=this.flatShading),this.side!==_&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=extractFromCache(e.textures),o=extractFromCache(e.images);t.length>0&&(n.textures=t),o.length>0&&(n.images=o)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let o=0;o!==e;++o)n[o]=t[o].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Material.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),MeshBasicMaterial.prototype=Object.create(Material.prototype),MeshBasicMaterial.prototype.constructor=MeshBasicMaterial,MeshBasicMaterial.prototype.isMeshBasicMaterial=!0,MeshBasicMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const ii=new Vector3,oi=new Vector2;function BufferAttribute(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=Dn,this.updateRange={offset:0,count:-1},this.version=0}function Int8BufferAttribute(e,t,n){BufferAttribute.call(this,new Int8Array(e),t,n)}function Uint8BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint8Array(e),t,n)}function Uint8ClampedBufferAttribute(e,t,n){BufferAttribute.call(this,new Uint8ClampedArray(e),t,n)}function Int16BufferAttribute(e,t,n){BufferAttribute.call(this,new Int16Array(e),t,n)}function Uint16BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint16Array(e),t,n)}function Int32BufferAttribute(e,t,n){BufferAttribute.call(this,new Int32Array(e),t,n)}function Uint32BufferAttribute(e,t,n){BufferAttribute.call(this,new Uint32Array(e),t,n)}function Float32BufferAttribute(e,t,n){BufferAttribute.call(this,new Float32Array(e),t,n)}function Float64BufferAttribute(e,t,n){BufferAttribute.call(this,new Float64Array(e),t,n)}Object.defineProperty(BufferAttribute.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(BufferAttribute.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let o=0,c=this.itemSize;o<c;o++)this.array[e+o]=t.array[n+o];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",o),c=new Color),t[n++]=c.r,t[n++]=c.g,t[n++]=c.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",o),c=new Vector2),t[n++]=c.x,t[n++]=c.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",o),c=new Vector3),t[n++]=c.x,t[n++]=c.y,t[n++]=c.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let o=0,c=e.length;o<c;o++){let c=e[o];void 0===c&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",o),c=new Vector4),t[n++]=c.x,t[n++]=c.y,t[n++]=c.z,t[n++]=c.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)oi.fromBufferAttribute(this,t),oi.applyMatrix3(e),this.setXY(t,oi.x,oi.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)ii.fromBufferAttribute(this,t),ii.applyMatrix3(e),this.setXYZ(t,ii.x,ii.y,ii.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)ii.x=this.getX(t),ii.y=this.getY(t),ii.z=this.getZ(t),ii.applyMatrix4(e),this.setXYZ(t,ii.x,ii.y,ii.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)ii.x=this.getX(t),ii.y=this.getY(t),ii.z=this.getZ(t),ii.applyNormalMatrix(e),this.setXYZ(t,ii.x,ii.y,ii.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)ii.x=this.getX(t),ii.y=this.getY(t),ii.z=this.getZ(t),ii.transformDirection(e),this.setXYZ(t,ii.x,ii.y,ii.z);return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this},setXYZW:function(e,t,n,o,c){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=o,this.array[e+3]=c,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int8BufferAttribute.prototype.constructor=Int8BufferAttribute,Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute,Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute,Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int16BufferAttribute.prototype.constructor=Int16BufferAttribute,Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute,Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Int32BufferAttribute.prototype.constructor=Int32BufferAttribute,Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute,Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Float32BufferAttribute.prototype.constructor=Float32BufferAttribute,Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype),Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;class DirectGeometry{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let n,o,c=void 0;const h=e.faces;for(o=0;o<h.length;o++){const e=h[o];e.materialIndex!==c&&(c=e.materialIndex,void 0!==n&&(n.count=3*o-n.start,t.push(n)),n={start:3*o,materialIndex:c})}void 0!==n&&(n.count=3*o-n.start,t.push(n)),this.groups=t}fromGeometry(e){const t=e.faces,n=e.vertices,o=e.faceVertexUvs,c=o[0]&&o[0].length>0,h=o[1]&&o[1].length>0,d=e.morphTargets,p=d.length;let m;if(p>0){m=[];for(let e=0;e<p;e++)m[e]={name:d[e].name,data:[]};this.morphTargets.position=m}const g=e.morphNormals,y=g.length;let x;if(y>0){x=[];for(let e=0;e<y;e++)x[e]={name:g[e].name,data:[]};this.morphTargets.normal=x}const b=e.skinIndices,M=e.skinWeights,_=b.length===n.length,w=M.length===n.length;n.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let S=0;S<t.length;S++){const e=t[S];this.vertices.push(n[e.a],n[e.b],n[e.c]);const T=e.vertexNormals;if(3===T.length)this.normals.push(T[0],T[1],T[2]);else{const t=e.normal;this.normals.push(t,t,t)}const E=e.vertexColors;if(3===E.length)this.colors.push(E[0],E[1],E[2]);else{const t=e.color;this.colors.push(t,t,t)}if(!0===c){const e=o[0][S];void 0!==e?this.uvs.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",S),this.uvs.push(new Vector2,new Vector2,new Vector2))}if(!0===h){const e=o[1][S];void 0!==e?this.uvs2.push(e[0],e[1],e[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",S),this.uvs2.push(new Vector2,new Vector2,new Vector2))}for(let t=0;t<p;t++){const n=d[t].vertices;m[t].data.push(n[e.a],n[e.b],n[e.c])}for(let t=0;t<y;t++){const e=g[t].vertexNormals[S];x[t].data.push(e.a,e.b,e.c)}_&&this.skinIndices.push(b[e.a],b[e.b],b[e.c]),w&&this.skinWeights.push(M[e.a],M[e.b],M[e.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}function arrayMax(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,o=e.length;n<o;++n)e[n]>t&&(t=e[n]);return t}let ai=1;const si=new Matrix4,ci=new Object3D,li=new Vector3,ui=new Box3,hi=new Box3,di=new Vector3;function BufferGeometry(){Object.defineProperty(this,"id",{value:ai+=2}),this.uuid=qn.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}BufferGeometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:BufferGeometry,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){Array.isArray(e)?this.index=new(arrayMax(e)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},addGroup:function(e,t,n){this.groups.push({start:e,count:t,materialIndex:void 0!==n?n:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new Matrix3).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(e),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return si.makeRotationX(e),this.applyMatrix4(si),this},rotateY:function(e){return si.makeRotationY(e),this.applyMatrix4(si),this},rotateZ:function(e){return si.makeRotationZ(e),this.applyMatrix4(si),this},translate:function(e,t,n){return si.makeTranslation(e,t,n),this.applyMatrix4(si),this},scale:function(e,t,n){return si.makeScale(e,t,n),this.applyMatrix4(si),this},lookAt:function(e){return ci.lookAt(e),ci.updateMatrix(),this.applyMatrix4(ci.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(li).negate(),this.translate(li.x,li.y,li.z),this},setFromObject:function(e){const t=e.geometry;if(e.isPoints||e.isLine){const e=new Float32BufferAttribute(3*t.vertices.length,3),n=new Float32BufferAttribute(3*t.colors.length,3);if(this.setAttribute("position",e.copyVector3sArray(t.vertices)),this.setAttribute("color",n.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){const e=new Float32BufferAttribute(t.lineDistances.length,1);this.setAttribute("lineDistance",e.copyArray(t.lineDistances))}null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n];t.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new Float32BufferAttribute(t,3)),this},updateFromObject:function(e){let t=e.geometry;if(e.isMesh){let e=t.__directGeometry;if(!0===t.elementsNeedUpdate&&(e=void 0,t.elementsNeedUpdate=!1),void 0===e)return this.fromGeometry(t);e.verticesNeedUpdate=t.verticesNeedUpdate,e.normalsNeedUpdate=t.normalsNeedUpdate,e.colorsNeedUpdate=t.colorsNeedUpdate,e.uvsNeedUpdate=t.uvsNeedUpdate,e.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=e}if(!0===t.verticesNeedUpdate){const e=this.attributes.position;void 0!==e&&(e.copyVector3sArray(t.vertices),e.needsUpdate=!0),t.verticesNeedUpdate=!1}if(!0===t.normalsNeedUpdate){const e=this.attributes.normal;void 0!==e&&(e.copyVector3sArray(t.normals),e.needsUpdate=!0),t.normalsNeedUpdate=!1}if(!0===t.colorsNeedUpdate){const e=this.attributes.color;void 0!==e&&(e.copyColorsArray(t.colors),e.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){const e=this.attributes.uv;void 0!==e&&(e.copyVector2sArray(t.uvs),e.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){const e=this.attributes.lineDistance;void 0!==e&&(e.copyArray(t.lineDistances),e.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=(new DirectGeometry).fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const t=new Float32Array(3*e.vertices.length);if(this.setAttribute("position",new BufferAttribute(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){const t=new Float32Array(3*e.normals.length);this.setAttribute("normal",new BufferAttribute(t,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const t=new Float32Array(3*e.colors.length);this.setAttribute("color",new BufferAttribute(t,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const t=new Float32Array(2*e.uvs.length);this.setAttribute("uv",new BufferAttribute(t,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const t=new Float32Array(2*e.uvs2.length);this.setAttribute("uv2",new BufferAttribute(t,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const n in e.morphTargets){const t=[],o=e.morphTargets[n];for(let e=0,n=o.length;e<n;e++){const n=o[e],c=new Float32BufferAttribute(3*n.data.length,3);c.name=n.name,t.push(c.copyVector3sArray(n.data))}this.morphAttributes[n]=t}if(e.skinIndices.length>0){const t=new Float32BufferAttribute(4*e.skinIndices.length,4);this.setAttribute("skinIndex",t.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const t=new Float32BufferAttribute(4*e.skinWeights.length,4);this.setAttribute("skinWeight",t.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,o=t.length;n<o;n++){const e=t[n];ui.setFromBufferAttribute(e),this.morphTargetsRelative?(di.addVectors(this.boundingBox.min,ui.min),this.boundingBox.expandByPoint(di),di.addVectors(this.boundingBox.max,ui.max),this.boundingBox.expandByPoint(di)):(this.boundingBox.expandByPoint(ui.min),this.boundingBox.expandByPoint(ui.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Vector3,1/0);if(e){const n=this.boundingSphere.center;if(ui.setFromBufferAttribute(e),t)for(let e=0,c=t.length;e<c;e++){const n=t[e];hi.setFromBufferAttribute(n),this.morphTargetsRelative?(di.addVectors(ui.min,hi.min),ui.expandByPoint(di),di.addVectors(ui.max,hi.max),ui.expandByPoint(di)):(ui.expandByPoint(hi.min),ui.expandByPoint(hi.max))}ui.getCenter(n);let o=0;for(let t=0,c=e.count;t<c;t++)di.fromBufferAttribute(e,t),o=Math.max(o,n.distanceToSquared(di));if(t)for(let c=0,h=t.length;c<h;c++){const h=t[c],d=this.morphTargetsRelative;for(let t=0,c=h.count;t<c;t++)di.fromBufferAttribute(h,t),d&&(li.fromBufferAttribute(e,t),di.add(li)),o=Math.max(o,n.distanceToSquared(di))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new BufferAttribute(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const o=new Vector3,c=new Vector3,h=new Vector3,d=new Vector3,p=new Vector3,m=new Vector3,g=new Vector3,y=new Vector3;if(e)for(let x=0,b=e.count;x<b;x+=3){const b=e.getX(x+0),M=e.getX(x+1),_=e.getX(x+2);o.fromBufferAttribute(t,b),c.fromBufferAttribute(t,M),h.fromBufferAttribute(t,_),g.subVectors(h,c),y.subVectors(o,c),g.cross(y),d.fromBufferAttribute(n,b),p.fromBufferAttribute(n,M),m.fromBufferAttribute(n,_),d.add(g),p.add(g),m.add(g),n.setXYZ(b,d.x,d.y,d.z),n.setXYZ(M,p.x,p.y,p.z),n.setXYZ(_,m.x,m.y,m.z)}else for(let e=0,x=t.count;e<x;e+=3)o.fromBufferAttribute(t,e+0),c.fromBufferAttribute(t,e+1),h.fromBufferAttribute(t,e+2),g.subVectors(h,c),y.subVectors(o,c),g.cross(y),n.setXYZ(e+0,g.x,g.y,g.z),n.setXYZ(e+1,g.x,g.y,g.z),n.setXYZ(e+2,g.x,g.y,g.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const o in n){if(void 0===e.attributes[o])continue;const c=n[o],h=c.array,d=e.attributes[o],p=d.array,m=d.itemSize*t,g=Math.min(p.length,h.length-m);for(let e=0,t=m;e<g;e++,t++)h[t]=p[e]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)di.fromBufferAttribute(e,t),di.normalize(),e.setXYZ(t,di.x,di.y,di.z)},toNonIndexed:function(){function convertBufferAttribute(e,t){const n=e.array,o=e.itemSize,c=e.normalized,h=new n.constructor(t.length*o);let d=0,p=0;for(let m=0,g=t.length;m<g;m++){d=t[m]*o;for(let e=0;e<o;e++)h[p++]=n[d++]}return new BufferAttribute(h,o,c)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const e=new BufferGeometry,t=this.index.array,n=this.attributes;for(const h in n){const o=n[h],c=convertBufferAttribute(o,t);e.setAttribute(h,c)}const o=this.morphAttributes;for(const h in o){const n=[],c=o[h];for(let e=0,o=c.length;e<o;e++){const o=c[e],h=convertBufferAttribute(o,t);n.push(h)}e.morphAttributes[h]=n}e.morphTargetsRelative=this.morphTargetsRelative;const c=this.groups;for(let h=0,d=c.length;h<d;h++){const t=c[h];e.addGroup(t.start,t.count,t.materialIndex)}return e},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const p in n){const t=n[p],o=t.toJSON(e.data);""!==t.name&&(o.name=t.name),e.data.attributes[p]=o}const o={};let c=!1;for(const p in this.morphAttributes){const t=this.morphAttributes[p],n=[];for(let o=0,c=t.length;o<c;o++){const c=t[o],h=c.toJSON(e.data);""!==c.name&&(h.name=c.name),n.push(h)}n.length>0&&(o[p]=n,c=!0)}c&&(e.data.morphAttributes=o,e.data.morphTargetsRelative=this.morphTargetsRelative);const h=this.groups;h.length>0&&(e.data.groups=JSON.parse(JSON.stringify(h)));const d=this.boundingSphere;return null!==d&&(e.data.boundingSphere={center:d.center.toArray(),radius:d.radius}),e},clone:function(){return(new BufferGeometry).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const o=e.attributes;for(const m in o){const e=o[m];this.setAttribute(m,e.clone(t))}const c=e.morphAttributes;for(const m in c){const e=[],n=c[m];for(let o=0,c=n.length;o<c;o++)e.push(n[o].clone(t));this.morphAttributes[m]=e}this.morphTargetsRelative=e.morphTargetsRelative;const h=e.groups;for(let m=0,g=h.length;m<g;m++){const e=h[m];this.addGroup(e.start,e.count,e.materialIndex)}const d=e.boundingBox;null!==d&&(this.boundingBox=d.clone());const p=e.boundingSphere;return null!==p&&(this.boundingSphere=p.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const pi=new Matrix4,fi=new Ray,mi=new Sphere,gi=new Vector3,yi=new Vector3,vi=new Vector3,xi=new Vector3,bi=new Vector3,Mi=new Vector3,_i=new Vector3,wi=new Vector3,Si=new Vector3,Ti=new Vector2,Ei=new Vector2,Li=new Vector2,Ai=new Vector3,Ci=new Vector3;function Mesh(e,t){Object3D.call(this),this.type="Mesh",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new MeshBasicMaterial,this.updateMorphTargets()}function checkIntersection(e,t,n,o,c,h,d,p){let m;if(m=t.side===w?o.intersectTriangle(d,h,c,!0,p):o.intersectTriangle(c,h,d,t.side!==S,p),null===m)return null;Ci.copy(p),Ci.applyMatrix4(e.matrixWorld);const g=n.ray.origin.distanceTo(Ci);return g<n.near||g>n.far?null:{distance:g,point:Ci.clone(),object:e}}function checkBufferGeometryIntersection(e,t,n,o,c,h,d,p,m,g,y,x){gi.fromBufferAttribute(c,g),yi.fromBufferAttribute(c,y),vi.fromBufferAttribute(c,x);const b=e.morphTargetInfluences;if(t.morphTargets&&h&&b){_i.set(0,0,0),wi.set(0,0,0),Si.set(0,0,0);for(let e=0,t=h.length;e<t;e++){const t=b[e],n=h[e];0!==t&&(xi.fromBufferAttribute(n,g),bi.fromBufferAttribute(n,y),Mi.fromBufferAttribute(n,x),d?(_i.addScaledVector(xi,t),wi.addScaledVector(bi,t),Si.addScaledVector(Mi,t)):(_i.addScaledVector(xi.sub(gi),t),wi.addScaledVector(bi.sub(yi),t),Si.addScaledVector(Mi.sub(vi),t)))}gi.add(_i),yi.add(wi),vi.add(Si)}e.isSkinnedMesh&&(e.boneTransform(g,gi),e.boneTransform(y,yi),e.boneTransform(x,vi));const M=checkIntersection(e,t,n,o,gi,yi,vi,Ai);if(M){p&&(Ti.fromBufferAttribute(p,g),Ei.fromBufferAttribute(p,y),Li.fromBufferAttribute(p,x),M.uv=Triangle.getUV(Ai,gi,yi,vi,Ti,Ei,Li,new Vector2)),m&&(Ti.fromBufferAttribute(m,g),Ei.fromBufferAttribute(m,y),Li.fromBufferAttribute(m,x),M.uv2=Triangle.getUV(Ai,gi,yi,vi,Ti,Ei,Li,new Vector2));const e=new Face3(g,y,x);Triangle.getNormal(gi,yi,vi,e.normal),M.face=e}return M}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,o=this.material,c=this.matrixWorld;if(void 0===o)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),mi.copy(n.boundingSphere),mi.applyMatrix4(c),!1===e.ray.intersectsSphere(mi))return;if(pi.getInverse(c),fi.copy(e.ray).applyMatrix4(pi),null!==n.boundingBox&&!1===fi.intersectsBox(n.boundingBox))return;let h;if(n.isBufferGeometry){const c=n.index,d=n.attributes.position,p=n.morphAttributes.position,m=n.morphTargetsRelative,g=n.attributes.uv,y=n.attributes.uv2,x=n.groups,b=n.drawRange;if(null!==c)if(Array.isArray(o))for(let n=0,M=x.length;n<M;n++){const M=x[n],_=o[M.materialIndex],w=Math.max(M.start,b.start),S=Math.min(M.start+M.count,b.start+b.count);for(let n=w,o=S;n<o;n+=3){const o=c.getX(n),x=c.getX(n+1),b=c.getX(n+2);h=checkBufferGeometryIntersection(this,_,e,fi,d,p,m,g,y,o,x,b),h&&(h.faceIndex=Math.floor(n/3),h.face.materialIndex=M.materialIndex,t.push(h))}}else{const n=Math.max(0,b.start),x=Math.min(c.count,b.start+b.count);for(let b=n,M=x;b<M;b+=3){const n=c.getX(b),x=c.getX(b+1),M=c.getX(b+2);h=checkBufferGeometryIntersection(this,o,e,fi,d,p,m,g,y,n,x,M),h&&(h.faceIndex=Math.floor(b/3),t.push(h))}}else if(void 0!==d)if(Array.isArray(o))for(let n=0,M=x.length;n<M;n++){const c=x[n],M=o[c.materialIndex],_=Math.max(c.start,b.start),w=Math.min(c.start+c.count,b.start+b.count);for(let n=_,o=w;n<o;n+=3){const o=n,x=n+1,b=n+2;h=checkBufferGeometryIntersection(this,M,e,fi,d,p,m,g,y,o,x,b),h&&(h.faceIndex=Math.floor(n/3),h.face.materialIndex=c.materialIndex,t.push(h))}}else{const n=Math.max(0,b.start),c=Math.min(d.count,b.start+b.count);for(let x=n,b=c;x<b;x+=3){const n=x,c=x+1,b=x+2;h=checkBufferGeometryIntersection(this,o,e,fi,d,p,m,g,y,n,c,b),h&&(h.faceIndex=Math.floor(x/3),t.push(h))}}}else if(n.isGeometry){const c=Array.isArray(o),d=n.vertices,p=n.faces;let m;const g=n.faceVertexUvs[0];g.length>0&&(m=g);for(let n=0,y=p.length;n<y;n++){const g=p[n],y=c?o[g.materialIndex]:o;if(void 0===y)continue;const x=d[g.a],b=d[g.b],M=d[g.c];if(h=checkIntersection(this,y,e,fi,x,b,M,Ai),h){if(m&&m[n]){const e=m[n];Ti.copy(e[0]),Ei.copy(e[1]),Li.copy(e[2]),h.uv=Triangle.getUV(Ai,x,b,M,Ti,Ei,Li,new Vector2)}h.face=g,h.faceIndex=n,t.push(h)}}}}});let Pi=0;const Ri=new Matrix4,Bi=new Object3D,Di=new Vector3;function Geometry(){Object.defineProperty(this,"id",{value:Pi+=2}),this.uuid=qn.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Geometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Geometry,isGeometry:!0,applyMatrix4:function(e){const t=(new Matrix3).getNormalMatrix(e);for(let n=0,o=this.vertices.length;n<o;n++){const t=this.vertices[n];t.applyMatrix4(e)}for(let n=0,o=this.faces.length;n<o;n++){const e=this.faces[n];e.normal.applyMatrix3(t).normalize();for(let n=0,o=e.vertexNormals.length;n<o;n++)e.vertexNormals[n].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Ri.makeRotationX(e),this.applyMatrix4(Ri),this},rotateY:function(e){return Ri.makeRotationY(e),this.applyMatrix4(Ri),this},rotateZ:function(e){return Ri.makeRotationZ(e),this.applyMatrix4(Ri),this},translate:function(e,t,n){return Ri.makeTranslation(e,t,n),this.applyMatrix4(Ri),this},scale:function(e,t,n){return Ri.makeScale(e,t,n),this.applyMatrix4(Ri),this},lookAt:function(e){return Bi.lookAt(e),Bi.updateMatrix(),this.applyMatrix4(Bi.matrix),this},fromBufferGeometry:function(e){const t=this,n=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const c=o.position,h=o.normal,d=o.color,p=o.uv,m=o.uv2;void 0!==m&&(this.faceVertexUvs[1]=[]);for(let y=0;y<c.count;y++)t.vertices.push((new Vector3).fromBufferAttribute(c,y)),void 0!==d&&t.colors.push((new Color).fromBufferAttribute(d,y));function addFace(e,n,o,c){const g=void 0===d?[]:[t.colors[e].clone(),t.colors[n].clone(),t.colors[o].clone()],y=void 0===h?[]:[(new Vector3).fromBufferAttribute(h,e),(new Vector3).fromBufferAttribute(h,n),(new Vector3).fromBufferAttribute(h,o)],x=new Face3(e,n,o,y,g,c);t.faces.push(x),void 0!==p&&t.faceVertexUvs[0].push([(new Vector2).fromBufferAttribute(p,e),(new Vector2).fromBufferAttribute(p,n),(new Vector2).fromBufferAttribute(p,o)]),void 0!==m&&t.faceVertexUvs[1].push([(new Vector2).fromBufferAttribute(m,e),(new Vector2).fromBufferAttribute(m,n),(new Vector2).fromBufferAttribute(m,o)])}const g=e.groups;if(g.length>0)for(let y=0;y<g.length;y++){const e=g[y],t=e.start,o=e.count;for(let c=t,h=t+o;c<h;c+=3)void 0!==n?addFace(n.getX(c),n.getX(c+1),n.getX(c+2),e.materialIndex):addFace(c,c+1,c+2,e.materialIndex)}else if(void 0!==n)for(let y=0;y<n.count;y+=3)addFace(n.getX(y),n.getX(y+1),n.getX(y+2));else for(let y=0;y<c.count;y+=3)addFace(y,y+1,y+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Di).negate(),this.translate(Di.x,Di.y,Di.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=0===t?1:1/t,o=new Matrix4;return o.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(o),this},computeFaceNormals:function(){const e=new Vector3,t=new Vector3;for(let n=0,o=this.faces.length;n<o;n++){const o=this.faces[n],c=this.vertices[o.a],h=this.vertices[o.b],d=this.vertices[o.c];e.subVectors(d,h),t.subVectors(c,h),e.cross(t),e.normalize(),o.normal.copy(e)}},computeVertexNormals:function(e){void 0===e&&(e=!0);const t=new Array(this.vertices.length);for(let n=0,o=this.vertices.length;n<o;n++)t[n]=new Vector3;if(e){const e=new Vector3,n=new Vector3;for(let o=0,c=this.faces.length;o<c;o++){const c=this.faces[o],h=this.vertices[c.a],d=this.vertices[c.b],p=this.vertices[c.c];e.subVectors(p,d),n.subVectors(h,d),e.cross(n),t[c.a].add(e),t[c.b].add(e),t[c.c].add(e)}}else{this.computeFaceNormals();for(let e=0,n=this.faces.length;e<n;e++){const n=this.faces[e];t[n.a].add(n.normal),t[n.b].add(n.normal),t[n.c].add(n.normal)}}for(let n=0,o=this.vertices.length;n<o;n++)t[n].normalize();for(let n=0,o=this.faces.length;n<o;n++){const e=this.faces[n],o=e.vertexNormals;3===o.length?(o[0].copy(t[e.a]),o[1].copy(t[e.b]),o[2].copy(t[e.c])):(o[0]=t[e.a].clone(),o[1]=t[e.b].clone(),o[2]=t[e.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],n=t.vertexNormals;3===n.length?(n[0].copy(t.normal),n[1].copy(t.normal),n[2].copy(t.normal)):(n[0]=t.normal.clone(),n[1]=t.normal.clone(),n[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,n=this.faces.length;t<n;t++){const e=this.faces[t];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]);for(let t=0,n=e.vertexNormals.length;t<n;t++)e.__originalVertexNormals[t]?e.__originalVertexNormals[t].copy(e.vertexNormals[t]):e.__originalVertexNormals[t]=e.vertexNormals[t].clone()}const e=new Geometry;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,n=this.morphNormals[t].vertexNormals;for(let t=0,o=this.faces.length;t<o;t++){const t=new Vector3,o={a:new Vector3,b:new Vector3,c:new Vector3};e.push(t),n.push(o)}}const n=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=n.faceNormals[e],c=n.vertexNormals[e];o.copy(t.normal),c.a.copy(t.vertexNormals[0]),c.b.copy(t.vertexNormals[1]),c.c.copy(t.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){const e=this.faces[t];e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new Box3),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new Sphere),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,n){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let o;const c=this.vertices.length,h=this.vertices,d=e.vertices,p=this.faces,m=e.faces,g=this.colors,y=e.colors;void 0===n&&(n=0),void 0!==t&&(o=(new Matrix3).getNormalMatrix(t));for(let x=0,b=d.length;x<b;x++){const e=d[x],n=e.clone();void 0!==t&&n.applyMatrix4(t),h.push(n)}for(let x=0,b=y.length;x<b;x++)g.push(y[x].clone());for(let x=0,b=m.length;x<b;x++){const e=m[x];let t,h;const d=e.vertexNormals,g=e.vertexColors,y=new Face3(e.a+c,e.b+c,e.c+c);y.normal.copy(e.normal),void 0!==o&&y.normal.applyMatrix3(o).normalize();for(let n=0,c=d.length;n<c;n++)t=d[n].clone(),void 0!==o&&t.applyMatrix3(o).normalize(),y.vertexNormals.push(t);y.color.copy(e.color);for(let n=0,o=g.length;n<o;n++)h=g[n],y.vertexColors.push(h.clone());y.materialIndex=e.materialIndex+n,p.push(y)}for(let x=0,b=e.faceVertexUvs.length;x<b;x++){const t=e.faceVertexUvs[x];void 0===this.faceVertexUvs[x]&&(this.faceVertexUvs[x]=[]);for(let e=0,n=t.length;e<n;e++){const n=t[e],o=[];for(let e=0,t=n.length;e<t;e++)o.push(n[e].clone());this.faceVertexUvs[x].push(o)}}},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(){const e={},t=[],n=[],o=4,c=Math.pow(10,o);for(let p=0,m=this.vertices.length;p<m;p++){const o=this.vertices[p],h=Math.round(o.x*c)+"_"+Math.round(o.y*c)+"_"+Math.round(o.z*c);void 0===e[h]?(e[h]=p,t.push(this.vertices[p]),n[p]=t.length-1):n[p]=n[e[h]]}const h=[];for(let p=0,m=this.faces.length;p<m;p++){const e=this.faces[p];e.a=n[e.a],e.b=n[e.b],e.c=n[e.c];const t=[e.a,e.b,e.c];for(let n=0;n<3;n++)if(t[n]===t[(n+1)%3]){h.push(p);break}}for(let p=h.length-1;p>=0;p--){const e=h[p];this.faces.splice(e,1);for(let t=0,n=this.faceVertexUvs.length;t<n;t++)this.faceVertexUvs[t].splice(e,1)}const d=this.vertices.length-t.length;return this.vertices=t,d},setFromPoints:function(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];this.vertices.push(new Vector3(n.x,n.y,n.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let d=0;d<t;d++)e[d]._id=d;function materialIndexSort(e,t){return e.materialIndex-t.materialIndex}e.sort(materialIndexSort);const n=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let c,h;n&&n.length===t&&(c=[]),o&&o.length===t&&(h=[]);for(let d=0;d<t;d++){const t=e[d]._id;c&&c.push(n[t]),h&&h.push(o[t])}c&&(this.faceVertexUvs[0]=c),h&&(this.faceVertexUvs[1]=h)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}const t=[];for(let g=0;g<this.vertices.length;g++){const e=this.vertices[g];t.push(e.x,e.y,e.z)}const n=[],o=[],c={},h=[],d={},p=[],m={};for(let g=0;g<this.faces.length;g++){const e=this.faces[g],t=!0,o=!1,c=void 0!==this.faceVertexUvs[0][g],h=e.normal.length()>0,d=e.vertexNormals.length>0,p=1!==e.color.r||1!==e.color.g||1!==e.color.b,m=e.vertexColors.length>0;let y=0;if(y=setBit(y,0,0),y=setBit(y,1,t),y=setBit(y,2,o),y=setBit(y,3,c),y=setBit(y,4,h),y=setBit(y,5,d),y=setBit(y,6,p),y=setBit(y,7,m),n.push(y),n.push(e.a,e.b,e.c),n.push(e.materialIndex),c){const e=this.faceVertexUvs[0][g];n.push(getUvIndex(e[0]),getUvIndex(e[1]),getUvIndex(e[2]))}if(h&&n.push(getNormalIndex(e.normal)),d){const t=e.vertexNormals;n.push(getNormalIndex(t[0]),getNormalIndex(t[1]),getNormalIndex(t[2]))}if(p&&n.push(getColorIndex(e.color)),m){const t=e.vertexColors;n.push(getColorIndex(t[0]),getColorIndex(t[1]),getColorIndex(t[2]))}}function setBit(e,t,n){return n?e|1<<t:e&~(1<<t)}function getNormalIndex(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==c[t]||(c[t]=o.length/3,o.push(e.x,e.y,e.z)),c[t]}function getColorIndex(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==d[t]||(d[t]=h.length,h.push(e.getHex())),d[t]}function getUvIndex(e){const t=e.x.toString()+e.y.toString();return void 0!==m[t]||(m[t]=p.length/2,p.push(e.x,e.y)),m[t]}return e.data={},e.data.vertices=t,e.data.normals=o,h.length>0&&(e.data.colors=h),p.length>0&&(e.data.uvs=[p]),e.data.faces=n,e},clone:function(){return(new Geometry).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let x=0,b=t.length;x<b;x++)this.vertices.push(t[x].clone());const n=e.colors;for(let x=0,b=n.length;x<b;x++)this.colors.push(n[x].clone());const o=e.faces;for(let x=0,b=o.length;x<b;x++)this.faces.push(o[x].clone());for(let x=0,b=e.faceVertexUvs.length;x<b;x++){const t=e.faceVertexUvs[x];void 0===this.faceVertexUvs[x]&&(this.faceVertexUvs[x]=[]);for(let e=0,n=t.length;e<n;e++){const n=t[e],o=[];for(let e=0,t=n.length;e<t;e++){const t=n[e];o.push(t.clone())}this.faceVertexUvs[x].push(o)}}const c=e.morphTargets;for(let x=0,b=c.length;x<b;x++){const e={};if(e.name=c[x].name,void 0!==c[x].vertices){e.vertices=[];for(let t=0,n=c[x].vertices.length;t<n;t++)e.vertices.push(c[x].vertices[t].clone())}if(void 0!==c[x].normals){e.normals=[];for(let t=0,n=c[x].normals.length;t<n;t++)e.normals.push(c[x].normals[t].clone())}this.morphTargets.push(e)}const h=e.morphNormals;for(let x=0,b=h.length;x<b;x++){const e={};if(void 0!==h[x].vertexNormals){e.vertexNormals=[];for(let t=0,n=h[x].vertexNormals.length;t<n;t++){const n=h[x].vertexNormals[t],o={};o.a=n.a.clone(),o.b=n.b.clone(),o.c=n.c.clone(),e.vertexNormals.push(o)}}if(void 0!==h[x].faceNormals){e.faceNormals=[];for(let t=0,n=h[x].faceNormals.length;t<n;t++)e.faceNormals.push(h[x].faceNormals[t].clone())}this.morphNormals.push(e)}const d=e.skinWeights;for(let x=0,b=d.length;x<b;x++)this.skinWeights.push(d[x].clone());const p=e.skinIndices;for(let x=0,b=p.length;x<b;x++)this.skinIndices.push(p[x].clone());const m=e.lineDistances;for(let x=0,b=m.length;x<b;x++)this.lineDistances.push(m[x]);const g=e.boundingBox;null!==g&&(this.boundingBox=g.clone());const y=e.boundingSphere;return null!==y&&(this.boundingSphere=y.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class BoxGeometry extends Geometry{constructor(e,t,n,o,c,h){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:o,heightSegments:c,depthSegments:h},this.fromBufferGeometry(new BoxBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}}class BoxBufferGeometry extends BufferGeometry{constructor(e=1,t=1,n=1,o=1,c=1,h=1){super(),this.type="BoxBufferGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:o,heightSegments:c,depthSegments:h};const d=this;o=Math.floor(o),c=Math.floor(c),h=Math.floor(h);const p=[],m=[],g=[],y=[];let x=0,b=0;function buildPlane(e,t,n,o,c,h,M,_,w,S,T){const E=h/w,L=M/S,A=h/2,C=M/2,P=_/2,R=w+1,B=S+1;let D=0,G=0;const I=new Vector3;for(let d=0;d<B;d++){const h=d*L-C;for(let p=0;p<R;p++){const x=p*E-A;I[e]=x*o,I[t]=h*c,I[n]=P,m.push(I.x,I.y,I.z),I[e]=0,I[t]=0,I[n]=_>0?1:-1,g.push(I.x,I.y,I.z),y.push(p/w),y.push(1-d/S),D+=1}}for(let d=0;d<S;d++)for(let e=0;e<w;e++){const t=x+e+R*d,n=x+e+R*(d+1),o=x+(e+1)+R*(d+1),c=x+(e+1)+R*d;p.push(t,n,c),p.push(n,o,c),G+=6}d.addGroup(b,G,T),b+=G,x+=D}buildPlane("z","y","x",-1,-1,n,t,e,h,c,0),buildPlane("z","y","x",1,-1,n,t,-e,h,c,1),buildPlane("x","z","y",1,1,e,n,t,o,h,2),buildPlane("x","z","y",1,-1,e,n,-t,o,h,3),buildPlane("x","y","z",1,-1,e,t,n,o,c,4),buildPlane("x","y","z",-1,-1,e,t,-n,o,c,5),this.setIndex(p),this.setAttribute("position",new Float32BufferAttribute(m,3)),this.setAttribute("normal",new Float32BufferAttribute(g,3)),this.setAttribute("uv",new Float32BufferAttribute(y,2))}}function cloneUniforms(e){const t={};for(const n in e){t[n]={};for(const o in e[n]){const c=e[n][o];c&&(c.isColor||c.isMatrix3||c.isMatrix4||c.isVector2||c.isVector3||c.isVector4||c.isTexture)?t[n][o]=c.clone():Array.isArray(c)?t[n][o]=c.slice():t[n][o]=c}}return t}function mergeUniforms(e){const t={};for(let n=0;n<e.length;n++){const o=cloneUniforms(e[n]);for(const e in o)t[e]=o[e]}return t}const Gi={clone:cloneUniforms,merge:mergeUniforms};var Ii="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",Oi="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";function ShaderMaterial(e){Material.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=Ii,this.fragmentShader=Oi,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Camera(){Object3D.call(this),this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4}function PerspectiveCamera(e,t,n,o){Camera.call(this),this.type="PerspectiveCamera",this.fov=void 0!==e?e:50,this.zoom=1,this.near=void 0!==n?n:.1,this.far=void 0!==o?o:2e3,this.focus=10,this.aspect=void 0!==t?t:1,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}ShaderMaterial.prototype=Object.create(Material.prototype),ShaderMaterial.prototype.constructor=ShaderMaterial,ShaderMaterial.prototype.isShaderMaterial=!0,ShaderMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cloneUniforms(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this},ShaderMaterial.prototype.toJSON=function(e){const t=Material.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const o in this.uniforms){const n=this.uniforms[o],c=n.value;c&&c.isTexture?t.uniforms[o]={type:"t",value:c.toJSON(e).uuid}:c&&c.isColor?t.uniforms[o]={type:"c",value:c.getHex()}:c&&c.isVector2?t.uniforms[o]={type:"v2",value:c.toArray()}:c&&c.isVector3?t.uniforms[o]={type:"v3",value:c.toArray()}:c&&c.isVector4?t.uniforms[o]={type:"v4",value:c.toArray()}:c&&c.isMatrix3?t.uniforms[o]={type:"m3",value:c.toArray()}:c&&c.isMatrix4?t.uniforms[o]={type:"m4",value:c.toArray()}:t.uniforms[o]={value:c}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const o in this.extensions)!0===this.extensions[o]&&(n[o]=!0);return Object.keys(n).length>0&&(t.extensions=n),t},Camera.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:!0,copy:function(e,t){return Object3D.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new Vector3),this.updateMatrixWorld(!0);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){Object3D.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.getInverse(this.matrixWorld)},updateWorldMatrix:function(e,t){Object3D.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}}),PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:!0,copy:function(e,t){return Camera.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=2*qn.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(.5*qn.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*qn.RAD2DEG*Math.atan(Math.tan(.5*qn.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,o,c,h){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(.5*qn.DEG2RAD*this.fov)/this.zoom,n=2*t,o=this.aspect*n,c=-.5*o;const h=this.view;if(null!==this.view&&this.view.enabled){const e=h.fullWidth,d=h.fullHeight;c+=h.offsetX*o/e,t-=h.offsetY*n/d,o*=h.width/e,n*=h.height/d}const d=this.filmOffset;0!==d&&(c+=e*d/this.getFilmWidth()),this.projectionMatrix.makePerspective(c,c+o,t,t-n,e,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const Vi=90,Ni=1;function CubeCamera(e,t,n){if(Object3D.call(this),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const o=new PerspectiveCamera(Vi,Ni,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new Vector3(1,0,0)),this.add(o);const c=new PerspectiveCamera(Vi,Ni,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new Vector3(-1,0,0)),this.add(c);const h=new PerspectiveCamera(Vi,Ni,e,t);h.layers=this.layers,h.up.set(0,0,1),h.lookAt(new Vector3(0,1,0)),this.add(h);const d=new PerspectiveCamera(Vi,Ni,e,t);d.layers=this.layers,d.up.set(0,0,-1),d.lookAt(new Vector3(0,-1,0)),this.add(d);const p=new PerspectiveCamera(Vi,Ni,e,t);p.layers=this.layers,p.up.set(0,-1,0),p.lookAt(new Vector3(0,0,1)),this.add(p);const m=new PerspectiveCamera(Vi,Ni,e,t);m.layers=this.layers,m.up.set(0,-1,0),m.lookAt(new Vector3(0,0,-1)),this.add(m),this.update=function(e,t){null===this.parent&&this.updateMatrixWorld();const g=e.xr.enabled,y=e.getRenderTarget();e.xr.enabled=!1;const x=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,o),e.setRenderTarget(n,1),e.render(t,c),e.setRenderTarget(n,2),e.render(t,h),e.setRenderTarget(n,3),e.render(t,d),e.setRenderTarget(n,4),e.render(t,p),n.texture.generateMipmaps=x,e.setRenderTarget(n,5),e.render(t,m),e.setRenderTarget(y),e.xr.enabled=g},this.clear=function(e,t,o,c){const h=e.getRenderTarget();for(let d=0;d<6;d++)e.setRenderTarget(n,d),e.clear(t,o,c);e.setRenderTarget(h)}}function WebGLCubeRenderTarget(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),WebGLRenderTarget.call(this,e,e,t),this.texture.isWebGLCubeRenderTargetTexture=!0}function DataTexture(e,t,n,o,c,h,d,p,m,g,y,x){Texture.call(this,null,h,d,p,m,g,o,c,y,x),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==m?m:_e,this.minFilter=void 0!==g?g:_e,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}CubeCamera.prototype=Object.create(Object3D.prototype),CubeCamera.prototype.constructor=CubeCamera,WebGLCubeRenderTarget.prototype=Object.create(WebGLRenderTarget.prototype),WebGLCubeRenderTarget.prototype.constructor=WebGLCubeRenderTarget,WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=!0,WebGLCubeRenderTarget.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=qe,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",fragmentShader:"\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"},o=new BoxBufferGeometry(5,5,5),c=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:w,blending:L});c.uniforms.tEquirect.value=t;const h=new Mesh(o,c),d=t.minFilter;t.minFilter===Pe&&(t.minFilter=Le);const p=new CubeCamera(1,10,this);return p.update(e,h),t.minFilter=d,h.geometry.dispose(),h.material.dispose(),this},DataTexture.prototype=Object.create(Texture.prototype),DataTexture.prototype.constructor=DataTexture,DataTexture.prototype.isDataTexture=!0;const Fi=new Sphere,Ui=new Vector3;class Frustum{constructor(e,t,n,o,c,h){this.planes=[void 0!==e?e:new Plane,void 0!==t?t:new Plane,void 0!==n?n:new Plane,void 0!==o?o:new Plane,void 0!==c?c:new Plane,void 0!==h?h:new Plane]}set(e,t,n,o,c,h){const d=this.planes;return d[0].copy(e),d[1].copy(t),d[2].copy(n),d[3].copy(o),d[4].copy(c),d[5].copy(h),this}clone(){return(new this.constructor).copy(this)}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,o=n[0],c=n[1],h=n[2],d=n[3],p=n[4],m=n[5],g=n[6],y=n[7],x=n[8],b=n[9],M=n[10],_=n[11],w=n[12],S=n[13],T=n[14],E=n[15];return t[0].setComponents(d-o,y-p,_-x,E-w).normalize(),t[1].setComponents(d+o,y+p,_+x,E+w).normalize(),t[2].setComponents(d+c,y+m,_+b,E+S).normalize(),t[3].setComponents(d-c,y-m,_-b,E-S).normalize(),t[4].setComponents(d-h,y-g,_-M,E-T).normalize(),t[5].setComponents(d+h,y+g,_+M,E+T).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Fi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Fi)}intersectsSprite(e){return Fi.center.set(0,0,0),Fi.radius=.7071067811865476,Fi.applyMatrix4(e.matrixWorld),this.intersectsSphere(Fi)}intersectsSphere(e){const t=this.planes,n=e.center,o=-e.radius;for(let c=0;c<6;c++){const e=t[c].distanceToPoint(n);if(e<o)return!1}return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const o=t[n];if(Ui.x=o.normal.x>0?e.max.x:e.min.x,Ui.y=o.normal.y>0?e.max.y:e.min.y,Ui.z=o.normal.z>0?e.max.z:e.min.z,o.distanceToPoint(Ui)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}}function WebGLAnimation(){let e=null,t=!1,n=null,o=null;function onAnimationFrame(t,c){n(t,c),o=e.requestAnimationFrame(onAnimationFrame)}return{start:function(){!0!==t&&null!==n&&(o=e.requestAnimationFrame(onAnimationFrame),t=!0)},stop:function(){e.cancelAnimationFrame(o),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function WebGLAttributes(e,t){const n=t.isWebGL2,o=new WeakMap;function createBuffer(t,n){const o=t.array,c=t.usage,h=e.createBuffer();e.bindBuffer(n,h),e.bufferData(n,o,c),t.onUploadCallback();let d=5126;return o instanceof Float32Array?d=5126:o instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):o instanceof Uint16Array?d=5123:o instanceof Int16Array?d=5122:o instanceof Uint32Array?d=5125:o instanceof Int32Array?d=5124:o instanceof Int8Array?d=5120:o instanceof Uint8Array&&(d=5121),{buffer:h,type:d,bytesPerElement:o.BYTES_PER_ELEMENT,version:t.version}}function updateBuffer(t,o,c){const h=o.array,d=o.updateRange;e.bindBuffer(c,t),-1===d.count?e.bufferSubData(c,0,h):(n?e.bufferSubData(c,d.offset*h.BYTES_PER_ELEMENT,h,d.offset,d.count):e.bufferSubData(c,d.offset*h.BYTES_PER_ELEMENT,h.subarray(d.offset,d.offset+d.count)),d.count=-1)}function get(e){return e.isInterleavedBufferAttribute&&(e=e.data),o.get(e)}function remove(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=o.get(t);n&&(e.deleteBuffer(n.buffer),o.delete(t))}function update(e,t){if(e.isGLBufferAttribute){var n=o.get(e);return void((!n||n.version<e.version)&&o.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const c=o.get(e);void 0===c?o.set(e,createBuffer(e,t)):c.version<e.version&&(updateBuffer(c.buffer,e,t),c.version=e.version)}return{get:get,remove:remove,update:update}}class PlaneGeometry extends Geometry{constructor(e,t,n,o){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:o},this.fromBufferGeometry(new PlaneBufferGeometry(e,t,n,o)),this.mergeVertices()}}class PlaneBufferGeometry extends BufferGeometry{constructor(e,t,n,o){super(),this.type="PlaneBufferGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:o},e=e||1,t=t||1;const c=e/2,h=t/2,d=Math.floor(n)||1,p=Math.floor(o)||1,m=d+1,g=p+1,y=e/d,x=t/p,b=[],M=[],_=[],w=[];for(let S=0;S<g;S++){const e=S*x-h;for(let t=0;t<m;t++){const n=t*y-c;M.push(n,-e,0),_.push(0,0,1),w.push(t/d),w.push(1-S/p)}}for(let S=0;S<p;S++)for(let e=0;e<d;e++){const t=e+m*S,n=e+m*(S+1),o=e+1+m*(S+1),c=e+1+m*S;b.push(t,n,c),b.push(n,o,c)}this.setIndex(b),this.setAttribute("position",new Float32BufferAttribute(M,3)),this.setAttribute("normal",new Float32BufferAttribute(_,3)),this.setAttribute("uv",new Float32BufferAttribute(w,2))}}var zi="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",Hi="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",ki="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",ji="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",Wi="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",qi="vec3 transformed = vec3( position );",Xi="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",Yi="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",Zi="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",Ji="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",Qi="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",Ki="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",$i="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",eo="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",to="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",no="#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",ro="#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",io="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",oo="#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",ao="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",so="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",co="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",lo="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",uo="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",ho="gl_FragColor = linearToOutputTexel( gl_FragColor );",po="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",fo="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",mo="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",go="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",yo="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",vo="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",xo="#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",bo="#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",Mo="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",_o="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",wo="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",So="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",To="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",Eo="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",Lo="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",Ao="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",Co="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",Po="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",Ro="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",Bo="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",Do="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",Go="struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",Io="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",Oo="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",Vo="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",No="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",Fo="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",Uo="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",zo="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",Ho="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",ko="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",jo="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",Wo="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",qo="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",Xo="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",Yo="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",Zo="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",Jo="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",Qo="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",Ko="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",$o="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",ea="#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",ta="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",na="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",ra="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",ia="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",oa="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",aa="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",sa="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",ca="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",la="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",ua="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",ha="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",da="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",pa="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",fa="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",ma="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",ga="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",ya="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",va="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",xa="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",ba="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",Ma="#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",_a="#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",wa="#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",Sa="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",Ta="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",Ea="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",La="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",Aa="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",Ca="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",Pa="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",Ra="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Ba="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",Da="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Ga="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",Ia="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",Oa="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",Va="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",Na="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",Fa="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",Ua="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",za="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",Ha="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",ka="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",ja="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",Wa="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",qa="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",Xa="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ya="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",Za="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ja="#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",Qa="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",Ka="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",$a="#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",es="#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",ts="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",ns="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",rs="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",is="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",os="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",as="#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",ss="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",cs="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";const ls={alphamap_fragment:zi,alphamap_pars_fragment:Hi,alphatest_fragment:ki,aomap_fragment:ji,aomap_pars_fragment:Wi,begin_vertex:qi,beginnormal_vertex:Xi,bsdfs:Yi,bumpmap_pars_fragment:Zi,clipping_planes_fragment:Ji,clipping_planes_pars_fragment:Qi,clipping_planes_pars_vertex:Ki,clipping_planes_vertex:$i,color_fragment:eo,color_pars_fragment:to,color_pars_vertex:no,color_vertex:ro,common:io,cube_uv_reflection_fragment:oo,defaultnormal_vertex:ao,displacementmap_pars_vertex:so,displacementmap_vertex:co,emissivemap_fragment:lo,emissivemap_pars_fragment:uo,encodings_fragment:ho,encodings_pars_fragment:po,envmap_fragment:fo,envmap_common_pars_fragment:mo,envmap_pars_fragment:go,envmap_pars_vertex:yo,envmap_physical_pars_fragment:Ao,envmap_vertex:vo,fog_vertex:xo,fog_pars_vertex:bo,fog_fragment:Mo,fog_pars_fragment:_o,gradientmap_pars_fragment:wo,lightmap_fragment:So,lightmap_pars_fragment:To,lights_lambert_vertex:Eo,lights_pars_begin:Lo,lights_toon_fragment:Co,lights_toon_pars_fragment:Po,lights_phong_fragment:Ro,lights_phong_pars_fragment:Bo,lights_physical_fragment:Do,lights_physical_pars_fragment:Go,lights_fragment_begin:Io,lights_fragment_maps:Oo,lights_fragment_end:Vo,logdepthbuf_fragment:No,logdepthbuf_pars_fragment:Fo,logdepthbuf_pars_vertex:Uo,logdepthbuf_vertex:zo,map_fragment:Ho,map_pars_fragment:ko,map_particle_fragment:jo,map_particle_pars_fragment:Wo,metalnessmap_fragment:qo,metalnessmap_pars_fragment:Xo,morphnormal_vertex:Yo,morphtarget_pars_vertex:Zo,morphtarget_vertex:Jo,normal_fragment_begin:Qo,normal_fragment_maps:Ko,normalmap_pars_fragment:$o,clearcoat_normal_fragment_begin:ea,clearcoat_normal_fragment_maps:ta,clearcoat_pars_fragment:na,packing:ra,premultiplied_alpha_fragment:ia,project_vertex:oa,dithering_fragment:aa,dithering_pars_fragment:sa,roughnessmap_fragment:ca,roughnessmap_pars_fragment:la,shadowmap_pars_fragment:ua,shadowmap_pars_vertex:ha,shadowmap_vertex:da,shadowmask_pars_fragment:pa,skinbase_vertex:fa,skinning_pars_vertex:ma,skinning_vertex:ga,skinnormal_vertex:ya,specularmap_fragment:va,specularmap_pars_fragment:xa,tonemapping_fragment:ba,tonemapping_pars_fragment:Ma,transmissionmap_fragment:_a,transmissionmap_pars_fragment:wa,uv_pars_fragment:Sa,uv_pars_vertex:Ta,uv_vertex:Ea,uv2_pars_fragment:La,uv2_pars_vertex:Aa,uv2_vertex:Ca,worldpos_vertex:Pa,background_frag:Ra,background_vert:Ba,cube_frag:Da,cube_vert:Ga,depth_frag:Ia,depth_vert:Oa,distanceRGBA_frag:Va,distanceRGBA_vert:Na,equirect_frag:Fa,equirect_vert:Ua,linedashed_frag:za,linedashed_vert:Ha,meshbasic_frag:ka,meshbasic_vert:ja,meshlambert_frag:Wa,meshlambert_vert:qa,meshmatcap_frag:Xa,meshmatcap_vert:Ya,meshtoon_frag:Za,meshtoon_vert:Ja,meshphong_frag:Qa,meshphong_vert:Ka,meshphysical_frag:$a,meshphysical_vert:es,normal_frag:ts,normal_vert:ns,points_frag:rs,points_vert:is,shadow_frag:os,shadow_vert:as,sprite_frag:ss,sprite_vert:cs},us={common:{diffuse:{value:new Color(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Matrix3},uv2Transform:{value:new Matrix3},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(15658734)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3}}},hs={basic:{uniforms:mergeUniforms([us.common,us.specularmap,us.envmap,us.aomap,us.lightmap,us.fog]),vertexShader:ls.meshbasic_vert,fragmentShader:ls.meshbasic_frag},lambert:{uniforms:mergeUniforms([us.common,us.specularmap,us.envmap,us.aomap,us.lightmap,us.emissivemap,us.fog,us.lights,{emissive:{value:new Color(0)}}]),vertexShader:ls.meshlambert_vert,fragmentShader:ls.meshlambert_frag},phong:{uniforms:mergeUniforms([us.common,us.specularmap,us.envmap,us.aomap,us.lightmap,us.emissivemap,us.bumpmap,us.normalmap,us.displacementmap,us.fog,us.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ls.meshphong_vert,fragmentShader:ls.meshphong_frag},standard:{uniforms:mergeUniforms([us.common,us.envmap,us.aomap,us.lightmap,us.emissivemap,us.bumpmap,us.normalmap,us.displacementmap,us.roughnessmap,us.metalnessmap,us.fog,us.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ls.meshphysical_vert,fragmentShader:ls.meshphysical_frag},toon:{uniforms:mergeUniforms([us.common,us.aomap,us.lightmap,us.emissivemap,us.bumpmap,us.normalmap,us.displacementmap,us.gradientmap,us.fog,us.lights,{emissive:{value:new Color(0)}}]),vertexShader:ls.meshtoon_vert,fragmentShader:ls.meshtoon_frag},matcap:{uniforms:mergeUniforms([us.common,us.bumpmap,us.normalmap,us.displacementmap,us.fog,{matcap:{value:null}}]),vertexShader:ls.meshmatcap_vert,fragmentShader:ls.meshmatcap_frag},points:{uniforms:mergeUniforms([us.points,us.fog]),vertexShader:ls.points_vert,fragmentShader:ls.points_frag},dashed:{uniforms:mergeUniforms([us.common,us.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ls.linedashed_vert,fragmentShader:ls.linedashed_frag},depth:{uniforms:mergeUniforms([us.common,us.displacementmap]),vertexShader:ls.depth_vert,fragmentShader:ls.depth_frag},normal:{uniforms:mergeUniforms([us.common,us.bumpmap,us.normalmap,us.displacementmap,{opacity:{value:1}}]),vertexShader:ls.normal_vert,fragmentShader:ls.normal_frag},sprite:{uniforms:mergeUniforms([us.sprite,us.fog]),vertexShader:ls.sprite_vert,fragmentShader:ls.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null}},vertexShader:ls.background_vert,fragmentShader:ls.background_frag},cube:{uniforms:mergeUniforms([us.envmap,{opacity:{value:1}}]),vertexShader:ls.cube_vert,fragmentShader:ls.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ls.equirect_vert,fragmentShader:ls.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([us.common,us.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ls.distanceRGBA_vert,fragmentShader:ls.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([us.lights,us.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ls.shadow_vert,fragmentShader:ls.shadow_frag}};function WebGLBackground(e,t,n,o,c){const h=new Color(0);let d,p,m=0,g=null,y=0,x=null;function render(n,c,b,M){let S=!0===c.isScene?c.background:null;S&&S.isTexture&&(S=t.get(S));const T=e.xr,E=T.getSession&&T.getSession();E&&"additive"===E.environmentBlendMode&&(S=null),null===S?setClear(h,m):S&&S.isColor&&(setClear(S,1),M=!0),(e.autoClear||M)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),S&&(S.isCubeTexture||S.isWebGLCubeRenderTarget||S.isWebGLCubeRenderTargetTexture||S.mapping===ye)?(void 0===p&&(p=new Mesh(new BoxBufferGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(hs.cube.uniforms),vertexShader:hs.cube.vertexShader,fragmentShader:hs.cube.fragmentShader,side:w,depthTest:!1,depthWrite:!1,fog:!1})),p.geometry.deleteAttribute("normal"),p.geometry.deleteAttribute("uv"),p.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(p.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),o.update(p)),S.isWebGLCubeRenderTarget&&(S=S.texture),p.material.uniforms.envMap.value=S,p.material.uniforms.flipEnvMap.value=S.isCubeTexture?-1:1,g===S&&y===S.version&&x===e.toneMapping||(p.material.needsUpdate=!0,g=S,y=S.version,x=e.toneMapping),n.unshift(p,p.geometry,p.material,0,0,null)):S&&S.isTexture&&(void 0===d&&(d=new Mesh(new PlaneBufferGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(hs.background.uniforms),vertexShader:hs.background.vertexShader,fragmentShader:hs.background.fragmentShader,side:_,depthTest:!1,depthWrite:!1,fog:!1})),d.geometry.deleteAttribute("normal"),Object.defineProperty(d.material,"map",{get:function(){return this.uniforms.t2D.value}}),o.update(d)),d.material.uniforms.t2D.value=S,!0===S.matrixAutoUpdate&&S.updateMatrix(),d.material.uniforms.uvTransform.value.copy(S.matrix),g===S&&y===S.version&&x===e.toneMapping||(d.material.needsUpdate=!0,g=S,y=S.version,x=e.toneMapping),n.unshift(d,d.geometry,d.material,0,0,null))}function setClear(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,c)}return{getClearColor:function(){return h},setClearColor:function(e,t){h.set(e),m=void 0!==t?t:1,setClear(h,m)},getClearAlpha:function(){return m},setClearAlpha:function(e){m=e,setClear(h,m)},render:render}}function WebGLBindingStates(e,t,n,o){const c=e.getParameter(34921),h=o.isWebGL2?null:t.get("OES_vertex_array_object"),d=o.isWebGL2||null!==h,p={},m=createBindingState(null);let g=m;function setup(t,o,c,h,p){let m=!1;if(d){const e=getBindingState(h,c,o);g!==e&&(g=e,bindVertexArrayObject(g.object)),m=needsUpdate(h,p),m&&saveCache(h,p)}else{const e=!0===o.wireframe;g.geometry===h.id&&g.program===c.id&&g.wireframe===e||(g.geometry=h.id,g.program=c.id,g.wireframe=e,m=!0)}!0===t.isInstancedMesh&&(m=!0),null!==p&&n.update(p,34963),m&&(setupVertexAttributes(t,o,c,h),null!==p&&e.bindBuffer(34963,n.get(p).buffer))}function createVertexArrayObject(){return o.isWebGL2?e.createVertexArray():h.createVertexArrayOES()}function bindVertexArrayObject(t){return o.isWebGL2?e.bindVertexArray(t):h.bindVertexArrayOES(t)}function deleteVertexArrayObject(t){return o.isWebGL2?e.deleteVertexArray(t):h.deleteVertexArrayOES(t)}function getBindingState(e,t,n){const o=!0===n.wireframe;let c=p[e.id];void 0===c&&(c={},p[e.id]=c);let h=c[t.id];void 0===h&&(h={},c[t.id]=h);let d=h[o];return void 0===d&&(d=createBindingState(createVertexArrayObject()),h[o]=d),d}function createBindingState(e){const t=[],n=[],o=[];for(let h=0;h<c;h++)t[h]=0,n[h]=0,o[h]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:o,object:e,attributes:{},index:null}}function needsUpdate(e,t){const n=g.attributes,o=e.attributes;if(Object.keys(n).length!==Object.keys(o).length)return!0;for(const c in o){const e=n[c],t=o[c];if(void 0===e)return!0;if(e.attribute!==t)return!0;if(e.data!==t.data)return!0}return g.index!==t}function saveCache(e,t){const n={},o=e.attributes;for(const c in o){const e=o[c],t={};t.attribute=e,e.data&&(t.data=e.data),n[c]=t}g.attributes=n,g.index=t}function initAttributes(){const e=g.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function enableAttribute(e){enableAttributeAndDivisor(e,0)}function enableAttributeAndDivisor(n,c){const h=g.newAttributes,d=g.enabledAttributes,p=g.attributeDivisors;if(h[n]=1,0===d[n]&&(e.enableVertexAttribArray(n),d[n]=1),p[n]!==c){const h=o.isWebGL2?e:t.get("ANGLE_instanced_arrays");h[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,c),p[n]=c}}function disableUnusedAttributes(){const t=g.newAttributes,n=g.enabledAttributes;for(let o=0,c=n.length;o<c;o++)n[o]!==t[o]&&(e.disableVertexAttribArray(o),n[o]=0)}function vertexAttribPointer(t,n,c,h,d,p){!0!==o.isWebGL2||5124!==c&&5125!==c?e.vertexAttribPointer(t,n,c,h,d,p):e.vertexAttribIPointer(t,n,c,d,p)}function setupVertexAttributes(c,h,d,p){if(!1===o.isWebGL2&&(c.isInstancedMesh||p.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;initAttributes();const m=p.attributes,g=d.getAttributes(),y=h.defaultAttributeValues;for(const t in g){const o=g[t];if(o>=0){const h=m[t];if(void 0!==h){const t=h.normalized,c=h.itemSize,d=n.get(h);if(void 0===d)continue;const m=d.buffer,g=d.type,y=d.bytesPerElement;if(h.isInterleavedBufferAttribute){const n=h.data,d=n.stride,x=h.offset;n&&n.isInstancedInterleavedBuffer?(enableAttributeAndDivisor(o,n.meshPerAttribute),void 0===p._maxInstanceCount&&(p._maxInstanceCount=n.meshPerAttribute*n.count)):enableAttribute(o),e.bindBuffer(34962,m),vertexAttribPointer(o,c,g,t,d*y,x*y)}else h.isInstancedBufferAttribute?(enableAttributeAndDivisor(o,h.meshPerAttribute),void 0===p._maxInstanceCount&&(p._maxInstanceCount=h.meshPerAttribute*h.count)):enableAttribute(o),e.bindBuffer(34962,m),vertexAttribPointer(o,c,g,t,0,0)}else if("instanceMatrix"===t){const t=n.get(c.instanceMatrix);if(void 0===t)continue;const h=t.buffer,d=t.type;enableAttributeAndDivisor(o+0,1),enableAttributeAndDivisor(o+1,1),enableAttributeAndDivisor(o+2,1),enableAttributeAndDivisor(o+3,1),e.bindBuffer(34962,h),e.vertexAttribPointer(o+0,4,d,!1,64,0),e.vertexAttribPointer(o+1,4,d,!1,64,16),e.vertexAttribPointer(o+2,4,d,!1,64,32),e.vertexAttribPointer(o+3,4,d,!1,64,48)}else if("instanceColor"===t){const t=n.get(c.instanceColor);if(void 0===t)continue;const h=t.buffer,d=t.type;enableAttributeAndDivisor(o,1),e.bindBuffer(34962,h),e.vertexAttribPointer(o,3,d,!1,12,0)}else if(void 0!==y){const n=y[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(o,n);break;case 3:e.vertexAttrib3fv(o,n);break;case 4:e.vertexAttrib4fv(o,n);break;default:e.vertexAttrib1fv(o,n)}}}}disableUnusedAttributes()}function dispose(){reset();for(const e in p){const t=p[e];for(const e in t){const n=t[e];for(const e in n)deleteVertexArrayObject(n[e].object),delete n[e];delete t[e]}delete p[e]}}function releaseStatesOfGeometry(e){if(void 0===p[e.id])return;const t=p[e.id];for(const n in t){const e=t[n];for(const t in e)deleteVertexArrayObject(e[t].object),delete e[t];delete t[n]}delete p[e.id]}function releaseStatesOfProgram(e){for(const t in p){const n=p[t];if(void 0===n[e.id])continue;const o=n[e.id];for(const e in o)deleteVertexArrayObject(o[e].object),delete o[e];delete n[e.id]}}function reset(){resetDefaultState(),g!==m&&(g=m,bindVertexArrayObject(g.object))}function resetDefaultState(){m.geometry=null,m.program=null,m.wireframe=!1}return{setup:setup,reset:reset,resetDefaultState:resetDefaultState,dispose:dispose,releaseStatesOfGeometry:releaseStatesOfGeometry,releaseStatesOfProgram:releaseStatesOfProgram,initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes}}function WebGLBufferRenderer(e,t,n,o){const c=o.isWebGL2;let h;function setMode(e){h=e}function render(t,o){e.drawArrays(h,t,o),n.update(o,h,1)}function renderInstances(o,d,p){if(0===p)return;let m,g;if(c)m=e,g="drawArraysInstanced";else if(m=t.get("ANGLE_instanced_arrays"),g="drawArraysInstancedANGLE",null===m)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");m[g](h,o,d,p),n.update(d,h,p)}this.setMode=setMode,this.render=render,this.renderInstances=renderInstances}function WebGLCapabilities(e,t,n){let o;function getMaxAnisotropy(){if(void 0!==o)return o;const n=t.get("EXT_texture_filter_anisotropic");return o=null!==n?e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,o}function getMaxPrecision(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const c="undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let h=void 0!==n.precision?n.precision:"highp";const d=getMaxPrecision(h);d!==h&&(console.warn("THREE.WebGLRenderer:",h,"not supported, using",d,"instead."),h=d);const p=!0===n.logarithmicDepthBuffer,m=e.getParameter(34930),g=e.getParameter(35660),y=e.getParameter(3379),x=e.getParameter(34076),b=e.getParameter(34921),M=e.getParameter(36347),_=e.getParameter(36348),w=e.getParameter(36349),S=g>0,T=c||!!t.get("OES_texture_float"),E=S&&T,L=c?e.getParameter(36183):0;return{isWebGL2:c,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:h,logarithmicDepthBuffer:p,maxTextures:m,maxVertexTextures:g,maxTextureSize:y,maxCubemapSize:x,maxAttributes:b,maxVertexUniforms:M,maxVaryings:_,maxFragmentUniforms:w,vertexTextures:S,floatFragmentTextures:T,floatVertexTextures:E,maxSamples:L}}function WebGLClipping(e){const t=this;let n=null,o=0,c=!1,h=!1;const d=new Plane,p=new Matrix3,m={value:null,needsUpdate:!1};function resetGlobalState(){m.value!==n&&(m.value=n,m.needsUpdate=o>0),t.numPlanes=o,t.numIntersection=0}function projectPlanes(e,n,o,c){const h=null!==e?e.length:0;let g=null;if(0!==h){if(g=m.value,!0!==c||null===g){const t=o+4*h,c=n.matrixWorldInverse;p.getNormalMatrix(c),(null===g||g.length<t)&&(g=new Float32Array(t));for(let n=0,m=o;n!==h;++n,m+=4)d.copy(e[n]).applyMatrix4(c,p),d.normal.toArray(g,m),g[m+3]=d.constant}m.value=g,m.needsUpdate=!0}return t.numPlanes=h,t.numIntersection=0,g}this.uniform=m,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,h){const d=0!==e.length||t||0!==o||c;return c=t,n=projectPlanes(e,h,0),o=e.length,d},this.beginShadows=function(){h=!0,projectPlanes(null)},this.endShadows=function(){h=!1,resetGlobalState()},this.setState=function(t,d,p){const g=t.clippingPlanes,y=t.clipIntersection,x=t.clipShadows,b=e.get(t);if(!c||null===g||0===g.length||h&&!x)h?projectPlanes(null):resetGlobalState();else{const e=h?0:o,t=4*e;let c=b.clippingState||null;m.value=c,c=projectPlanes(g,d,t,p);for(let o=0;o!==t;++o)c[o]=n[o];b.clippingState=c,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=e}}}function WebGLCubeMaps(e){let t=new WeakMap;function mapTextureMapping(e,t){return t===me?e.mapping=pe:t===ge&&(e.mapping=fe),e}function get(n){if(n&&n.isTexture){const o=n.mapping;if(o===me||o===ge){if(t.has(n)){const e=t.get(n).texture;return mapTextureMapping(e,n.mapping)}{const o=n.image;if(o&&o.height>0){const c=e.getRenderList(),h=e.getRenderTarget(),d=e.getRenderState(),p=new WebGLCubeRenderTarget(o.height/2);return p.fromEquirectangularTexture(e,n),t.set(n,p),e.setRenderTarget(h),e.setRenderList(c),e.setRenderState(d),mapTextureMapping(p.texture,n.mapping)}return null}}}return n}function dispose(){t=new WeakMap}return{get:get,dispose:dispose}}function WebGLExtensions(e){const t={};return{has:function(n){if(void 0!==t[n])return null!==t[n];let o;switch(n){case"WEBGL_depth_texture":o=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=e.getExtension(n)}return t[n]=o,null!==o},get:function(e){return this.has(e)||console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t[e]}}}function WebGLGeometries(e,t,n,o){const c=new WeakMap,h=new WeakMap;function onGeometryDispose(e){const d=e.target,p=c.get(d);null!==p.index&&t.remove(p.index);for(const n in p.attributes)t.remove(p.attributes[n]);d.removeEventListener("dispose",onGeometryDispose),c.delete(d);const m=h.get(p);m&&(t.remove(m),h.delete(p)),o.releaseStatesOfGeometry(d),!0===d.isInstancedBufferGeometry&&delete d._maxInstanceCount,n.memory.geometries--}function get(e,t){let o=c.get(t);return o||(t.addEventListener("dispose",onGeometryDispose),t.isBufferGeometry?o=t:t.isGeometry&&(void 0===t._bufferGeometry&&(t._bufferGeometry=(new BufferGeometry).setFromObject(e)),o=t._bufferGeometry),c.set(t,o),n.memory.geometries++,o)}function update(e){const n=e.attributes;for(const c in n)t.update(n[c],34962);const o=e.morphAttributes;for(const c in o){const e=o[c];for(let n=0,o=e.length;n<o;n++)t.update(e[n],34962)}}function updateWireframeAttribute(e){const n=[],o=e.index,c=e.attributes.position;let d=0;if(null!==o){const e=o.array;d=o.version;for(let t=0,o=e.length;t<o;t+=3){const o=e[t+0],c=e[t+1],h=e[t+2];n.push(o,c,c,h,h,o)}}else{const e=c.array;d=c.version;for(let t=0,o=e.length/3-1;t<o;t+=3){const e=t+0,o=t+1,c=t+2;n.push(e,o,o,c,c,e)}}const p=new(arrayMax(n)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(n,1);p.version=d;const m=h.get(e);m&&t.remove(m),h.set(e,p)}function getWireframeAttribute(e){const t=h.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&updateWireframeAttribute(e)}else updateWireframeAttribute(e);return h.get(e)}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute}}function WebGLIndexedBufferRenderer(e,t,n,o){const c=o.isWebGL2;let h,d,p;function setMode(e){h=e}function setIndex(e){d=e.type,p=e.bytesPerElement}function render(t,o){e.drawElements(h,o,d,t*p),n.update(o,h,1)}function renderInstances(o,m,g){if(0===g)return;let y,x;if(c)y=e,x="drawElementsInstanced";else if(y=t.get("ANGLE_instanced_arrays"),x="drawElementsInstancedANGLE",null===y)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");y[x](h,m,d,o*p,g),n.update(m,h,g)}this.setMode=setMode,this.setIndex=setIndex,this.render=render,this.renderInstances=renderInstances}function WebGLInfo(e){const t={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function update(e,t,o){switch(n.calls++,t){case 4:n.triangles+=o*(e/3);break;case 1:n.lines+=o*(e/2);break;case 3:n.lines+=o*(e-1);break;case 2:n.lines+=o*e;break;case 0:n.points+=o*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t);break}}function reset(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:t,render:n,programs:null,autoReset:!0,reset:reset,update:update}}function numericalSort(e,t){return e[0]-t[0]}function absNumericalSort(e,t){return Math.abs(t[1])-Math.abs(e[1])}function WebGLMorphtargets(e){const t={},n=new Float32Array(8),o=[];for(let c=0;c<8;c++)o[c]=[c,0];function update(c,h,d,p){const m=c.morphTargetInfluences,g=void 0===m?0:m.length;let y=t[h.id];if(void 0===y){y=[];for(let e=0;e<g;e++)y[e]=[e,0];t[h.id]=y}for(let e=0;e<g;e++){const t=y[e];t[0]=e,t[1]=m[e]}y.sort(absNumericalSort);for(let e=0;e<8;e++)e<g&&y[e][1]?(o[e][0]=y[e][0],o[e][1]=y[e][1]):(o[e][0]=Number.MAX_SAFE_INTEGER,o[e][1]=0);o.sort(numericalSort);const x=d.morphTargets&&h.morphAttributes.position,b=d.morphNormals&&h.morphAttributes.normal;let M=0;for(let e=0;e<8;e++){const t=o[e],c=t[0],d=t[1];c!==Number.MAX_SAFE_INTEGER&&d?(x&&h.getAttribute("morphTarget"+e)!==x[c]&&h.setAttribute("morphTarget"+e,x[c]),b&&h.getAttribute("morphNormal"+e)!==b[c]&&h.setAttribute("morphNormal"+e,b[c]),n[e]=d,M+=d):(x&&void 0!==h.getAttribute("morphTarget"+e)&&h.deleteAttribute("morphTarget"+e),b&&void 0!==h.getAttribute("morphNormal"+e)&&h.deleteAttribute("morphNormal"+e),n[e]=0)}const _=h.morphTargetsRelative?1:1-M;p.getUniforms().setValue(e,"morphTargetBaseInfluence",_),p.getUniforms().setValue(e,"morphTargetInfluences",n)}return{update:update}}function WebGLObjects(e,t,n,o){let c=new WeakMap;function update(e){const h=o.render.frame,d=e.geometry,p=t.get(e,d);return c.get(p)!==h&&(d.isGeometry&&p.updateFromObject(e),t.update(p),c.set(p,h)),e.isInstancedMesh&&(n.update(e.instanceMatrix,34962),null!==e.instanceColor&&n.update(e.instanceColor,34962)),p}function dispose(){c=new WeakMap}return{update:update,dispose:dispose}}function CubeTexture(e,t,n,o,c,h,d,p,m,g){e=void 0!==e?e:[],t=void 0!==t?t:pe,d=void 0!==d?d:We,Texture.call(this,e,t,n,o,c,h,d,p,m,g),this.flipY=!1}function DataTexture2DArray(e,t,n,o){Texture.call(this,null),this.image={data:e||null,width:t||1,height:n||1,depth:o||1},this.magFilter=_e,this.minFilter=_e,this.wrapR=be,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function DataTexture3D(e,t,n,o){Texture.call(this,null),this.image={data:e||null,width:t||1,height:n||1,depth:o||1},this.magFilter=_e,this.minFilter=_e,this.wrapR=be,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}hs.physical={uniforms:mergeUniforms([hs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Color(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:ls.meshphysical_vert,fragmentShader:ls.meshphysical_frag},CubeTexture.prototype=Object.create(Texture.prototype),CubeTexture.prototype.constructor=CubeTexture,CubeTexture.prototype.isCubeTexture=!0,Object.defineProperty(CubeTexture.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}}),DataTexture2DArray.prototype=Object.create(Texture.prototype),DataTexture2DArray.prototype.constructor=DataTexture2DArray,DataTexture2DArray.prototype.isDataTexture2DArray=!0,DataTexture3D.prototype=Object.create(Texture.prototype),DataTexture3D.prototype.constructor=DataTexture3D,DataTexture3D.prototype.isDataTexture3D=!0;const ds=new Texture,ps=new DataTexture2DArray,fs=new DataTexture3D,ms=new CubeTexture,gs=[],ys=[],vs=new Float32Array(16),xs=new Float32Array(9),bs=new Float32Array(4);function flatten(e,t,n){const o=e[0];if(o<=0||o>0)return e;const c=t*n;let h=gs[c];if(void 0===h&&(h=new Float32Array(c),gs[c]=h),0!==t){o.toArray(h,0);for(let o=1,c=0;o!==t;++o)c+=n,e[o].toArray(h,c)}return h}function arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}function copyArray(e,t){for(let n=0,o=t.length;n<o;n++)e[n]=t[n]}function allocTexUnits(e,t){let n=ys[t];void 0===n&&(n=new Int32Array(t),ys[t]=n);for(let o=0;o!==t;++o)n[o]=e.allocateTextureUnit();return n}function setValueV1f(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function setValueV2f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(arraysEqual(n,t))return;e.uniform2fv(this.addr,t),copyArray(n,t)}}function setValueV3f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(arraysEqual(n,t))return;e.uniform3fv(this.addr,t),copyArray(n,t)}}function setValueV4f(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(arraysEqual(n,t))return;e.uniform4fv(this.addr,t),copyArray(n,t)}}function setValueM2(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;bs.set(o),e.uniformMatrix2fv(this.addr,!1,bs),copyArray(n,o)}}function setValueM3(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;xs.set(o),e.uniformMatrix3fv(this.addr,!1,xs),copyArray(n,o)}}function setValueM4(e,t){const n=this.cache,o=t.elements;if(void 0===o){if(arraysEqual(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),copyArray(n,t)}else{if(arraysEqual(n,o))return;vs.set(o),e.uniformMatrix4fv(this.addr,!1,vs),copyArray(n,o)}}function setValueT1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.safeSetTexture2D(t||ds,c)}function setValueT2DArray1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.setTexture2DArray(t||ps,c)}function setValueT3D1(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.setTexture3D(t||fs,c)}function setValueT6(e,t,n){const o=this.cache,c=n.allocateTextureUnit();o[0]!==c&&(e.uniform1i(this.addr,c),o[0]=c),n.safeSetTextureCube(t||ms,c)}function setValueV1i(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function setValueV2i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform2iv(this.addr,t),copyArray(n,t))}function setValueV3i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform3iv(this.addr,t),copyArray(n,t))}function setValueV4i(e,t){const n=this.cache;arraysEqual(n,t)||(e.uniform4iv(this.addr,t),copyArray(n,t))}function setValueV1ui(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function getSingularSetter(e){switch(e){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(e,t){e.uniform1fv(this.addr,t)}function setValueV1iArray(e,t){e.uniform1iv(this.addr,t)}function setValueV2iArray(e,t){e.uniform2iv(this.addr,t)}function setValueV3iArray(e,t){e.uniform3iv(this.addr,t)}function setValueV4iArray(e,t){e.uniform4iv(this.addr,t)}function setValueV2fArray(e,t){const n=flatten(t,this.size,2);e.uniform2fv(this.addr,n)}function setValueV3fArray(e,t){const n=flatten(t,this.size,3);e.uniform3fv(this.addr,n)}function setValueV4fArray(e,t){const n=flatten(t,this.size,4);e.uniform4fv(this.addr,n)}function setValueM2Array(e,t){const n=flatten(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function setValueM3Array(e,t){const n=flatten(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function setValueM4Array(e,t){const n=flatten(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function setValueT1Array(e,t,n){const o=t.length,c=allocTexUnits(n,o);e.uniform1iv(this.addr,c);for(let h=0;h!==o;++h)n.safeSetTexture2D(t[h]||ds,c[h])}function setValueT6Array(e,t,n){const o=t.length,c=allocTexUnits(n,o);e.uniform1iv(this.addr,c);for(let h=0;h!==o;++h)n.safeSetTextureCube(t[h]||ms,c[h])}function getPureArraySetter(e){switch(e){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35680:case 36300:case 36308:case 36293:return setValueT6Array}}function SingleUniform(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=getSingularSetter(t.type)}function PureArrayUniform(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=getPureArraySetter(t.type)}function StructuredUniform(e){this.id=e,this.seq=[],this.map={}}PureArrayUniform.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),copyArray(t,e)},StructuredUniform.prototype.setValue=function(e,t,n){const o=this.seq;for(let c=0,h=o.length;c!==h;++c){const h=o[c];h.setValue(e,t[h.id],n)}};const Ms=/([\w\d_]+)(\])?(\[|\.)?/g;function addUniform(e,t){e.seq.push(t),e.map[t.id]=t}function parseUniform(e,t,n){const o=e.name,c=o.length;Ms.lastIndex=0;while(1){const h=Ms.exec(o),d=Ms.lastIndex;let p=h[1];const m="]"===h[2],g=h[3];if(m&&(p|=0),void 0===g||"["===g&&d+2===c){addUniform(n,void 0===g?new SingleUniform(p,e,t):new PureArrayUniform(p,e,t));break}{const e=n.map;let t=e[p];void 0===t&&(t=new StructuredUniform(p),addUniform(n,t)),n=t}}}function WebGLUniforms(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let o=0;o<n;++o){const n=e.getActiveUniform(t,o),c=e.getUniformLocation(t,n.name);parseUniform(n,c,this)}}function WebGLShader(e,t,n){const o=e.createShader(t);return e.shaderSource(o,n),e.compileShader(o),o}WebGLUniforms.prototype.setValue=function(e,t,n,o){const c=this.map[t];void 0!==c&&c.setValue(e,n,o)},WebGLUniforms.prototype.setOptional=function(e,t,n){const o=t[n];void 0!==o&&this.setValue(e,n,o)},WebGLUniforms.upload=function(e,t,n,o){for(let c=0,h=t.length;c!==h;++c){const h=t[c],d=n[h.id];!1!==d.needsUpdate&&h.setValue(e,d.value,o)}},WebGLUniforms.seqWithValue=function(e,t){const n=[];for(let o=0,c=e.length;o!==c;++o){const c=e[o];c.id in t&&n.push(c)}return n};let _s=0;function addLineNumbers(e){const t=e.split("\n");for(let n=0;n<t.length;n++)t[n]=n+1+": "+t[n];return t.join("\n")}function getEncodingComponents(e){switch(e){case on:return["Linear","( value )"];case an:return["sRGB","( value )"];case cn:return["RGBE","( value )"];case un:return["RGBM","( value, 7.0 )"];case hn:return["RGBM","( value, 16.0 )"];case dn:return["RGBD","( value, 256.0 )"];case sn:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case ln:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function getShaderErrors(e,t,n){const o=e.getShaderParameter(t,35713),c=e.getShaderInfoLog(t).trim();if(o&&""===c)return"";const h=e.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+c+addLineNumbers(h)}function getTexelDecodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function getTexelEncodingFunction(e,t){const n=getEncodingComponents(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function getToneMappingFunction(e,t){let n;switch(t){case se:n="Linear";break;case ce:n="Reinhard";break;case le:n="OptimizedCineon";break;case ue:n="ACESFilmic";break;case he:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function generateExtensions(e){const t=[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return t.filter(filterEmptyLine).join("\n")}function generateDefines(e){const t=[];for(const n in e){const o=e[n];!1!==o&&t.push("#define "+n+" "+o)}return t.join("\n")}function fetchAttributeLocations(e,t){const n={},o=e.getProgramParameter(t,35721);for(let c=0;c<o;c++){const o=e.getActiveAttrib(t,c),h=o.name;n[h]=e.getAttribLocation(t,h)}return n}function filterEmptyLine(e){return""!==e}function replaceLightNums(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function replaceClippingPlaneNums(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const ws=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(e){return e.replace(ws,includeReplacer)}function includeReplacer(e,t){const n=ls[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return resolveIncludes(n)}const Ss=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Ts=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(e){return e.replace(Ts,loopReplacer).replace(Ss,deprecatedLoopReplacer)}function deprecatedLoopReplacer(e,t,n,o){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),loopReplacer(e,t,n,o)}function loopReplacer(e,t,n,o){let c="";for(let h=parseInt(t);h<parseInt(n);h++)c+=o.replace(/\[\s*i\s*\]/g,"[ "+h+" ]").replace(/UNROLLED_LOOP_INDEX/g,h);return c}function generatePrecision(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function generateShadowMapTypeDefine(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===x?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===b?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===M&&(t="SHADOWMAP_TYPE_VSM"),t}function generateEnvMapTypeDefine(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case pe:case fe:t="ENVMAP_TYPE_CUBE";break;case ye:case ve:t="ENVMAP_TYPE_CUBE_UV";break}return t}function generateEnvMapModeDefine(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case fe:case ve:t="ENVMAP_MODE_REFRACTION";break}return t}function generateEnvMapBlendingDefine(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case re:t="ENVMAP_BLENDING_MULTIPLY";break;case ie:t="ENVMAP_BLENDING_MIX";break;case oe:t="ENVMAP_BLENDING_ADD";break}return t}function WebGLProgram(e,t,n,o){const c=e.getContext(),h=n.defines;let d=n.vertexShader,p=n.fragmentShader;const m=generateShadowMapTypeDefine(n),g=generateEnvMapTypeDefine(n),y=generateEnvMapModeDefine(n),x=generateEnvMapBlendingDefine(n),b=e.gammaFactor>0?e.gammaFactor:1,M=n.isWebGL2?"":generateExtensions(n),_=generateDefines(h),w=c.createProgram();let S,T,E=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(S=[_].filter(filterEmptyLine).join("\n"),S.length>0&&(S+="\n"),T=[M,_].filter(filterEmptyLine).join("\n"),T.length>0&&(T+="\n")):(S=[generatePrecision(n),"#define SHADER_NAME "+n.shaderName,_,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+b,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+y:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+m:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(filterEmptyLine).join("\n"),T=[M,generatePrecision(n),"#define SHADER_NAME "+n.shaderName,_,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+b,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+g:"",n.envMap?"#define "+y:"",n.envMap?"#define "+x:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+m:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==ae?"#define TONE_MAPPING":"",n.toneMapping!==ae?ls["tonemapping_pars_fragment"]:"",n.toneMapping!==ae?getToneMappingFunction("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",ls["encodings_pars_fragment"],n.map?getTexelDecodingFunction("mapTexelToLinear",n.mapEncoding):"",n.matcap?getTexelDecodingFunction("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?getTexelDecodingFunction("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?getTexelDecodingFunction("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?getTexelDecodingFunction("lightMapTexelToLinear",n.lightMapEncoding):"",getTexelEncodingFunction("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(filterEmptyLine).join("\n")),d=resolveIncludes(d),d=replaceLightNums(d,n),d=replaceClippingPlaneNums(d,n),p=resolveIncludes(p),p=replaceLightNums(p,n),p=replaceClippingPlaneNums(p,n),d=unrollLoops(d),p=unrollLoops(p),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(E="#version 300 es\n",S=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+S,T=["#define varying in",n.glslVersion===kn?"":"out highp vec4 pc_fragColor;",n.glslVersion===kn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+T);const L=E+S+d,A=E+T+p,C=WebGLShader(c,35633,L),P=WebGLShader(c,35632,A);if(c.attachShader(w,C),c.attachShader(w,P),void 0!==n.index0AttributeName?c.bindAttribLocation(w,0,n.index0AttributeName):!0===n.morphTargets&&c.bindAttribLocation(w,0,"position"),c.linkProgram(w),e.debug.checkShaderErrors){const e=c.getProgramInfoLog(w).trim(),t=c.getShaderInfoLog(C).trim(),n=c.getShaderInfoLog(P).trim();let o=!0,h=!0;if(!1===c.getProgramParameter(w,35714)){o=!1;const t=getShaderErrors(c,C,"vertex"),n=getShaderErrors(c,P,"fragment");console.error("THREE.WebGLProgram: shader error: ",c.getError(),"35715",c.getProgramParameter(w,35715),"gl.getProgramInfoLog",e,t,n)}else""!==e?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",e):""!==t&&""!==n||(h=!1);h&&(this.diagnostics={runnable:o,programLog:e,vertexShader:{log:t,prefix:S},fragmentShader:{log:n,prefix:T}})}let R,B;return c.deleteShader(C),c.deleteShader(P),this.getUniforms=function(){return void 0===R&&(R=new WebGLUniforms(c,w)),R},this.getAttributes=function(){return void 0===B&&(B=fetchAttributeLocations(c,w)),B},this.destroy=function(){o.releaseStatesOfProgram(this),c.deleteProgram(w),this.program=void 0},this.name=n.shaderName,this.id=_s++,this.cacheKey=t,this.usedTimes=1,this.program=w,this.vertexShader=C,this.fragmentShader=P,this}function WebGLPrograms(e,t,n,o,c,h){const d=[],p=o.isWebGL2,m=o.logarithmicDepthBuffer,g=o.floatVertexTextures,y=o.maxVertexUniforms,x=o.vertexTextures;let b=o.precision;const M={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},_=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function getMaxBones(e){const t=e.skeleton,n=t.bones;if(g)return 1024;{const e=y,t=Math.floor((e-20)/4),o=Math.min(t,n.length);return o<n.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+n.length+" bones. This GPU supports "+o+"."),0):o}}function getTextureEncodingFromMap(e){let t;return e?e.isTexture?t=e.encoding:e.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=on,t}function getParameters(c,d,y,_,T){const E=_.fog,L=c.isMeshStandardMaterial?_.environment:null,A=t.get(c.envMap||L),C=M[c.type],P=T.isSkinnedMesh?getMaxBones(T):0;let R,B;if(null!==c.precision&&(b=o.getMaxPrecision(c.precision),b!==c.precision&&console.warn("THREE.WebGLProgram.getParameters:",c.precision,"not supported, using",b,"instead.")),C){const e=hs[C];R=e.vertexShader,B=e.fragmentShader}else R=c.vertexShader,B=c.fragmentShader;const D=e.getRenderTarget(),G={isWebGL2:p,shaderID:C,shaderName:c.type,vertexShader:R,fragmentShader:B,defines:c.defines,isRawShaderMaterial:!0===c.isRawShaderMaterial,glslVersion:c.glslVersion,precision:b,instancing:!0===T.isInstancedMesh,instancingColor:!0===T.isInstancedMesh&&null!==T.instanceColor,supportsVertexTextures:x,outputEncoding:null!==D?getTextureEncodingFromMap(D.texture):e.outputEncoding,map:!!c.map,mapEncoding:getTextureEncodingFromMap(c.map),matcap:!!c.matcap,matcapEncoding:getTextureEncodingFromMap(c.matcap),envMap:!!A,envMapMode:A&&A.mapping,envMapEncoding:getTextureEncodingFromMap(A),envMapCubeUV:!!A&&(A.mapping===ye||A.mapping===ve),lightMap:!!c.lightMap,lightMapEncoding:getTextureEncodingFromMap(c.lightMap),aoMap:!!c.aoMap,emissiveMap:!!c.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(c.emissiveMap),bumpMap:!!c.bumpMap,normalMap:!!c.normalMap,objectSpaceNormalMap:c.normalMapType===gn,tangentSpaceNormalMap:c.normalMapType===mn,clearcoatMap:!!c.clearcoatMap,clearcoatRoughnessMap:!!c.clearcoatRoughnessMap,clearcoatNormalMap:!!c.clearcoatNormalMap,displacementMap:!!c.displacementMap,roughnessMap:!!c.roughnessMap,metalnessMap:!!c.metalnessMap,specularMap:!!c.specularMap,alphaMap:!!c.alphaMap,gradientMap:!!c.gradientMap,sheen:!!c.sheen,transmissionMap:!!c.transmissionMap,combine:c.combine,vertexTangents:c.normalMap&&c.vertexTangents,vertexColors:c.vertexColors,vertexUvs:!!c.map||!!c.bumpMap||!!c.normalMap||!!c.specularMap||!!c.alphaMap||!!c.emissiveMap||!!c.roughnessMap||!!c.metalnessMap||!!c.clearcoatMap||!!c.clearcoatRoughnessMap||!!c.clearcoatNormalMap||!!c.displacementMap||!!c.transmissionMap,uvsVertexOnly:!(c.map||c.bumpMap||c.normalMap||c.specularMap||c.alphaMap||c.emissiveMap||c.roughnessMap||c.metalnessMap||c.clearcoatNormalMap||c.transmissionMap)&&!!c.displacementMap,fog:!!E,useFog:c.fog,fogExp2:E&&E.isFogExp2,flatShading:c.flatShading,sizeAttenuation:c.sizeAttenuation,logarithmicDepthBuffer:m,skinning:c.skinning&&P>0,maxBones:P,useVertexTexture:g,morphTargets:c.morphTargets,morphNormals:c.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:d.directional.length,numPointLights:d.point.length,numSpotLights:d.spot.length,numRectAreaLights:d.rectArea.length,numHemiLights:d.hemi.length,numDirLightShadows:d.directionalShadowMap.length,numPointLightShadows:d.pointShadowMap.length,numSpotLightShadows:d.spotShadowMap.length,numClippingPlanes:h.numPlanes,numClipIntersection:h.numIntersection,dithering:c.dithering,shadowMapEnabled:e.shadowMap.enabled&&y.length>0,shadowMapType:e.shadowMap.type,toneMapping:c.toneMapped?e.toneMapping:ae,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:c.premultipliedAlpha,alphaTest:c.alphaTest,doubleSided:c.side===S,flipSided:c.side===w,depthPacking:void 0!==c.depthPacking&&c.depthPacking,index0AttributeName:c.index0AttributeName,extensionDerivatives:c.extensions&&c.extensions.derivatives,extensionFragDepth:c.extensions&&c.extensions.fragDepth,extensionDrawBuffers:c.extensions&&c.extensions.drawBuffers,extensionShaderTextureLOD:c.extensions&&c.extensions.shaderTextureLOD,rendererExtensionFragDepth:p||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:p||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:p||n.has("EXT_shader_texture_lod"),customProgramCacheKey:c.customProgramCacheKey()};return G}function getProgramCacheKey(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.fragmentShader),n.push(t.vertexShader)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);if(!1===t.isRawShaderMaterial){for(let e=0;e<_.length;e++)n.push(t[_[e]]);n.push(e.outputEncoding),n.push(e.gammaFactor)}return n.push(t.customProgramCacheKey),n.join()}function getUniforms(e){const t=M[e.type];let n;if(t){const e=hs[t];n=Gi.clone(e.uniforms)}else n=e.uniforms;return n}function acquireProgram(t,n){let o;for(let e=0,c=d.length;e<c;e++){const t=d[e];if(t.cacheKey===n){o=t,++o.usedTimes;break}}return void 0===o&&(o=new WebGLProgram(e,n,t,c),d.push(o)),o}function releaseProgram(e){if(0===--e.usedTimes){const t=d.indexOf(e);d[t]=d[d.length-1],d.pop(),e.destroy()}}return{getParameters:getParameters,getProgramCacheKey:getProgramCacheKey,getUniforms:getUniforms,acquireProgram:acquireProgram,releaseProgram:releaseProgram,programs:d}}function WebGLProperties(){let e=new WeakMap;function get(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n}function remove(t){e.delete(t)}function update(t,n,o){e.get(t)[n]=o}function dispose(){e=new WeakMap}return{get:get,remove:remove,update:update,dispose:dispose}}function painterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function reversePainterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WebGLRenderList(e){const t=[];let n=0;const o=[],c=[],h={id:-1};function init(){n=0,o.length=0,c.length=0}function getNextRenderItem(o,c,d,p,m,g){let y=t[n];const x=e.get(d);return void 0===y?(y={id:o.id,object:o,geometry:c,material:d,program:x.program||h,groupOrder:p,renderOrder:o.renderOrder,z:m,group:g},t[n]=y):(y.id=o.id,y.object=o,y.geometry=c,y.material=d,y.program=x.program||h,y.groupOrder=p,y.renderOrder=o.renderOrder,y.z=m,y.group=g),n++,y}function push(e,t,n,h,d,p){const m=getNextRenderItem(e,t,n,h,d,p);(!0===n.transparent?c:o).push(m)}function unshift(e,t,n,h,d,p){const m=getNextRenderItem(e,t,n,h,d,p);(!0===n.transparent?c:o).unshift(m)}function sort(e,t){o.length>1&&o.sort(e||painterSortStable),c.length>1&&c.sort(t||reversePainterSortStable)}function finish(){for(let e=n,o=t.length;e<o;e++){const n=t[e];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}}return{opaque:o,transparent:c,init:init,push:push,unshift:unshift,finish:finish,sort:sort}}function WebGLRenderLists(e){let t=new WeakMap;function get(n,o){const c=t.get(n);let h;return void 0===c?(h=new WebGLRenderList(e),t.set(n,new WeakMap),t.get(n).set(o,h)):(h=c.get(o),void 0===h&&(h=new WebGLRenderList(e),c.set(o,h))),h}function dispose(){t=new WeakMap}return{get:get,dispose:dispose}}function UniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new Vector3,color:new Color};break;case"SpotLight":n={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":n={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":n={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return e[t.id]=n,n}}}function ShadowUniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return e[t.id]=n,n}}}let Es=0;function shadowCastingLightsFirst(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function WebGLLights(){const e=new UniformsCache,t=ShadowUniformsCache(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let d=0;d<9;d++)n.probe.push(new Vector3);const o=new Vector3,c=new Matrix4,h=new Matrix4;function setup(d,p,m){let g=0,y=0,x=0;for(let e=0;e<9;e++)n.probe[e].set(0,0,0);let b=0,M=0,_=0,w=0,S=0,T=0,E=0,L=0;const A=m.matrixWorldInverse;d.sort(shadowCastingLightsFirst);for(let P=0,R=d.length;P<R;P++){const p=d[P],m=p.color,C=p.intensity,R=p.distance,B=p.shadow&&p.shadow.map?p.shadow.map.texture:null;if(p.isAmbientLight)g+=m.r*C,y+=m.g*C,x+=m.b*C;else if(p.isLightProbe)for(let e=0;e<9;e++)n.probe[e].addScaledVector(p.sh.coefficients[e],C);else if(p.isDirectionalLight){const c=e.get(p);if(c.color.copy(p.color).multiplyScalar(p.intensity),c.direction.setFromMatrixPosition(p.matrixWorld),o.setFromMatrixPosition(p.target.matrixWorld),c.direction.sub(o),c.direction.transformDirection(A),p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,n.directionalShadow[b]=o,n.directionalShadowMap[b]=B,n.directionalShadowMatrix[b]=p.shadow.matrix,T++}n.directional[b]=c,b++}else if(p.isSpotLight){const c=e.get(p);if(c.position.setFromMatrixPosition(p.matrixWorld),c.position.applyMatrix4(A),c.color.copy(m).multiplyScalar(C),c.distance=R,c.direction.setFromMatrixPosition(p.matrixWorld),o.setFromMatrixPosition(p.target.matrixWorld),c.direction.sub(o),c.direction.transformDirection(A),c.coneCos=Math.cos(p.angle),c.penumbraCos=Math.cos(p.angle*(1-p.penumbra)),c.decay=p.decay,p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,n.spotShadow[_]=o,n.spotShadowMap[_]=B,n.spotShadowMatrix[_]=p.shadow.matrix,L++}n.spot[_]=c,_++}else if(p.isRectAreaLight){const t=e.get(p);t.color.copy(m).multiplyScalar(C),t.position.setFromMatrixPosition(p.matrixWorld),t.position.applyMatrix4(A),h.identity(),c.copy(p.matrixWorld),c.premultiply(A),h.extractRotation(c),t.halfWidth.set(.5*p.width,0,0),t.halfHeight.set(0,.5*p.height,0),t.halfWidth.applyMatrix4(h),t.halfHeight.applyMatrix4(h),n.rectArea[w]=t,w++}else if(p.isPointLight){const o=e.get(p);if(o.position.setFromMatrixPosition(p.matrixWorld),o.position.applyMatrix4(A),o.color.copy(p.color).multiplyScalar(p.intensity),o.distance=p.distance,o.decay=p.decay,p.castShadow){const e=p.shadow,o=t.get(p);o.shadowBias=e.bias,o.shadowNormalBias=e.normalBias,o.shadowRadius=e.radius,o.shadowMapSize=e.mapSize,o.shadowCameraNear=e.camera.near,o.shadowCameraFar=e.camera.far,n.pointShadow[M]=o,n.pointShadowMap[M]=B,n.pointShadowMatrix[M]=p.shadow.matrix,E++}n.point[M]=o,M++}else if(p.isHemisphereLight){const t=e.get(p);t.direction.setFromMatrixPosition(p.matrixWorld),t.direction.transformDirection(A),t.direction.normalize(),t.skyColor.copy(p.color).multiplyScalar(C),t.groundColor.copy(p.groundColor).multiplyScalar(C),n.hemi[S]=t,S++}}w>0&&(n.rectAreaLTC1=us.LTC_1,n.rectAreaLTC2=us.LTC_2),n.ambient[0]=g,n.ambient[1]=y,n.ambient[2]=x;const C=n.hash;C.directionalLength===b&&C.pointLength===M&&C.spotLength===_&&C.rectAreaLength===w&&C.hemiLength===S&&C.numDirectionalShadows===T&&C.numPointShadows===E&&C.numSpotShadows===L||(n.directional.length=b,n.spot.length=_,n.rectArea.length=w,n.point.length=M,n.hemi.length=S,n.directionalShadow.length=T,n.directionalShadowMap.length=T,n.pointShadow.length=E,n.pointShadowMap.length=E,n.spotShadow.length=L,n.spotShadowMap.length=L,n.directionalShadowMatrix.length=T,n.pointShadowMatrix.length=E,n.spotShadowMatrix.length=L,C.directionalLength=b,C.pointLength=M,C.spotLength=_,C.rectAreaLength=w,C.hemiLength=S,C.numDirectionalShadows=T,C.numPointShadows=E,C.numSpotShadows=L,n.version=Es++)}return{setup:setup,state:n}}function WebGLRenderState(){const e=new WebGLLights,t=[],n=[];function init(){t.length=0,n.length=0}function pushLight(e){t.push(e)}function pushShadow(e){n.push(e)}function setupLights(o){e.setup(t,n,o)}const o={lightsArray:t,shadowsArray:n,lights:e};return{init:init,state:o,setupLights:setupLights,pushLight:pushLight,pushShadow:pushShadow}}function WebGLRenderStates(){let e=new WeakMap;function get(t,n){let o;return!1===e.has(t)?(o=new WebGLRenderState,e.set(t,new WeakMap),e.get(t).set(n,o)):!1===e.get(t).has(n)?(o=new WebGLRenderState,e.get(t).set(n,o)):o=e.get(t).get(n),o}function dispose(){e=new WeakMap}return{get:get,dispose:dispose}}function MeshDepthMaterial(e){Material.call(this),this.type="MeshDepthMaterial",this.depthPacking=pn,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function MeshDistanceMaterial(e){Material.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Vector3,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}MeshDepthMaterial.prototype=Object.create(Material.prototype),MeshDepthMaterial.prototype.constructor=MeshDepthMaterial,MeshDepthMaterial.prototype.isMeshDepthMaterial=!0,MeshDepthMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},MeshDistanceMaterial.prototype=Object.create(Material.prototype),MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial,MeshDistanceMaterial.prototype.isMeshDistanceMaterial=!0,MeshDistanceMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this};var Ls="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",As="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";function WebGLShadowMap(e,t,n){let o=new Frustum;const c=new Vector2,h=new Vector2,d=new Vector4,p=[],m=[],g={},y={0:w,1:_,2:S},b=new ShaderMaterial({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:As,fragmentShader:Ls}),T=b.clone();T.defines.HORIZONAL_PASS=1;const E=new BufferGeometry;E.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const A=new Mesh(E,b),C=this;function VSMPass(n,o){const c=t.update(A);b.uniforms.shadow_pass.value=n.map.texture,b.uniforms.resolution.value=n.mapSize,b.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(o,null,c,b,A,null),T.uniforms.shadow_pass.value=n.mapPass.texture,T.uniforms.resolution.value=n.mapSize,T.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(o,null,c,T,A,null)}function getDepthMaterialVariant(e,t,n){const o=e<<0|t<<1|n<<2;let c=p[o];return void 0===c&&(c=new MeshDepthMaterial({depthPacking:fn,morphTargets:e,skinning:t}),p[o]=c),c}function getDistanceMaterialVariant(e,t,n){const o=e<<0|t<<1|n<<2;let c=m[o];return void 0===c&&(c=new MeshDistanceMaterial({morphTargets:e,skinning:t}),m[o]=c),c}function getDepthMaterial(t,n,o,c,h,d,p){let m=null,x=getDepthMaterialVariant,b=t.customDepthMaterial;if(!0===c.isPointLight&&(x=getDistanceMaterialVariant,b=t.customDistanceMaterial),void 0===b){let e=!1;!0===o.morphTargets&&(e=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let c=!1;!0===t.isSkinnedMesh&&(!0===o.skinning?c=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t));const h=!0===t.isInstancedMesh;m=x(e,c,h)}else m=b;if(e.localClippingEnabled&&!0===o.clipShadows&&0!==o.clippingPlanes.length){const e=m.uuid,t=o.uuid;let n=g[e];void 0===n&&(n={},g[e]=n);let c=n[t];void 0===c&&(c=m.clone(),n[t]=c),m=c}return m.visible=o.visible,m.wireframe=o.wireframe,m.side=p===M?null!==o.shadowSide?o.shadowSide:o.side:null!==o.shadowSide?o.shadowSide:y[o.side],m.clipShadows=o.clipShadows,m.clippingPlanes=o.clippingPlanes,m.clipIntersection=o.clipIntersection,m.wireframeLinewidth=o.wireframeLinewidth,m.linewidth=o.linewidth,!0===c.isPointLight&&!0===m.isMeshDistanceMaterial&&(m.referencePosition.setFromMatrixPosition(c.matrixWorld),m.nearDistance=h,m.farDistance=d),m}function renderObject(n,c,h,d,p){if(!1===n.visible)return;const m=n.layers.test(c.layers);if(m&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&p===M)&&(!n.frustumCulled||o.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(h.matrixWorldInverse,n.matrixWorld);const o=t.update(n),c=n.material;if(Array.isArray(c)){const t=o.groups;for(let m=0,g=t.length;m<g;m++){const g=t[m],y=c[g.materialIndex];if(y&&y.visible){const t=getDepthMaterial(n,o,y,d,h.near,h.far,p);e.renderBufferDirect(h,null,o,t,n,g)}}}else if(c.visible){const t=getDepthMaterial(n,o,c,d,h.near,h.far,p);e.renderBufferDirect(h,null,o,t,n,null)}}const g=n.children;for(let e=0,t=g.length;e<t;e++)renderObject(g[e],c,h,d,p)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=x,this.render=function(t,p,m){if(!1===C.enabled)return;if(!1===C.autoUpdate&&!1===C.needsUpdate)return;if(0===t.length)return;const g=e.getRenderTarget(),y=e.getActiveCubeFace(),x=e.getActiveMipmapLevel(),b=e.state;b.setBlending(L),b.buffers.color.setClear(1,1,1,1),b.buffers.depth.setTest(!0),b.setScissorTest(!1);for(let _=0,w=t.length;_<w;_++){const g=t[_],y=g.shadow;if(!1===y.autoUpdate&&!1===y.needsUpdate)continue;if(void 0===y){console.warn("THREE.WebGLShadowMap:",g,"has no shadow.");continue}c.copy(y.mapSize);const x=y.getFrameExtents();if(c.multiply(x),h.copy(y.mapSize),(c.x>n||c.y>n)&&(c.x>n&&(h.x=Math.floor(n/x.x),c.x=h.x*x.x,y.mapSize.x=h.x),c.y>n&&(h.y=Math.floor(n/x.y),c.y=h.y*x.y,y.mapSize.y=h.y)),null===y.map&&!y.isPointLightShadow&&this.type===M){const e={minFilter:Le,magFilter:Le,format:qe};y.map=new WebGLRenderTarget(c.x,c.y,e),y.map.texture.name=g.name+".shadowMap",y.mapPass=new WebGLRenderTarget(c.x,c.y,e),y.camera.updateProjectionMatrix()}if(null===y.map){const e={minFilter:_e,magFilter:_e,format:qe};y.map=new WebGLRenderTarget(c.x,c.y,e),y.map.texture.name=g.name+".shadowMap",y.camera.updateProjectionMatrix()}e.setRenderTarget(y.map),e.clear();const w=y.getViewportCount();for(let e=0;e<w;e++){const t=y.getViewport(e);d.set(h.x*t.x,h.y*t.y,h.x*t.z,h.y*t.w),b.viewport(d),y.updateMatrices(g,e),o=y.getFrustum(),renderObject(p,m,y.camera,g,this.type)}y.isPointLightShadow||this.type!==M||VSMPass(y,m),y.needsUpdate=!1}C.needsUpdate=!1,e.setRenderTarget(g,y,x)}}function WebGLState(e,t,n){const o=n.isWebGL2;function ColorBuffer(){let t=!1;const n=new Vector4;let o=null;const c=new Vector4(0,0,0,0);return{setMask:function(n){o===n||t||(e.colorMask(n,n,n,n),o=n)},setLocked:function(e){t=e},setClear:function(t,o,h,d,p){!0===p&&(t*=d,o*=d,h*=d),n.set(t,o,h,d),!1===c.equals(n)&&(e.clearColor(t,o,h,d),c.copy(n))},reset:function(){t=!1,o=null,c.set(-1,0,0,0)}}}function DepthBuffer(){let t=!1,n=null,o=null,c=null;return{setTest:function(e){e?enable(2929):disable(2929)},setMask:function(o){n===o||t||(e.depthMask(o),n=o)},setFunc:function(t){if(o!==t){if(t)switch(t){case Z:e.depthFunc(512);break;case J:e.depthFunc(519);break;case Q:e.depthFunc(513);break;case K:e.depthFunc(515);break;case $:e.depthFunc(514);break;case ee:e.depthFunc(518);break;case te:e.depthFunc(516);break;case ne:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);o=t}},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearDepth(t),c=t)},reset:function(){t=!1,n=null,o=null,c=null}}}function StencilBuffer(){let t=!1,n=null,o=null,c=null,h=null,d=null,p=null,m=null,g=null;return{setTest:function(e){t||(e?enable(2960):disable(2960))},setMask:function(o){n===o||t||(e.stencilMask(o),n=o)},setFunc:function(t,n,d){o===t&&c===n&&h===d||(e.stencilFunc(t,n,d),o=t,c=n,h=d)},setOp:function(t,n,o){d===t&&p===n&&m===o||(e.stencilOp(t,n,o),d=t,p=n,m=o)},setLocked:function(e){t=e},setClear:function(t){g!==t&&(e.clearStencil(t),g=t)},reset:function(){t=!1,n=null,o=null,c=null,h=null,d=null,p=null,m=null,g=null}}}const c=new ColorBuffer,h=new DepthBuffer,g=new StencilBuffer;let y={},x=null,b=null,M=null,_=null,T=null,E=null,re=null,ie=null,oe=null,ae=!1,se=null,ce=null,le=null,ue=null,he=null;const de=e.getParameter(35661);let pe=!1,fe=0;const me=e.getParameter(7938);-1!==me.indexOf("WebGL")?(fe=parseFloat(/^WebGL\ ([0-9])/.exec(me)[1]),pe=fe>=1):-1!==me.indexOf("OpenGL ES")&&(fe=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(me)[1]),pe=fe>=2);let ge=null,ye={};const ve=new Vector4,xe=new Vector4;function createTexture(t,n,o){const c=new Uint8Array(4),h=e.createTexture();e.bindTexture(t,h),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let d=0;d<o;d++)e.texImage2D(n+d,0,6408,1,1,0,6408,5121,c);return h}const be={};function enable(t){!0!==y[t]&&(e.enable(t),y[t]=!0)}function disable(t){!1!==y[t]&&(e.disable(t),y[t]=!1)}function useProgram(t){return x!==t&&(e.useProgram(t),x=t,!0)}be[3553]=createTexture(3553,3553,1),be[34067]=createTexture(34067,34069,6),c.setClear(0,0,0,1),h.setClear(1),g.setClear(0),enable(2929),h.setFunc(K),setFlipSided(!1),setCullFace(p),enable(2884),setBlending(L);const Me={[D]:32774,[G]:32778,[I]:32779};if(o)Me[O]=32775,Me[V]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(Me[O]=e.MIN_EXT,Me[V]=e.MAX_EXT)}const _e={[N]:0,[F]:1,[U]:768,[H]:770,[Y]:776,[q]:774,[j]:772,[z]:769,[k]:771,[X]:775,[W]:773};function setBlending(t,n,o,c,h,d,p,m){if(t!==L){if(b||(enable(3042),b=!0),t===B)h=h||n,d=d||o,p=p||c,n===_&&h===re||(e.blendEquationSeparate(Me[n],Me[h]),_=n,re=h),o===T&&c===E&&d===ie&&p===oe||(e.blendFuncSeparate(_e[o],_e[c],_e[d],_e[p]),T=o,E=c,ie=d,oe=p),M=t,ae=null;else if(t!==M||m!==ae){if(_===D&&re===D||(e.blendEquation(32774),_=D,re=D),m)switch(t){case A:e.blendFuncSeparate(1,771,1,771);break;case C:e.blendFunc(1,1);break;case P:e.blendFuncSeparate(0,0,769,771);break;case R:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}else switch(t){case A:e.blendFuncSeparate(770,771,1,771);break;case C:e.blendFunc(770,1);break;case P:e.blendFunc(0,769);break;case R:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}T=null,E=null,ie=null,oe=null,M=t,ae=m}}else b&&(disable(3042),b=!1)}function setMaterial(e,t){e.side===S?disable(2884):enable(2884);let n=e.side===w;t&&(n=!n),setFlipSided(n),e.blending===A&&!1===e.transparent?setBlending(L):setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),h.setFunc(e.depthFunc),h.setTest(e.depthTest),h.setMask(e.depthWrite),c.setMask(e.colorWrite);const o=e.stencilWrite;g.setTest(o),o&&(g.setMask(e.stencilWriteMask),g.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),g.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits)}function setFlipSided(t){se!==t&&(t?e.frontFace(2304):e.frontFace(2305),se=t)}function setCullFace(t){t!==d?(enable(2884),t!==ce&&(t===p?e.cullFace(1029):t===m?e.cullFace(1028):e.cullFace(1032))):disable(2884),ce=t}function setLineWidth(t){t!==le&&(pe&&e.lineWidth(t),le=t)}function setPolygonOffset(t,n,o){t?(enable(32823),ue===n&&he===o||(e.polygonOffset(n,o),ue=n,he=o)):disable(32823)}function setScissorTest(e){e?enable(3089):disable(3089)}function activeTexture(t){void 0===t&&(t=33984+de-1),ge!==t&&(e.activeTexture(t),ge=t)}function bindTexture(t,n){null===ge&&activeTexture();let o=ye[ge];void 0===o&&(o={type:void 0,texture:void 0},ye[ge]=o),o.type===t&&o.texture===n||(e.bindTexture(t,n||be[t]),o.type=t,o.texture=n)}function unbindTexture(){const t=ye[ge];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)}function compressedTexImage2D(){try{e.compressedTexImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function texImage2D(){try{e.texImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function texImage3D(){try{e.texImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}}function scissor(t){!1===ve.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),ve.copy(t))}function viewport(t){!1===xe.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),xe.copy(t))}function reset(){y={},ge=null,ye={},x=null,M=null,se=null,ce=null,c.reset(),h.reset(),g.reset()}return{buffers:{color:c,depth:h,stencil:g},enable:enable,disable:disable,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset}}function WebGLTextures(e,t,n,o,c,h,d){const p=c.isWebGL2,m=c.maxTextures,g=c.maxCubemapSize,y=c.maxTextureSize,x=c.maxSamples,b=new WeakMap;let M,_=!1;try{_="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(A){}function createCanvas(e,t){return _?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function resizeImage(e,t,n,o){let c=1;if((e.width>o||e.height>o)&&(c=o/Math.max(e.width,e.height)),c<1||!0===t){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap){const o=t?qn.floorPowerOfTwo:Math.floor,h=o(c*e.width),d=o(c*e.height);void 0===M&&(M=createCanvas(h,d));const p=n?createCanvas(h,d):M;p.width=h,p.height=d;const m=p.getContext("2d");return m.drawImage(e,0,0,h,d),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+h+"x"+d+")."),p}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function isPowerOfTwo(e){return qn.isPowerOfTwo(e.width)&&qn.isPowerOfTwo(e.height)}function textureNeedsPowerOfTwo(e){return!p&&(e.wrapS!==be||e.wrapT!==be||e.minFilter!==_e&&e.minFilter!==Le)}function textureNeedsGenerateMipmaps(e,t){return e.generateMipmaps&&t&&e.minFilter!==_e&&e.minFilter!==Le}function generateMipmap(t,n,c,h){e.generateMipmap(t);const d=o.get(n);d.__maxMipLevel=Math.log(Math.max(c,h))*Math.LOG2E}function getInternalFormat(n,o,c){if(!1===p)return o;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let h=o;return 6403===o&&(5126===c&&(h=33326),5131===c&&(h=33325),5121===c&&(h=33321)),6407===o&&(5126===c&&(h=34837),5131===c&&(h=34843),5121===c&&(h=32849)),6408===o&&(5126===c&&(h=34836),5131===c&&(h=34842),5121===c&&(h=32856)),33325!==h&&33326!==h&&34842!==h&&34836!==h||t.get("EXT_color_buffer_float"),h}function filterFallback(e){return e===_e||e===we||e===Te?9728:9729}function onTextureDispose(e){const t=e.target;t.removeEventListener("dispose",onTextureDispose),deallocateTexture(t),t.isVideoTexture&&b.delete(t),d.memory.textures--}function onRenderTargetDispose(e){const t=e.target;t.removeEventListener("dispose",onRenderTargetDispose),deallocateRenderTarget(t),d.memory.textures--}function deallocateTexture(t){const n=o.get(t);void 0!==n.__webglInit&&(e.deleteTexture(n.__webglTexture),o.remove(t))}function deallocateRenderTarget(t){const n=o.get(t),c=o.get(t.texture);if(t){if(void 0!==c.__webglTexture&&e.deleteTexture(c.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer&&e.deleteRenderbuffer(n.__webglColorRenderbuffer),n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer);o.remove(t.texture),o.remove(t)}}let w=0;function resetTextureUnits(){w=0}function allocateTextureUnit(){const e=w;return e>=m&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+m),w+=1,e}function setTexture2D(e,t){const c=o.get(e);if(e.isVideoTexture&&updateVideoTexture(e),e.version>0&&c.__version!==e.version){const n=e.image;if(void 0===n)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==n.complete)return void uploadTexture(c,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+t),n.bindTexture(3553,c.__webglTexture)}function setTexture2DArray(e,t){const c=o.get(e);e.version>0&&c.__version!==e.version?uploadTexture(c,e,t):(n.activeTexture(33984+t),n.bindTexture(35866,c.__webglTexture))}function setTexture3D(e,t){const c=o.get(e);e.version>0&&c.__version!==e.version?uploadTexture(c,e,t):(n.activeTexture(33984+t),n.bindTexture(32879,c.__webglTexture))}function setTextureCube(t,c){if(6!==t.image.length)return;const d=o.get(t);if(t.version>0&&d.__version!==t.version){initTexture(d,t),n.activeTexture(33984+c),n.bindTexture(34067,d.__webglTexture),e.pixelStorei(37440,t.flipY);const o=t&&(t.isCompressedTexture||t.image[0].isCompressedTexture),m=t.image[0]&&t.image[0].isDataTexture,y=[];for(let e=0;e<6;e++)y[e]=o||m?m?t.image[e].image:t.image[e]:resizeImage(t.image[e],!1,!0,g);const x=y[0],b=isPowerOfTwo(x)||p,M=h.convert(t.format),_=h.convert(t.type),w=getInternalFormat(t.internalFormat,M,_);let S;if(setTextureParameters(34067,t,b),o){for(let e=0;e<6;e++){S=y[e].mipmaps;for(let o=0;o<S.length;o++){const c=S[o];t.format!==qe&&t.format!==We?null!==M?n.compressedTexImage2D(34069+e,o,w,c.width,c.height,0,c.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+e,o,w,c.width,c.height,0,M,_,c.data)}}d.__maxMipLevel=S.length-1}else{S=t.mipmaps;for(let e=0;e<6;e++)if(m){n.texImage2D(34069+e,0,w,y[e].width,y[e].height,0,M,_,y[e].data);for(let t=0;t<S.length;t++){const o=S[t],c=o.image[e].image;n.texImage2D(34069+e,t+1,w,c.width,c.height,0,M,_,c.data)}}else{n.texImage2D(34069+e,0,w,M,_,y[e]);for(let t=0;t<S.length;t++){const o=S[t];n.texImage2D(34069+e,t+1,w,M,_,o.image[e])}}d.__maxMipLevel=S.length}textureNeedsGenerateMipmaps(t,b)&&generateMipmap(34067,t,x.width,x.height),d.__version=t.version,t.onUpdate&&t.onUpdate(t)}else n.activeTexture(33984+c),n.bindTexture(34067,d.__webglTexture)}function setTextureCubeDynamic(e,t){n.activeTexture(33984+t),n.bindTexture(34067,o.get(e).__webglTexture)}const S={[xe]:10497,[be]:33071,[Me]:33648},T={[_e]:9728,[we]:9984,[Te]:9986,[Le]:9729,[Ae]:9985,[Pe]:9987};function setTextureParameters(n,h,d){d?(e.texParameteri(n,10242,S[h.wrapS]),e.texParameteri(n,10243,S[h.wrapT]),32879!==n&&35866!==n||e.texParameteri(n,32882,S[h.wrapR]),e.texParameteri(n,10240,T[h.magFilter]),e.texParameteri(n,10241,T[h.minFilter])):(e.texParameteri(n,10242,33071),e.texParameteri(n,10243,33071),32879!==n&&35866!==n||e.texParameteri(n,32882,33071),h.wrapS===be&&h.wrapT===be||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,10240,filterFallback(h.magFilter)),e.texParameteri(n,10241,filterFallback(h.minFilter)),h.minFilter!==_e&&h.minFilter!==Le&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const m=t.get("EXT_texture_filter_anisotropic");if(m){if(h.type===Ne&&null===t.get("OES_texture_float_linear"))return;if(h.type===Fe&&null===(p||t.get("OES_texture_half_float_linear")))return;(h.anisotropy>1||o.get(h).__currentAnisotropy)&&(e.texParameterf(n,m.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(h.anisotropy,c.getMaxAnisotropy())),o.get(h).__currentAnisotropy=h.anisotropy)}}function initTexture(t,n){void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",onTextureDispose),t.__webglTexture=e.createTexture(),d.memory.textures++)}function uploadTexture(t,o,c){let d=3553;o.isDataTexture2DArray&&(d=35866),o.isDataTexture3D&&(d=32879),initTexture(t,o),n.activeTexture(33984+c),n.bindTexture(d,t.__webglTexture),e.pixelStorei(37440,o.flipY),e.pixelStorei(37441,o.premultiplyAlpha),e.pixelStorei(3317,o.unpackAlignment);const m=textureNeedsPowerOfTwo(o)&&!1===isPowerOfTwo(o.image),g=resizeImage(o.image,m,!1,y),x=isPowerOfTwo(g)||p,b=h.convert(o.format);let M,_=h.convert(o.type),w=getInternalFormat(o.internalFormat,b,_);setTextureParameters(d,o,x);const S=o.mipmaps;if(o.isDepthTexture)w=6402,p?w=o.type===Ne?36012:o.type===Ve?33190:o.type===ke?35056:33189:o.type===Ne&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),o.format===Je&&6402===w&&o.type!==Ie&&o.type!==Ve&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),o.type=Ie,_=h.convert(o.type)),o.format===Qe&&6402===w&&(w=34041,o.type!==ke&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),o.type=ke,_=h.convert(o.type))),n.texImage2D(3553,0,w,g.width,g.height,0,b,_,null);else if(o.isDataTexture)if(S.length>0&&x){for(let e=0,t=S.length;e<t;e++)M=S[e],n.texImage2D(3553,e,w,M.width,M.height,0,b,_,M.data);o.generateMipmaps=!1,t.__maxMipLevel=S.length-1}else n.texImage2D(3553,0,w,g.width,g.height,0,b,_,g.data),t.__maxMipLevel=0;else if(o.isCompressedTexture){for(let e=0,t=S.length;e<t;e++)M=S[e],o.format!==qe&&o.format!==We?null!==b?n.compressedTexImage2D(3553,e,w,M.width,M.height,0,M.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,e,w,M.width,M.height,0,b,_,M.data);t.__maxMipLevel=S.length-1}else if(o.isDataTexture2DArray)n.texImage3D(35866,0,w,g.width,g.height,g.depth,0,b,_,g.data),t.__maxMipLevel=0;else if(o.isDataTexture3D)n.texImage3D(32879,0,w,g.width,g.height,g.depth,0,b,_,g.data),t.__maxMipLevel=0;else if(S.length>0&&x){for(let e=0,t=S.length;e<t;e++)M=S[e],n.texImage2D(3553,e,w,b,_,M);o.generateMipmaps=!1,t.__maxMipLevel=S.length-1}else n.texImage2D(3553,0,w,b,_,g),t.__maxMipLevel=0;textureNeedsGenerateMipmaps(o,x)&&generateMipmap(d,o,g.width,g.height),t.__version=o.version,o.onUpdate&&o.onUpdate(o)}function setupFrameBufferTexture(t,c,d,p){const m=h.convert(c.texture.format),g=h.convert(c.texture.type),y=getInternalFormat(c.texture.internalFormat,m,g);n.texImage2D(p,0,y,c.width,c.height,0,m,g,null),e.bindFramebuffer(36160,t),e.framebufferTexture2D(36160,d,p,o.get(c.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function setupRenderBufferStorage(t,n,o){if(e.bindRenderbuffer(36161,t),n.depthBuffer&&!n.stencilBuffer){let c=33189;if(o){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===Ne?c=36012:t.type===Ve&&(c=33190));const o=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,o,c,n.width,n.height)}else e.renderbufferStorage(36161,c,n.width,n.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(n.depthBuffer&&n.stencilBuffer){if(o){const t=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,t,35056,n.width,n.height)}else e.renderbufferStorage(36161,34041,n.width,n.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=h.convert(n.texture.format),c=h.convert(n.texture.type),d=getInternalFormat(n.texture.internalFormat,t,c);if(o){const t=getRenderTargetSamples(n);e.renderbufferStorageMultisample(36161,t,d,n.width,n.height)}else e.renderbufferStorage(36161,d,n.width,n.height)}e.bindRenderbuffer(36161,null)}function setupDepthTexture(t,n){const c=n&&n.isWebGLCubeRenderTarget;if(c)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");o.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),setTexture2D(n.depthTexture,0);const h=o.get(n.depthTexture).__webglTexture;if(n.depthTexture.format===Je)e.framebufferTexture2D(36160,36096,3553,h,0);else{if(n.depthTexture.format!==Qe)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,h,0)}}function setupDepthRenderbuffer(t){const n=o.get(t),c=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(c)throw new Error("target.depthTexture not supported in Cube render targets");setupDepthTexture(n.__webglFramebuffer,t)}else if(c){n.__webglDepthbuffer=[];for(let o=0;o<6;o++)e.bindFramebuffer(36160,n.__webglFramebuffer[o]),n.__webglDepthbuffer[o]=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer[o],t,!1)}else e.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer,t,!1);e.bindFramebuffer(36160,null)}function setupRenderTarget(t){const c=o.get(t),m=o.get(t.texture);t.addEventListener("dispose",onRenderTargetDispose),m.__webglTexture=e.createTexture(),d.memory.textures++;const g=!0===t.isWebGLCubeRenderTarget,y=!0===t.isWebGLMultisampleRenderTarget,x=isPowerOfTwo(t)||p;if(!p||t.texture.format!==We||t.texture.type!==Ne&&t.texture.type!==Fe||(t.texture.format=qe,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),g){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else if(c.__webglFramebuffer=e.createFramebuffer(),y)if(p){c.__webglMultisampledFramebuffer=e.createFramebuffer(),c.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,c.__webglColorRenderbuffer);const n=h.convert(t.texture.format),o=h.convert(t.texture.type),d=getInternalFormat(t.texture.internalFormat,n,o),p=getRenderTargetSamples(t);e.renderbufferStorageMultisample(36161,p,d,t.width,t.height),e.bindFramebuffer(36160,c.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,c.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(c.__webglDepthRenderbuffer=e.createRenderbuffer(),setupRenderBufferStorage(c.__webglDepthRenderbuffer,t,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(g){n.bindTexture(34067,m.__webglTexture),setTextureParameters(34067,t.texture,x);for(let e=0;e<6;e++)setupFrameBufferTexture(c.__webglFramebuffer[e],t,36064,34069+e);textureNeedsGenerateMipmaps(t.texture,x)&&generateMipmap(34067,t.texture,t.width,t.height),n.bindTexture(34067,null)}else n.bindTexture(3553,m.__webglTexture),setTextureParameters(3553,t.texture,x),setupFrameBufferTexture(c.__webglFramebuffer,t,36064,3553),textureNeedsGenerateMipmaps(t.texture,x)&&generateMipmap(3553,t.texture,t.width,t.height),n.bindTexture(3553,null);t.depthBuffer&&setupDepthRenderbuffer(t)}function updateRenderTargetMipmap(e){const t=e.texture,c=isPowerOfTwo(e)||p;if(textureNeedsGenerateMipmaps(t,c)){const c=e.isWebGLCubeRenderTarget?34067:3553,h=o.get(t).__webglTexture;n.bindTexture(c,h),generateMipmap(c,t,e.width,e.height),n.bindTexture(c,null)}}function updateMultisampleRenderTarget(t){if(t.isWebGLMultisampleRenderTarget)if(p){const n=o.get(t);e.bindFramebuffer(36008,n.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,n.__webglFramebuffer);const c=t.width,h=t.height;let d=16384;t.depthBuffer&&(d|=256),t.stencilBuffer&&(d|=1024),e.blitFramebuffer(0,0,c,h,0,0,c,h,d,9728),e.bindFramebuffer(36160,n.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function getRenderTargetSamples(e){return p&&e.isWebGLMultisampleRenderTarget?Math.min(x,e.samples):0}function updateVideoTexture(e){const t=d.render.frame;b.get(e)!==t&&(b.set(e,t),e.update())}let E=!1,L=!1;function safeSetTexture2D(e,t){e&&e.isWebGLRenderTarget&&(!1===E&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),E=!0),e=e.texture),setTexture2D(e,t)}function safeSetTextureCube(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===L&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),L=!0),e=e.texture),e&&e.isCubeTexture||Array.isArray(e.image)&&6===e.image.length?setTextureCube(e,t):setTextureCubeDynamic(e,t)}this.allocateTextureUnit=allocateTextureUnit,this.resetTextureUnits=resetTextureUnits,this.setTexture2D=setTexture2D,this.setTexture2DArray=setTexture2DArray,this.setTexture3D=setTexture3D,this.setTextureCube=setTextureCube,this.setTextureCubeDynamic=setTextureCubeDynamic,this.setupRenderTarget=setupRenderTarget,this.updateRenderTargetMipmap=updateRenderTargetMipmap,this.updateMultisampleRenderTarget=updateMultisampleRenderTarget,this.safeSetTexture2D=safeSetTexture2D,this.safeSetTextureCube=safeSetTextureCube}function WebGLUtils(e,t,n){const o=n.isWebGL2;function convert(e){let n;if(e===Be)return 5121;if(e===Ue)return 32819;if(e===ze)return 32820;if(e===He)return 33635;if(e===De)return 5120;if(e===Ge)return 5122;if(e===Ie)return 5123;if(e===Oe)return 5124;if(e===Ve)return 5125;if(e===Ne)return 5126;if(e===Fe)return o?5131:(n=t.get("OES_texture_half_float"),null!==n?n.HALF_FLOAT_OES:null);if(e===je)return 6406;if(e===We)return 6407;if(e===qe)return 6408;if(e===Xe)return 6409;if(e===Ye)return 6410;if(e===Je)return 6402;if(e===Qe)return 34041;if(e===Ke)return 6403;if(e===$e)return 36244;if(e===et)return 33319;if(e===tt)return 33320;if(e===nt)return 36248;if(e===rt)return 36249;if(e===it||e===ot||e===at||e===st){if(n=t.get("WEBGL_compressed_texture_s3tc"),null===n)return null;if(e===it)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(e===ot)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(e===at)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(e===st)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(e===ct||e===lt||e===ut||e===ht){if(n=t.get("WEBGL_compressed_texture_pvrtc"),null===n)return null;if(e===ct)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(e===lt)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(e===ut)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(e===ht)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(e===dt)return n=t.get("WEBGL_compressed_texture_etc1"),null!==n?n.COMPRESSED_RGB_ETC1_WEBGL:null;if((e===pt||e===ft)&&(n=t.get("WEBGL_compressed_texture_etc"),null!==n)){if(e===pt)return n.COMPRESSED_RGB8_ETC2;if(e===ft)return n.COMPRESSED_RGBA8_ETC2_EAC}return e===mt||e===gt||e===yt||e===vt||e===xt||e===bt||e===Mt||e===_t||e===wt||e===St||e===Tt||e===Et||e===Lt||e===At||e===Pt||e===Rt||e===Bt||e===Dt||e===Gt||e===It||e===Ot||e===Vt||e===Nt||e===Ft||e===Ut||e===zt||e===Ht||e===kt?(n=t.get("WEBGL_compressed_texture_astc"),null!==n?e:null):e===Ct?(n=t.get("EXT_texture_compression_bptc"),null!==n?e:null):e===ke?o?34042:(n=t.get("WEBGL_depth_texture"),null!==n?n.UNSIGNED_INT_24_8_WEBGL:null):void 0}return{convert:convert}}function ArrayCamera(e){PerspectiveCamera.call(this),this.cameras=e||[]}function Group(){Object3D.call(this),this.type="Group"}function WebXRController(){this._targetRay=null,this._grip=null,this._hand=null}function WebXRManager(e,t){const n=this;let o=null,c=1,h=null,d="local-floor",p=null;const m=[],g=new Map,y=new PerspectiveCamera;y.layers.enable(1),y.viewport=new Vector4;const x=new PerspectiveCamera;x.layers.enable(2),x.viewport=new Vector4;const b=[y,x],M=new ArrayCamera;M.layers.enable(1),M.layers.enable(2);let _=null,w=null;function onSessionEvent(e){const t=g.get(e.inputSource);t&&t.dispatchEvent({type:e.type})}function onSessionEnd(){g.forEach((function(e,t){e.disconnect(t)})),g.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),L.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function onRequestReferenceSpace(e){h=e,L.setContext(o),L.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}function updateInputSources(e){const t=o.inputSources;for(let n=0;n<m.length;n++)g.set(t[n],m[n]);for(let n=0;n<e.removed.length;n++){const t=e.removed[n],o=g.get(t);o&&(o.dispatchEvent({type:"disconnected",data:t}),g.delete(t))}for(let n=0;n<e.added.length;n++){const t=e.added[n],o=g.get(t);o&&o.dispatchEvent({type:"connected",data:t})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=m[e];return void 0===t&&(t=new WebXRController,m[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=m[e];return void 0===t&&(t=new WebXRController,m[e]=t),t.getGripSpace()},this.getHand=function(e){let t=m[e];return void 0===t&&(t=new WebXRController,m[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){c=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){d=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return h},this.getSession=function(){return o},this.setSession=function(e){if(o=e,null!==o){o.addEventListener("select",onSessionEvent),o.addEventListener("selectstart",onSessionEvent),o.addEventListener("selectend",onSessionEvent),o.addEventListener("squeeze",onSessionEvent),o.addEventListener("squeezestart",onSessionEvent),o.addEventListener("squeezeend",onSessionEvent),o.addEventListener("end",onSessionEnd);const e=t.getContextAttributes();!0!==e.xrCompatible&&t.makeXRCompatible();const n={antialias:e.antialias,alpha:e.alpha,depth:e.depth,stencil:e.stencil,framebufferScaleFactor:c},h=new XRWebGLLayer(o,t,n);o.updateRenderState({baseLayer:h}),o.requestReferenceSpace(d).then(onRequestReferenceSpace),o.addEventListener("inputsourceschange",updateInputSources)}};const S=new Vector3,T=new Vector3;function setProjectionFromUnion(e,t,n){S.setFromMatrixPosition(t.matrixWorld),T.setFromMatrixPosition(n.matrixWorld);const o=S.distanceTo(T),c=t.projectionMatrix.elements,h=n.projectionMatrix.elements,d=c[14]/(c[10]-1),p=c[14]/(c[10]+1),m=(c[9]+1)/c[5],g=(c[9]-1)/c[5],y=(c[8]-1)/c[0],x=(h[8]+1)/h[0],b=d*y,M=d*x,_=o/(-y+x),w=_*-y;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(w),e.translateZ(_),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.getInverse(e.matrixWorld);const E=d+_,L=p+_,A=b-w,C=M+(o-w),P=m*p/L*E,R=g*p/L*E;e.projectionMatrix.makePerspective(A,C,P,R,E,L)}function updateCamera(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.getInverse(e.matrixWorld)}this.getCamera=function(e){M.near=x.near=y.near=e.near,M.far=x.far=y.far=e.far,_===M.near&&w===M.far||(o.updateRenderState({depthNear:M.near,depthFar:M.far}),_=M.near,w=M.far);const t=e.parent,n=M.cameras;updateCamera(M,t);for(let o=0;o<n.length;o++)updateCamera(n[o],t);e.matrixWorld.copy(M.matrixWorld);const c=e.children;for(let o=0,h=c.length;o<h;o++)c[o].updateMatrixWorld(!0);return 2===n.length?setProjectionFromUnion(M,y,x):M.projectionMatrix.copy(y.projectionMatrix),M};let E=null;function onAnimationFrame(t,n){if(p=n.getViewerPose(h),null!==p){const t=p.views,n=o.renderState.baseLayer;e.setFramebuffer(n.framebuffer);let c=!1;t.length!==M.cameras.length&&(M.cameras.length=0,c=!0);for(let e=0;e<t.length;e++){const o=t[e],h=n.getViewport(o),d=b[e];d.matrix.fromArray(o.transform.matrix),d.projectionMatrix.fromArray(o.projectionMatrix),d.viewport.set(h.x,h.y,h.width,h.height),0===e&&M.matrix.copy(d.matrix),!0===c&&M.cameras.push(d)}}const c=o.inputSources;for(let e=0;e<m.length;e++){const t=m[e],o=c[e];t.update(o,n,h)}E&&E(t,n)}const L=new WebGLAnimation;L.setAnimationLoop(onAnimationFrame),this.setAnimationLoop=function(e){E=e},this.dispose=function(){}}function WebGLMaterials(e){function refreshFogUniforms(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)}function refreshMaterialUniforms(e,t,n,o){t.isMeshBasicMaterial?refreshUniformsCommon(e,t):t.isMeshLambertMaterial?(refreshUniformsCommon(e,t),refreshUniformsLambert(e,t)):t.isMeshToonMaterial?(refreshUniformsCommon(e,t),refreshUniformsToon(e,t)):t.isMeshPhongMaterial?(refreshUniformsCommon(e,t),refreshUniformsPhong(e,t)):t.isMeshStandardMaterial?(refreshUniformsCommon(e,t),t.isMeshPhysicalMaterial?refreshUniformsPhysical(e,t):refreshUniformsStandard(e,t)):t.isMeshMatcapMaterial?(refreshUniformsCommon(e,t),refreshUniformsMatcap(e,t)):t.isMeshDepthMaterial?(refreshUniformsCommon(e,t),refreshUniformsDepth(e,t)):t.isMeshDistanceMaterial?(refreshUniformsCommon(e,t),refreshUniformsDistance(e,t)):t.isMeshNormalMaterial?(refreshUniformsCommon(e,t),refreshUniformsNormal(e,t)):t.isLineBasicMaterial?(refreshUniformsLine(e,t),t.isLineDashedMaterial&&refreshUniformsDash(e,t)):t.isPointsMaterial?refreshUniformsPoints(e,t,n,o):t.isSpriteMaterial?refreshUniformsSprites(e,t):t.isShadowMaterial?(e.color.value.copy(t.color),e.opacity.value=t.opacity):t.isShaderMaterial&&(t.uniformsNeedUpdate=!1)}function refreshUniformsCommon(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.specularMap&&(t.specularMap.value=n.specularMap);const o=e.get(n).envMap;if(o){t.envMap.value=o,t.flipEnvMap.value=o.isCubeTexture?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio;const c=e.get(o).__maxMipLevel;void 0!==c&&(t.maxMipLevel.value=c)}let c,h;n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?c=n.map:n.specularMap?c=n.specularMap:n.displacementMap?c=n.displacementMap:n.normalMap?c=n.normalMap:n.bumpMap?c=n.bumpMap:n.roughnessMap?c=n.roughnessMap:n.metalnessMap?c=n.metalnessMap:n.alphaMap?c=n.alphaMap:n.emissiveMap?c=n.emissiveMap:n.clearcoatMap?c=n.clearcoatMap:n.clearcoatNormalMap?c=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(c=n.clearcoatRoughnessMap),void 0!==c&&(c.isWebGLRenderTarget&&(c=c.texture),!0===c.matrixAutoUpdate&&c.updateMatrix(),t.uvTransform.value.copy(c.matrix)),n.aoMap?h=n.aoMap:n.lightMap&&(h=n.lightMap),void 0!==h&&(h.isWebGLRenderTarget&&(h=h.texture),!0===h.matrixAutoUpdate&&h.updateMatrix(),t.uv2Transform.value.copy(h.matrix))}function refreshUniformsLine(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}function refreshUniformsDash(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}function refreshUniformsPoints(e,t,n,o){let c;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*o,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?c=t.map:t.alphaMap&&(c=t.alphaMap),void 0!==c&&(!0===c.matrixAutoUpdate&&c.updateMatrix(),e.uvTransform.value.copy(c.matrix))}function refreshUniformsSprites(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}function refreshUniformsLambert(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}function refreshUniformsPhong(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===w&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===w&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsToon(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===w&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===w&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsStandard(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap),n.bumpMap&&(t.bumpMap.value=n.bumpMap,t.bumpScale.value=n.bumpScale,n.side===w&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,t.normalScale.value.copy(n.normalScale),n.side===w&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias);const o=e.get(n).envMap;o&&(t.envMapIntensity.value=n.envMapIntensity)}function refreshUniformsPhysical(e,t){refreshUniformsStandard(e,t),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,t.side===w&&e.clearcoatNormalScale.value.negate()),e.transmission.value=t.transmission,t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap)}function refreshUniformsMatcap(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===w&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===w&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsDepth(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function refreshUniformsDistance(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}function refreshUniformsNormal(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===w&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===w&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}return{refreshFogUniforms:refreshFogUniforms,refreshMaterialUniforms:refreshMaterialUniforms}}function WebGLRenderer(e){e=e||{};const t=void 0!==e.canvas?e.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),n=void 0!==e.context?e.context:null,o=void 0!==e.alpha&&e.alpha,c=void 0===e.depth||e.depth,h=void 0===e.stencil||e.stencil,d=void 0!==e.antialias&&e.antialias,p=void 0===e.premultipliedAlpha||e.premultipliedAlpha,m=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,g=void 0!==e.powerPreference?e.powerPreference:"default",y=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let x=null,b=null;this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=on,this.physicallyCorrectLights=!1,this.toneMapping=ae,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const M=this;let _=!1,w=null,S=0,T=0,E=null,L=null,A=-1,C=null,P=null;const R=new Vector4,B=new Vector4;let D=null,G=t.width,I=t.height,O=1,V=null,N=null;const F=new Vector4(0,0,G,I),U=new Vector4(0,0,G,I);let z=!1;const H=new Frustum;let k=!1,j=!1;const W=new Matrix4,q=new Vector3,X={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function getTargetPixelRatio(){return null===E?O:1}let Y,Z,J,Q,K,$,ee,te,ne,re,ie,oe,se,ce,le,ue,he,de,pe,fe,me,ge=n;function getContext(e,n){for(let o=0;o<e.length;o++){const c=e[o],h=t.getContext(c,n);if(null!==h)return h}return null}try{const e={alpha:o,depth:c,stencil:h,antialias:d,premultipliedAlpha:p,preserveDrawingBuffer:m,powerPreference:g,failIfMajorPerformanceCaveat:y};if(t.addEventListener("webglcontextlost",onContextLost,!1),t.addEventListener("webglcontextrestored",onContextRestore,!1),null===ge){const t=["webgl2","webgl","experimental-webgl"];if(!0===M.isWebGL1Renderer&&t.shift(),ge=getContext(t,e),null===ge)throw getContext(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ge.getShaderPrecisionFormat&&(ge.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Me){throw console.error("THREE.WebGLRenderer: "+Me.message),Me}function initGLContext(){Y=new WebGLExtensions(ge),Z=new WebGLCapabilities(ge,Y,e),!1===Z.isWebGL2&&(Y.get("WEBGL_depth_texture"),Y.get("OES_texture_float"),Y.get("OES_texture_half_float"),Y.get("OES_texture_half_float_linear"),Y.get("OES_standard_derivatives"),Y.get("OES_element_index_uint"),Y.get("OES_vertex_array_object"),Y.get("ANGLE_instanced_arrays")),Y.get("OES_texture_float_linear"),fe=new WebGLUtils(ge,Y,Z),J=new WebGLState(ge,Y,Z),J.scissor(B.copy(U).multiplyScalar(O).floor()),J.viewport(R.copy(F).multiplyScalar(O).floor()),Q=new WebGLInfo(ge),K=new WebGLProperties,$=new WebGLTextures(ge,Y,J,K,Z,fe,Q),ee=new WebGLCubeMaps(M),te=new WebGLAttributes(ge,Z),me=new WebGLBindingStates(ge,Y,te,Z),ne=new WebGLGeometries(ge,te,Q,me),re=new WebGLObjects(ge,ne,te,Q),he=new WebGLMorphtargets(ge),le=new WebGLClipping(K),ie=new WebGLPrograms(M,ee,Y,Z,me,le),oe=new WebGLMaterials(K),se=new WebGLRenderLists(K),ce=new WebGLRenderStates,ue=new WebGLBackground(M,ee,J,re,p),de=new WebGLBufferRenderer(ge,Y,Q,Z),pe=new WebGLIndexedBufferRenderer(ge,Y,Q,Z),Q.programs=ie.programs,M.capabilities=Z,M.extensions=Y,M.properties=K,M.renderLists=se,M.state=J,M.info=Q}initGLContext();const ye=new WebXRManager(M,ge);this.xr=ye;const ve=new WebGLShadowMap(M,re,Z.maxTextureSize);function onContextLost(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1,initGLContext()}function onMaterialDispose(e){const t=e.target;t.removeEventListener("dispose",onMaterialDispose),deallocateMaterial(t)}function deallocateMaterial(e){releaseMaterialProgramReference(e),K.remove(e)}function releaseMaterialProgramReference(e){const t=K.get(e).program;void 0!==t&&ie.releaseProgram(t)}function renderObjectImmediate(e,t){e.render((function(e){M.renderBufferImmediate(e,t)}))}this.shadowMap=ve,this.getContext=function(){return ge},this.getContextAttributes=function(){return ge.getContextAttributes()},this.forceContextLoss=function(){const e=Y.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=Y.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(e){void 0!==e&&(O=e,this.setSize(G,I,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new Vector2),e.set(G,I)},this.setSize=function(e,n,o){ye.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(G=e,I=n,t.width=Math.floor(e*O),t.height=Math.floor(n*O),!1!==o&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new Vector2),e.set(G*O,I*O).floor()},this.setDrawingBufferSize=function(e,n,o){G=e,I=n,O=o,t.width=Math.floor(e*o),t.height=Math.floor(n*o),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new Vector4),e.copy(R)},this.getViewport=function(e){return e.copy(F)},this.setViewport=function(e,t,n,o){e.isVector4?F.set(e.x,e.y,e.z,e.w):F.set(e,t,n,o),J.viewport(R.copy(F).multiplyScalar(O).floor())},this.getScissor=function(e){return e.copy(U)},this.setScissor=function(e,t,n,o){e.isVector4?U.set(e.x,e.y,e.z,e.w):U.set(e,t,n,o),J.scissor(B.copy(U).multiplyScalar(O).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(e){J.setScissorTest(z=e)},this.setOpaqueSort=function(e){V=e},this.setTransparentSort=function(e){N=e},this.getClearColor=function(){return ue.getClearColor()},this.setClearColor=function(){ue.setClearColor.apply(ue,arguments)},this.getClearAlpha=function(){return ue.getClearAlpha()},this.setClearAlpha=function(){ue.setClearAlpha.apply(ue,arguments)},this.clear=function(e,t,n){let o=0;(void 0===e||e)&&(o|=16384),(void 0===t||t)&&(o|=256),(void 0===n||n)&&(o|=1024),ge.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",onContextLost,!1),t.removeEventListener("webglcontextrestored",onContextRestore,!1),se.dispose(),ce.dispose(),K.dispose(),ee.dispose(),re.dispose(),me.dispose(),ye.dispose(),be.stop()},this.renderBufferImmediate=function(e,t){me.initAttributes();const n=K.get(e);e.hasPositions&&!n.position&&(n.position=ge.createBuffer()),e.hasNormals&&!n.normal&&(n.normal=ge.createBuffer()),e.hasUvs&&!n.uv&&(n.uv=ge.createBuffer()),e.hasColors&&!n.color&&(n.color=ge.createBuffer());const o=t.getAttributes();e.hasPositions&&(ge.bindBuffer(34962,n.position),ge.bufferData(34962,e.positionArray,35048),me.enableAttribute(o.position),ge.vertexAttribPointer(o.position,3,5126,!1,0,0)),e.hasNormals&&(ge.bindBuffer(34962,n.normal),ge.bufferData(34962,e.normalArray,35048),me.enableAttribute(o.normal),ge.vertexAttribPointer(o.normal,3,5126,!1,0,0)),e.hasUvs&&(ge.bindBuffer(34962,n.uv),ge.bufferData(34962,e.uvArray,35048),me.enableAttribute(o.uv),ge.vertexAttribPointer(o.uv,2,5126,!1,0,0)),e.hasColors&&(ge.bindBuffer(34962,n.color),ge.bufferData(34962,e.colorArray,35048),me.enableAttribute(o.color),ge.vertexAttribPointer(o.color,3,5126,!1,0,0)),me.disableUnusedAttributes(),ge.drawArrays(4,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,n,o,c,h){null===t&&(t=X);const d=c.isMesh&&c.matrixWorld.determinant()<0,p=setProgram(e,t,o,c);J.setMaterial(o,d);let m=n.index;const g=n.attributes.position;if(null===m){if(void 0===g||0===g.count)return}else if(0===m.count)return;let y,x=1;!0===o.wireframe&&(m=ne.getWireframeAttribute(n),x=2),(o.morphTargets||o.morphNormals)&&he.update(c,n,o,p),me.setup(c,o,p,n,m);let b=de;null!==m&&(y=te.get(m),b=pe,b.setIndex(y));const M=null!==m?m.count:g.count,_=n.drawRange.start*x,w=n.drawRange.count*x,S=null!==h?h.start*x:0,T=null!==h?h.count*x:1/0,E=Math.max(_,S),L=Math.min(M,_+w,S+T)-1,A=Math.max(0,L-E+1);if(0!==A){if(c.isMesh)!0===o.wireframe?(J.setLineWidth(o.wireframeLinewidth*getTargetPixelRatio()),b.setMode(1)):b.setMode(4);else if(c.isLine){let e=o.linewidth;void 0===e&&(e=1),J.setLineWidth(e*getTargetPixelRatio()),c.isLineSegments?b.setMode(1):c.isLineLoop?b.setMode(2):b.setMode(3)}else c.isPoints?b.setMode(0):c.isSprite&&b.setMode(4);if(c.isInstancedMesh)b.renderInstances(E,A,c.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);b.renderInstances(E,A,e)}else b.render(E,A)}},this.compile=function(e,t){b=ce.get(e,t),b.init(),e.traverse((function(e){e.isLight&&(b.pushLight(e),e.castShadow&&b.pushShadow(e))})),b.setupLights(t);const n=new WeakMap;e.traverse((function(t){const o=t.material;if(o)if(Array.isArray(o))for(let c=0;c<o.length;c++){const h=o[c];!1===n.has(h)&&(initMaterial(h,e,t),n.set(h))}else!1===n.has(o)&&(initMaterial(o,e,t),n.set(o))}))};let xe=null;function onAnimationFrame(e){ye.isPresenting||xe&&xe(e)}const be=new WebGLAnimation;function projectObject(e,t,n,o){if(!1===e.visible)return;const c=e.layers.test(t.layers);if(c)if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)b.pushLight(e),e.castShadow&&b.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||H.intersectsSprite(e)){o&&q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(W);const t=re.update(e),c=e.material;c.visible&&x.push(e,t,c,n,q.z,null)}}else if(e.isImmediateRenderObject)o&&q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(W),x.push(e,null,e.material,n,q.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==Q.render.frame&&(e.skeleton.update(),e.skeleton.frame=Q.render.frame),!e.frustumCulled||H.intersectsObject(e))){o&&q.setFromMatrixPosition(e.matrixWorld).applyMatrix4(W);const t=re.update(e),c=e.material;if(Array.isArray(c)){const o=t.groups;for(let h=0,d=o.length;h<d;h++){const d=o[h],p=c[d.materialIndex];p&&p.visible&&x.push(e,t,p,n,q.z,d)}}else c.visible&&x.push(e,t,c,n,q.z,null)}const h=e.children;for(let d=0,p=h.length;d<p;d++)projectObject(h[d],t,n,o)}function renderObjects(e,t,n){const o=!0===t.isScene?t.overrideMaterial:null;for(let c=0,h=e.length;c<h;c++){const h=e[c],d=h.object,p=h.geometry,m=null===o?h.material:o,g=h.group;if(n.isArrayCamera){P=n;const e=n.cameras;for(let n=0,o=e.length;n<o;n++){const o=e[n];d.layers.test(o.layers)&&(J.viewport(R.copy(o.viewport)),b.setupLights(o),renderObject(d,t,o,p,m,g))}}else P=null,renderObject(d,t,n,p,m,g)}}function renderObject(e,t,n,o,c,h){if(e.onBeforeRender(M,t,n,o,c,h),b=ce.get(t,P||n),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){const o=setProgram(n,t,c,e);J.setMaterial(c),me.reset(),renderObjectImmediate(e,o)}else M.renderBufferDirect(n,t,o,c,e,h);e.onAfterRender(M,t,n,o,c,h),b=ce.get(t,P||n)}function initMaterial(e,t,n){!0!==t.isScene&&(t=X);const o=K.get(e),c=b.state.lights,h=b.state.shadowsArray,d=c.state.version,p=ie.getParameters(e,c.state,h,t,n),m=ie.getProgramCacheKey(p);let g=o.program,y=!0;if(void 0===g)e.addEventListener("dispose",onMaterialDispose);else if(g.cacheKey!==m)releaseMaterialProgramReference(e);else if(o.lightsStateVersion!==d)y=!1;else{if(void 0!==p.shaderID){const n=e.isMeshStandardMaterial?t.environment:null;return void(o.envMap=ee.get(e.envMap||n))}y=!1}y&&(p.uniforms=ie.getUniforms(e),e.onBeforeCompile(p,M),g=ie.acquireProgram(p,m),o.program=g,o.uniforms=p.uniforms,o.outputEncoding=p.outputEncoding);const x=o.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(o.numClippingPlanes=le.numPlanes,o.numIntersection=le.numIntersection,x.clippingPlanes=le.uniform),o.environment=e.isMeshStandardMaterial?t.environment:null,o.fog=t.fog,o.envMap=ee.get(e.envMap||o.environment),o.needsLights=materialNeedsLights(e),o.lightsStateVersion=d,o.needsLights&&(x.ambientLightColor.value=c.state.ambient,x.lightProbe.value=c.state.probe,x.directionalLights.value=c.state.directional,x.directionalLightShadows.value=c.state.directionalShadow,x.spotLights.value=c.state.spot,x.spotLightShadows.value=c.state.spotShadow,x.rectAreaLights.value=c.state.rectArea,x.ltc_1.value=c.state.rectAreaLTC1,x.ltc_2.value=c.state.rectAreaLTC2,x.pointLights.value=c.state.point,x.pointLightShadows.value=c.state.pointShadow,x.hemisphereLights.value=c.state.hemi,x.directionalShadowMap.value=c.state.directionalShadowMap,x.directionalShadowMatrix.value=c.state.directionalShadowMatrix,x.spotShadowMap.value=c.state.spotShadowMap,x.spotShadowMatrix.value=c.state.spotShadowMatrix,x.pointShadowMap.value=c.state.pointShadowMap,x.pointShadowMatrix.value=c.state.pointShadowMatrix);const _=o.program.getUniforms(),w=WebGLUniforms.seqWithValue(_.seq,x);o.uniformsList=w}function setProgram(e,t,n,o){!0!==t.isScene&&(t=X),$.resetTextureUnits();const c=t.fog,h=n.isMeshStandardMaterial?t.environment:null,d=null===E?M.outputEncoding:E.texture.encoding,p=ee.get(n.envMap||h),m=K.get(n),g=b.state.lights;if(!0===k&&(!0===j||e!==C)){const t=e===C&&n.id===A;le.setState(n,e,t)}n.version===m.__version?n.fog&&m.fog!==c||m.environment!==h||m.needsLights&&m.lightsStateVersion!==g.state.version?initMaterial(n,t,o):void 0===m.numClippingPlanes||m.numClippingPlanes===le.numPlanes&&m.numIntersection===le.numIntersection?(m.outputEncoding!==d||m.envMap!==p)&&initMaterial(n,t,o):initMaterial(n,t,o):(initMaterial(n,t,o),m.__version=n.version);let y=!1,x=!1,_=!1;const w=m.program,S=w.getUniforms(),T=m.uniforms;if(J.useProgram(w.program)&&(y=!0,x=!0,_=!0),n.id!==A&&(A=n.id,x=!0),y||C!==e){if(S.setValue(ge,"projectionMatrix",e.projectionMatrix),Z.logarithmicDepthBuffer&&S.setValue(ge,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),C!==e&&(C=e,x=!0,_=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const t=S.map.cameraPosition;void 0!==t&&t.setValue(ge,q.setFromMatrixPosition(e.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&S.setValue(ge,"isOrthographic",!0===e.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&S.setValue(ge,"viewMatrix",e.matrixWorldInverse)}if(n.skinning){S.setOptional(ge,o,"bindMatrix"),S.setOptional(ge,o,"bindMatrixInverse");const e=o.skeleton;if(e){const t=e.bones;if(Z.floatVertexTextures){if(void 0===e.boneTexture){let n=Math.sqrt(4*t.length);n=qn.ceilPowerOfTwo(n),n=Math.max(n,4);const o=new Float32Array(n*n*4);o.set(e.boneMatrices);const c=new DataTexture(o,n,n,qe,Ne);e.boneMatrices=o,e.boneTexture=c,e.boneTextureSize=n}S.setValue(ge,"boneTexture",e.boneTexture,$),S.setValue(ge,"boneTextureSize",e.boneTextureSize)}else S.setOptional(ge,e,"boneMatrices")}}return(x||m.receiveShadow!==o.receiveShadow)&&(m.receiveShadow=o.receiveShadow,S.setValue(ge,"receiveShadow",o.receiveShadow)),x&&(S.setValue(ge,"toneMappingExposure",M.toneMappingExposure),m.needsLights&&markUniformsLightsNeedsUpdate(T,_),c&&n.fog&&oe.refreshFogUniforms(T,c),oe.refreshMaterialUniforms(T,n,O,I),WebGLUniforms.upload(ge,m.uniformsList,T,$)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(WebGLUniforms.upload(ge,m.uniformsList,T,$),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&S.setValue(ge,"center",o.center),S.setValue(ge,"modelViewMatrix",o.modelViewMatrix),S.setValue(ge,"normalMatrix",o.normalMatrix),S.setValue(ge,"modelMatrix",o.matrixWorld),w}function markUniformsLightsNeedsUpdate(e,t){e.ambientLightColor.needsUpdate=t,e.lightProbe.needsUpdate=t,e.directionalLights.needsUpdate=t,e.directionalLightShadows.needsUpdate=t,e.pointLights.needsUpdate=t,e.pointLightShadows.needsUpdate=t,e.spotLights.needsUpdate=t,e.spotLightShadows.needsUpdate=t,e.rectAreaLights.needsUpdate=t,e.hemisphereLights.needsUpdate=t}function materialNeedsLights(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}be.setAnimationLoop(onAnimationFrame),"undefined"!==typeof window&&be.setContext(window),this.setAnimationLoop=function(e){xe=e,ye.setAnimationLoop(e),null===e?be.stop():be.start()},this.render=function(e,t){let n,o;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),o=arguments[3]),void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===_)return;me.resetDefaultState(),A=-1,C=null,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===ye.enabled&&!0===ye.isPresenting&&(t=ye.getCamera(t)),!0===e.isScene&&e.onBeforeRender(M,e,t,n||E),b=ce.get(e,t),b.init(),W.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),H.setFromProjectionMatrix(W),j=this.localClippingEnabled,k=le.init(this.clippingPlanes,j,t),x=se.get(e,t),x.init(),projectObject(e,t,0,M.sortObjects),x.finish(),!0===M.sortObjects&&x.sort(V,N),!0===k&&le.beginShadows();const c=b.state.shadowsArray;ve.render(c,e,t),b.setupLights(t),!0===k&&le.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),ue.render(x,e,t,o);const h=x.opaque,d=x.transparent;h.length>0&&renderObjects(h,e,t),d.length>0&&renderObjects(d,e,t),!0===e.isScene&&e.onAfterRender(M,e,t),null!==E&&($.updateRenderTargetMipmap(E),$.updateMultisampleRenderTarget(E)),J.buffers.depth.setTest(!0),J.buffers.depth.setMask(!0),J.buffers.color.setMask(!0),J.setPolygonOffset(!1),x=null,b=null},this.setFramebuffer=function(e){w!==e&&null===E&&ge.bindFramebuffer(36160,e),w=e},this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return T},this.getRenderList=function(){return x},this.setRenderList=function(e){x=e},this.getRenderState=function(){return b},this.setRenderState=function(e){b=e},this.getRenderTarget=function(){return E},this.setRenderTarget=function(e,t=0,n=0){E=e,S=t,T=n,e&&void 0===K.get(e).__webglFramebuffer&&$.setupRenderTarget(e);let o=w,c=!1;if(e){const n=K.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(o=n[t],c=!0):o=e.isWebGLMultisampleRenderTarget?K.get(e).__webglMultisampledFramebuffer:n,R.copy(e.viewport),B.copy(e.scissor),D=e.scissorTest}else R.copy(F).multiplyScalar(O).floor(),B.copy(U).multiplyScalar(O).floor(),D=z;if(L!==o&&(ge.bindFramebuffer(36160,o),L=o),J.viewport(R),J.scissor(B),J.setScissorTest(D),c){const o=K.get(e.texture);ge.framebufferTexture2D(36160,36064,34069+t,o.__webglTexture,n)}},this.readRenderTargetPixels=function(e,t,n,o,c,h,d){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let p=K.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==d&&(p=p[d]),p){let d=!1;p!==L&&(ge.bindFramebuffer(36160,p),d=!0);try{const p=e.texture,m=p.format,g=p.type;if(m!==qe&&fe.convert(m)!==ge.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(g!==Be&&fe.convert(g)!==ge.getParameter(35738)&&(g!==Ne||!(Z.isWebGL2||Y.get("OES_texture_float")||Y.get("WEBGL_color_buffer_float")))&&(g!==Fe||!(Z.isWebGL2?Y.get("EXT_color_buffer_float"):Y.get("EXT_color_buffer_half_float"))))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===ge.checkFramebufferStatus(36160)?t>=0&&t<=e.width-o&&n>=0&&n<=e.height-c&&ge.readPixels(t,n,o,c,fe.convert(m),fe.convert(g),h):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{d&&ge.bindFramebuffer(36160,L)}}},this.copyFramebufferToTexture=function(e,t,n){void 0===n&&(n=0);const o=Math.pow(2,-n),c=Math.floor(t.image.width*o),h=Math.floor(t.image.height*o),d=fe.convert(t.format);$.setTexture2D(t,0),ge.copyTexImage2D(3553,n,d,e.x,e.y,c,h,0),J.unbindTexture()},this.copyTextureToTexture=function(e,t,n,o){void 0===o&&(o=0);const c=t.image.width,h=t.image.height,d=fe.convert(n.format),p=fe.convert(n.type);$.setTexture2D(n,0),ge.pixelStorei(37440,n.flipY),ge.pixelStorei(37441,n.premultiplyAlpha),ge.pixelStorei(3317,n.unpackAlignment),t.isDataTexture?ge.texSubImage2D(3553,o,e.x,e.y,c,h,d,p,t.image.data):t.isCompressedTexture?ge.compressedTexSubImage2D(3553,o,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,d,t.mipmaps[0].data):ge.texSubImage2D(3553,o,e.x,e.y,d,p,t.image),0===o&&n.generateMipmaps&&ge.generateMipmap(3553),J.unbindTexture()},this.initTexture=function(e){$.setTexture2D(e,0),J.unbindTexture()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function WebGL1Renderer(e){WebGLRenderer.call(this,e)}ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:!0}),Group.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Group,isGroup:!0}),Object.assign(WebXRController.prototype,{constructor:WebXRController,getHandSpace:function(){if(null===this._hand&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(let e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){const e=new Group;e.matrixAutoUpdate=!1,e.visible=!1,this._hand.joints.push(e),this._hand.add(e)}return this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(e,t,n){let o=null,c=null,h=null;const d=this._targetRay,p=this._grip,m=this._hand;if(e)if(m&&e.hand){h=!0;for(let o=0;o<=window.XRHand.LITTLE_PHALANX_TIP;o++)if(e.hand[o]){const c=t.getJointPose(e.hand[o],n),h=m.joints[o];null!==c&&(h.matrix.fromArray(c.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),h.jointRadius=c.radius),h.visible=null!==c;const d=m.joints[window.XRHand.INDEX_PHALANX_TIP],p=m.joints[window.XRHand.THUMB_PHALANX_TIP],g=d.position.distanceTo(p.position),y=.02,x=.005;m.inputState.pinching&&g>y+x?(m.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!m.inputState.pinching&&g<=y-x&&(m.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else null!==d&&(o=t.getPose(e.targetRaySpace,n),null!==o&&(d.matrix.fromArray(o.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale))),null!==p&&e.gripSpace&&(c=t.getPose(e.gripSpace,n),null!==c&&(p.matrix.fromArray(c.transform.matrix),p.matrix.decompose(p.position,p.rotation,p.scale)));return null!==d&&(d.visible=null!==o),null!==p&&(p.visible=null!==c),null!==m&&(m.visible=null!==h),this}}),Object.assign(WebXRManager.prototype,EventDispatcher.prototype),WebGL1Renderer.prototype=Object.assign(Object.create(WebGLRenderer.prototype),{constructor:WebGL1Renderer,isWebGL1Renderer:!0});class FogExp2{constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new Color(e),this.density=void 0!==t?t:25e-5}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Fog{constructor(e,t,n){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new Color(e),this.near=void 0!==t?t:1,this.far=void 0!==n?n:1e3}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}function InterleavedBuffer(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=Dn,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=qn.generateUUID()}Object.defineProperty(InterleavedBuffer.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(InterleavedBuffer.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let o=0,c=this.stride;o<c;o++)this.array[e+o]=t.array[n+o];return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=qn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new InterleavedBuffer(t,this.stride);return n.setUsage(this.usage),n},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=qn.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Cs=new Vector3;function InterleavedBufferAttribute(e,t,n,o){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===o}function SpriteMaterial(e){Material.call(this),this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}let Ps;Object.defineProperties(InterleavedBufferAttribute.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Cs.x=this.getX(t),Cs.y=this.getY(t),Cs.z=this.getZ(t),Cs.applyMatrix4(e),this.setXYZ(t,Cs.x,Cs.y,Cs.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,o){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this},setXYZW:function(e,t,n,o,c){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=o,this.data.array[e+3]=c,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new BufferAttribute(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),SpriteMaterial.prototype=Object.create(Material.prototype),SpriteMaterial.prototype.constructor=SpriteMaterial,SpriteMaterial.prototype.isSpriteMaterial=!0,SpriteMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};const Rs=new Vector3,Bs=new Vector3,Ds=new Vector3,Gs=new Vector2,Is=new Vector2,Os=new Matrix4,Vs=new Vector3,Ns=new Vector3,Fs=new Vector3,Us=new Vector2,zs=new Vector2,Hs=new Vector2;function Sprite(e){if(Object3D.call(this),this.type="Sprite",void 0===Ps){Ps=new BufferGeometry;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new InterleavedBuffer(e,5);Ps.setIndex([0,1,2,0,2,3]),Ps.setAttribute("position",new InterleavedBufferAttribute(t,3,0,!1)),Ps.setAttribute("uv",new InterleavedBufferAttribute(t,2,3,!1))}this.geometry=Ps,this.material=void 0!==e?e:new SpriteMaterial,this.center=new Vector2(.5,.5)}function transformVertex(e,t,n,o,c,h){Gs.subVectors(e,n).addScalar(.5).multiply(o),void 0!==c?(Is.x=h*Gs.x-c*Gs.y,Is.y=c*Gs.x+h*Gs.y):Is.copy(Gs),e.copy(t),e.x+=Is.x,e.y+=Is.y,e.applyMatrix4(Os)}Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:!0,raycast:function(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Bs.setFromMatrixScale(this.matrixWorld),Os.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ds.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Bs.multiplyScalar(-Ds.z);const n=this.material.rotation;let o,c;0!==n&&(c=Math.cos(n),o=Math.sin(n));const h=this.center;transformVertex(Vs.set(-.5,-.5,0),Ds,h,Bs,o,c),transformVertex(Ns.set(.5,-.5,0),Ds,h,Bs,o,c),transformVertex(Fs.set(.5,.5,0),Ds,h,Bs,o,c),Us.set(0,0),zs.set(1,0),Hs.set(1,1);let d=e.ray.intersectTriangle(Vs,Ns,Fs,!1,Rs);if(null===d&&(transformVertex(Ns.set(-.5,.5,0),Ds,h,Bs,o,c),zs.set(0,1),d=e.ray.intersectTriangle(Vs,Fs,Ns,!1,Rs),null===d))return;const p=e.ray.origin.distanceTo(Rs);p<e.near||p>e.far||t.push({distance:p,point:Rs.clone(),uv:Triangle.getUV(Rs,Vs,Ns,Fs,Us,zs,Hs,new Vector2),face:null,object:this})},copy:function(e){return Object3D.prototype.copy.call(this,e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}});const ks=new Vector3,js=new Vector3;function LOD(){Object3D.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}function SkinnedMesh(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Mesh.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4}LOD.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LOD,isLOD:!0,copy:function(e){Object3D.prototype.copy.call(this,e,!1);const t=e.levels;for(let n=0,o=t.length;n<o;n++){const e=t[n];this.addLevel(e.object.clone(),e.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t){void 0===t&&(t=0),t=Math.abs(t);const n=this.levels;let o;for(o=0;o<n.length;o++)if(t<n[o].distance)break;return n.splice(o,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,o;for(n=1,o=t.length;n<o;n++)if(e<t[n].distance)break;return t[n-1].object}return null},raycast:function(e,t){const n=this.levels;if(n.length>0){ks.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(ks);this.getObjectForDistance(n).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){ks.setFromMatrixPosition(e.matrixWorld),js.setFromMatrixPosition(this.matrixWorld);const n=ks.distanceTo(js)/e.zoom;let o,c;for(t[0].object.visible=!0,o=1,c=t.length;o<c;o++){if(!(n>=t[o].distance))break;t[o-1].object.visible=!1,t[o].object.visible=!0}for(this._currentLevel=o-1;o<c;o++)t[o].object.visible=!1}},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let o=0,c=n.length;o<c;o++){const e=n[o];t.object.levels.push({object:e.object.uuid,distance:e.distance})}return t}}),SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:!0,copy:function(e){return Mesh.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.getInverse(t)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new Vector4,t=this.geometry.attributes.skinWeight;for(let n=0,o=t.count;n<o;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const o=1/e.manhattanLength();o!==1/0?e.multiplyScalar(o):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){Mesh.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(){const e=new Vector3,t=new Vector4,n=new Vector4,o=new Vector3,c=new Matrix4;return function(h,d){const p=this.skeleton,m=this.geometry;t.fromBufferAttribute(m.attributes.skinIndex,h),n.fromBufferAttribute(m.attributes.skinWeight,h),e.fromBufferAttribute(m.attributes.position,h).applyMatrix4(this.bindMatrix),d.set(0,0,0);for(let g=0;g<4;g++){const h=n.getComponent(g);if(0!==h){const n=t.getComponent(g);c.multiplyMatrices(p.bones[n].matrixWorld,p.boneInverses[n]),d.addScaledVector(o.copy(e).applyMatrix4(c),h)}}return d.applyMatrix4(this.bindMatrixInverse)}}()});const Ws=new Matrix4,qs=new Matrix4;function Skeleton(e,t){if(e=e||[],this.bones=e.slice(0),this.boneMatrices=new Float32Array(16*this.bones.length),this.frame=-1,void 0===t)this.calculateInverses();else if(this.bones.length===t.length)this.boneInverses=t.slice(0);else{console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Matrix4)}}function Bone(){Object3D.call(this),this.type="Bone"}Object.assign(Skeleton.prototype,{calculateInverses:function(){this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++){const t=new Matrix4;this.bones[e]&&t.getInverse(this.bones[e].matrixWorld),this.boneInverses.push(t)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.getInverse(this.boneInverses[e])}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.getInverse(t.parent.matrixWorld),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,o=this.boneTexture;for(let c=0,h=e.length;c<h;c++){const o=e[c]?e[c].matrixWorld:qs;Ws.multiplyMatrices(o,t[c]),Ws.toArray(n,16*c)}void 0!==o&&(o.needsUpdate=!0)},clone:function(){return new Skeleton(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}},dispose:function(){this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=void 0)}}),Bone.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Bone,isBone:!0});const Xs=new Matrix4,Ys=new Matrix4,Zs=[],Js=new Mesh;function InstancedMesh(e,t,n){Mesh.call(this,e,t),this.instanceMatrix=new BufferAttribute(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}function LineBasicMaterial(e){Material.call(this),this.type="LineBasicMaterial",this.color=new Color(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}InstancedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:InstancedMesh,isInstancedMesh:!0,copy:function(e){return Mesh.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},setColorAt:function(e,t){null===this.instanceColor&&(this.instanceColor=new BufferAttribute(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){const n=this.matrixWorld,o=this.count;if(Js.geometry=this.geometry,Js.material=this.material,void 0!==Js.material)for(let c=0;c<o;c++){this.getMatrixAt(c,Xs),Ys.multiplyMatrices(n,Xs),Js.matrixWorld=Ys,Js.raycast(e,Zs);for(let e=0,n=Zs.length;e<n;e++){const n=Zs[e];n.instanceId=c,n.object=this,t.push(n)}Zs.length=0}},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){}}),LineBasicMaterial.prototype=Object.create(Material.prototype),LineBasicMaterial.prototype.constructor=LineBasicMaterial,LineBasicMaterial.prototype.isLineBasicMaterial=!0,LineBasicMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const Qs=new Vector3,Ks=new Vector3,$s=new Matrix4,ec=new Ray,tc=new Sphere;function Line(e,t,n){1===n&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),Object3D.call(this),this.type="Line",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new LineBasicMaterial,this.updateMorphTargets()}Line.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Line,isLine:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,o=t.count;e<o;e++)Qs.fromBufferAttribute(t,e-1),Ks.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=Qs.distanceTo(Ks);e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;n[0]=0;for(let e=1,o=t.length;e<o;e++)n[e]=n[e-1],n[e]+=t[e-1].distanceTo(t[e])}return this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,c=e.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),tc.copy(n.boundingSphere),tc.applyMatrix4(o),tc.radius+=c,!1===e.ray.intersectsSphere(tc))return;$s.getInverse(o),ec.copy(e.ray).applyMatrix4($s);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h,p=new Vector3,m=new Vector3,g=new Vector3,y=new Vector3,x=this&&this.isLineSegments?2:1;if(n.isBufferGeometry){const o=n.index,c=n.attributes,h=c.position.array;if(null!==o){const n=o.array;for(let o=0,c=n.length-1;o<c;o+=x){const c=n[o],x=n[o+1];p.fromArray(h,3*c),m.fromArray(h,3*x);const b=ec.distanceSqToSegment(p,m,y,g);if(b>d)continue;y.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(y);M<e.near||M>e.far||t.push({distance:M,point:g.clone().applyMatrix4(this.matrixWorld),index:o,face:null,faceIndex:null,object:this})}}else for(let n=0,b=h.length/3-1;n<b;n+=x){p.fromArray(h,3*n),m.fromArray(h,3*n+3);const o=ec.distanceSqToSegment(p,m,y,g);if(o>d)continue;y.applyMatrix4(this.matrixWorld);const c=e.ray.origin.distanceTo(y);c<e.near||c>e.far||t.push({distance:c,point:g.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const o=n.vertices,c=o.length;for(let n=0;n<c-1;n+=x){const c=ec.distanceSqToSegment(o[n],o[n+1],y,g);if(c>d)continue;y.applyMatrix4(this.matrixWorld);const h=e.ray.origin.distanceTo(y);h<e.near||h>e.far||t.push({distance:h,point:g.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const nc=new Vector3,rc=new Vector3;function LineSegments(e,t){Line.call(this,e,t),this.type="LineSegments"}function LineLoop(e,t){Line.call(this,e,t),this.type="LineLoop"}function PointsMaterial(e){Material.call(this),this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}LineSegments.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,o=t.count;e<o;e+=2)nc.fromBufferAttribute(t,e),rc.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+nc.distanceTo(rc);e.setAttribute("lineDistance",new Float32BufferAttribute(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;for(let e=0,o=t.length;e<o;e+=2)nc.copy(t[e]),rc.copy(t[e+1]),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+nc.distanceTo(rc)}return this}}),LineLoop.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineLoop,isLineLoop:!0}),PointsMaterial.prototype=Object.create(Material.prototype),PointsMaterial.prototype.constructor=PointsMaterial,PointsMaterial.prototype.isPointsMaterial=!0,PointsMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const ic=new Matrix4,oc=new Ray,ac=new Sphere,sc=new Vector3;function Points(e,t){Object3D.call(this),this.type="Points",this.geometry=void 0!==e?e:new BufferGeometry,this.material=void 0!==t?t:new PointsMaterial,this.updateMorphTargets()}function testPoint(e,t,n,o,c,h,d){const p=oc.distanceSqToPoint(e);if(p<n){const n=new Vector3;oc.closestPointToPoint(e,n),n.applyMatrix4(o);const m=c.ray.origin.distanceTo(n);if(m<c.near||m>c.far)return;h.push({distance:m,distanceToRay:Math.sqrt(p),point:n,index:t,face:null,object:d})}}function VideoTexture(e,t,n,o,c,h,d,p,m){Texture.call(this,e,t,n,o,c,h,d,p,m),this.format=void 0!==d?d:We,this.minFilter=void 0!==h?h:Le,this.magFilter=void 0!==c?c:Le,this.generateMipmaps=!1;const g=this;function updateVideo(){g.needsUpdate=!0,e.requestVideoFrameCallback(updateVideo)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(updateVideo)}function CompressedTexture(e,t,n,o,c,h,d,p,m,g,y,x){Texture.call(this,null,h,d,p,m,g,o,c,y,x),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function CanvasTexture(e,t,n,o,c,h,d,p,m){Texture.call(this,e,t,n,o,c,h,d,p,m),this.needsUpdate=!0}function DepthTexture(e,t,n,o,c,h,d,p,m,g){if(g=void 0!==g?g:Je,g!==Je&&g!==Qe)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&g===Je&&(n=Ie),void 0===n&&g===Qe&&(n=ke),Texture.call(this,null,o,c,h,d,p,g,n,m),this.image={width:e,height:t},this.magFilter=void 0!==d?d:_e,this.minFilter=void 0!==p?p:_e,this.flipY=!1,this.generateMipmaps=!1}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,o=this.matrixWorld,c=e.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),ac.copy(n.boundingSphere),ac.applyMatrix4(o),ac.radius+=c,!1===e.ray.intersectsSphere(ac))return;ic.getInverse(o),oc.copy(e.ray).applyMatrix4(ic);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h;if(n.isBufferGeometry){const c=n.index,h=n.attributes,p=h.position.array;if(null!==c){const n=c.array;for(let c=0,h=n.length;c<h;c++){const h=n[c];sc.fromArray(p,3*h),testPoint(sc,h,d,o,e,t,this)}}else for(let n=0,m=p.length/3;n<m;n++)sc.fromArray(p,3*n),testPoint(sc,n,d,o,e,t,this)}else{const c=n.vertices;for(let n=0,h=c.length;n<h;n++)testPoint(c[n],n,d,o,e,t,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),VideoTexture.prototype=Object.assign(Object.create(Texture.prototype),{constructor:VideoTexture,isVideoTexture:!0,update:function(){const e=this.image,t="requestVideoFrameCallback"in e;!1===t&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),CompressedTexture.prototype=Object.create(Texture.prototype),CompressedTexture.prototype.constructor=CompressedTexture,CompressedTexture.prototype.isCompressedTexture=!0,CanvasTexture.prototype=Object.create(Texture.prototype),CanvasTexture.prototype.constructor=CanvasTexture,CanvasTexture.prototype.isCanvasTexture=!0,DepthTexture.prototype=Object.create(Texture.prototype),DepthTexture.prototype.constructor=DepthTexture,DepthTexture.prototype.isDepthTexture=!0;class WireframeGeometry extends BufferGeometry{constructor(e){super(),this.type="WireframeGeometry";const t=[],n=[0,0],o={},c=["a","b","c"];if(e&&e.isGeometry){const h=e.faces;for(let e=0,t=h.length;e<t;e++){const t=h[e];for(let e=0;e<3;e++){const h=t[c[e]],d=t[c[(e+1)%3]];n[0]=Math.min(h,d),n[1]=Math.max(h,d);const p=n[0]+","+n[1];void 0===o[p]&&(o[p]={index1:n[0],index2:n[1]})}}for(const n in o){const c=o[n];let h=e.vertices[c.index1];t.push(h.x,h.y,h.z),h=e.vertices[c.index2],t.push(h.x,h.y,h.z)}}else if(e&&e.isBufferGeometry){const c=new Vector3;if(null!==e.index){const h=e.attributes.position,d=e.index;let p=e.groups;0===p.length&&(p=[{start:0,count:d.count,materialIndex:0}]);for(let e=0,t=p.length;e<t;++e){const t=p[e],c=t.start,h=t.count;for(let e=c,p=c+h;e<p;e+=3)for(let t=0;t<3;t++){const c=d.getX(e+t),h=d.getX(e+(t+1)%3);n[0]=Math.min(c,h),n[1]=Math.max(c,h);const p=n[0]+","+n[1];void 0===o[p]&&(o[p]={index1:n[0],index2:n[1]})}}for(const e in o){const n=o[e];c.fromBufferAttribute(h,n.index1),t.push(c.x,c.y,c.z),c.fromBufferAttribute(h,n.index2),t.push(c.x,c.y,c.z)}}else{const n=e.attributes.position;for(let e=0,o=n.count/3;e<o;e++)for(let h=0;h<3;h++){const o=3*e+h;c.fromBufferAttribute(n,o),t.push(c.x,c.y,c.z);const d=3*e+(h+1)%3;c.fromBufferAttribute(n,d),t.push(c.x,c.y,c.z)}}}this.setAttribute("position",new Float32BufferAttribute(t,3))}}function ParametricGeometry(e,t,n){Geometry.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n},this.fromBufferGeometry(new ParametricBufferGeometry(e,t,n)),this.mergeVertices()}function ParametricBufferGeometry(e,t,n){BufferGeometry.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:n};const o=[],c=[],h=[],d=[],p=1e-5,m=new Vector3,g=new Vector3,y=new Vector3,x=new Vector3,b=new Vector3;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const M=t+1;for(let _=0;_<=n;_++){const o=_/n;for(let n=0;n<=t;n++){const M=n/t;e(M,o,g),c.push(g.x,g.y,g.z),M-p>=0?(e(M-p,o,y),x.subVectors(g,y)):(e(M+p,o,y),x.subVectors(y,g)),o-p>=0?(e(M,o-p,y),b.subVectors(g,y)):(e(M,o+p,y),b.subVectors(y,g)),m.crossVectors(x,b).normalize(),h.push(m.x,m.y,m.z),d.push(M,o)}}for(let _=0;_<n;_++)for(let e=0;e<t;e++){const t=_*M+e,n=_*M+e+1,c=(_+1)*M+e+1,h=(_+1)*M+e;o.push(t,n,h),o.push(n,c,h)}this.setIndex(o),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2))}ParametricGeometry.prototype=Object.create(Geometry.prototype),ParametricGeometry.prototype.constructor=ParametricGeometry,ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype),ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;class PolyhedronGeometry extends Geometry{constructor(e,t,n,o){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:o},this.fromBufferGeometry(new PolyhedronBufferGeometry(e,t,n,o)),this.mergeVertices()}}class PolyhedronBufferGeometry extends BufferGeometry{constructor(e,t,n,o){super(),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:o},n=n||1,o=o||0;const c=[],h=[];function subdivide(e){const n=new Vector3,o=new Vector3,c=new Vector3;for(let h=0;h<t.length;h+=3)getVertexByIndex(t[h+0],n),getVertexByIndex(t[h+1],o),getVertexByIndex(t[h+2],c),subdivideFace(n,o,c,e)}function subdivideFace(e,t,n,o){const c=Math.pow(2,o),h=[];for(let d=0;d<=c;d++){h[d]=[];const o=e.clone().lerp(n,d/c),p=t.clone().lerp(n,d/c),m=c-d;for(let e=0;e<=m;e++)h[d][e]=0===e&&d===c?o:o.clone().lerp(p,e/m)}for(let d=0;d<c;d++)for(let e=0;e<2*(c-d)-1;e++){const t=Math.floor(e/2);e%2===0?(pushVertex(h[d][t+1]),pushVertex(h[d+1][t]),pushVertex(h[d][t])):(pushVertex(h[d][t+1]),pushVertex(h[d+1][t+1]),pushVertex(h[d+1][t]))}}function applyRadius(e){const t=new Vector3;for(let n=0;n<c.length;n+=3)t.x=c[n+0],t.y=c[n+1],t.z=c[n+2],t.normalize().multiplyScalar(e),c[n+0]=t.x,c[n+1]=t.y,c[n+2]=t.z}function generateUVs(){const e=new Vector3;for(let t=0;t<c.length;t+=3){e.x=c[t+0],e.y=c[t+1],e.z=c[t+2];const n=azimuth(e)/2/Math.PI+.5,o=inclination(e)/Math.PI+.5;h.push(n,1-o)}correctUVs(),correctSeam()}function correctSeam(){for(let e=0;e<h.length;e+=6){const t=h[e+0],n=h[e+2],o=h[e+4],c=Math.max(t,n,o),d=Math.min(t,n,o);c>.9&&d<.1&&(t<.2&&(h[e+0]+=1),n<.2&&(h[e+2]+=1),o<.2&&(h[e+4]+=1))}}function pushVertex(e){c.push(e.x,e.y,e.z)}function getVertexByIndex(t,n){const o=3*t;n.x=e[o+0],n.y=e[o+1],n.z=e[o+2]}function correctUVs(){const e=new Vector3,t=new Vector3,n=new Vector3,o=new Vector3,d=new Vector2,p=new Vector2,m=new Vector2;for(let g=0,y=0;g<c.length;g+=9,y+=6){e.set(c[g+0],c[g+1],c[g+2]),t.set(c[g+3],c[g+4],c[g+5]),n.set(c[g+6],c[g+7],c[g+8]),d.set(h[y+0],h[y+1]),p.set(h[y+2],h[y+3]),m.set(h[y+4],h[y+5]),o.copy(e).add(t).add(n).divideScalar(3);const x=azimuth(o);correctUV(d,y+0,e,x),correctUV(p,y+2,t,x),correctUV(m,y+4,n,x)}}function correctUV(e,t,n,o){o<0&&1===e.x&&(h[t]=e.x-1),0===n.x&&0===n.z&&(h[t]=o/2/Math.PI+.5)}function azimuth(e){return Math.atan2(e.z,-e.x)}function inclination(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}subdivide(o),applyRadius(n),generateUVs(),this.setAttribute("position",new Float32BufferAttribute(c,3)),this.setAttribute("normal",new Float32BufferAttribute(c.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(h,2)),0===o?this.computeVertexNormals():this.normalizeNormals()}}class TetrahedronGeometry extends Geometry{constructor(e,t){super(),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new TetrahedronBufferGeometry(e,t)),this.mergeVertices()}}class TetrahedronBufferGeometry extends PolyhedronBufferGeometry{constructor(e,t){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],o=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,o,e,t),this.type="TetrahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class OctahedronGeometry extends Geometry{constructor(e,t){super(),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new OctahedronBufferGeometry(e,t)),this.mergeVertices()}}class OctahedronBufferGeometry extends PolyhedronBufferGeometry{constructor(e,t){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],o=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,o,e,t),this.type="OctahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class IcosahedronGeometry extends Geometry{constructor(e,t){super(),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new IcosahedronBufferGeometry(e,t)),this.mergeVertices()}}class IcosahedronBufferGeometry extends PolyhedronBufferGeometry{constructor(e,t){const n=(1+Math.sqrt(5))/2,o=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],c=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(o,c,e,t),this.type="IcosahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class DodecahedronGeometry extends Geometry{constructor(e,t){super(),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new DodecahedronBufferGeometry(e,t)),this.mergeVertices()}}class DodecahedronBufferGeometry extends PolyhedronBufferGeometry{constructor(e,t){const n=(1+Math.sqrt(5))/2,o=1/n,c=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-o,-n,0,-o,n,0,o,-n,0,o,n,-o,-n,0,-o,n,0,o,-n,0,o,n,0,-n,0,-o,n,0,-o,-n,0,o,n,0,o],h=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(c,h,e,t),this.type="DodecahedronBufferGeometry",this.parameters={radius:e,detail:t}}}class TubeGeometry extends Geometry{constructor(e,t,n,o,c,h){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:o,closed:c},void 0!==h&&console.warn("THREE.TubeGeometry: taper has been removed.");const d=new TubeBufferGeometry(e,t,n,o,c);this.tangents=d.tangents,this.normals=d.normals,this.binormals=d.binormals,this.fromBufferGeometry(d),this.mergeVertices()}}class TubeBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c){super(),this.type="TubeBufferGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:o,closed:c},t=t||64,n=n||1,o=o||8,c=c||!1;const h=e.computeFrenetFrames(t,c);this.tangents=h.tangents,this.normals=h.normals,this.binormals=h.binormals;const d=new Vector3,p=new Vector3,m=new Vector2;let g=new Vector3;const y=[],x=[],b=[],M=[];function generateBufferData(){for(let e=0;e<t;e++)generateSegment(e);generateSegment(!1===c?t:0),generateUVs(),generateIndices()}function generateSegment(c){g=e.getPointAt(c/t,g);const m=h.normals[c],b=h.binormals[c];for(let e=0;e<=o;e++){const t=e/o*Math.PI*2,c=Math.sin(t),h=-Math.cos(t);p.x=h*m.x+c*b.x,p.y=h*m.y+c*b.y,p.z=h*m.z+c*b.z,p.normalize(),x.push(p.x,p.y,p.z),d.x=g.x+n*p.x,d.y=g.y+n*p.y,d.z=g.z+n*p.z,y.push(d.x,d.y,d.z)}}function generateIndices(){for(let e=1;e<=t;e++)for(let t=1;t<=o;t++){const n=(o+1)*(e-1)+(t-1),c=(o+1)*e+(t-1),h=(o+1)*e+t,d=(o+1)*(e-1)+t;M.push(n,c,d),M.push(c,h,d)}}function generateUVs(){for(let e=0;e<=t;e++)for(let n=0;n<=o;n++)m.x=e/t,m.y=n/o,b.push(m.x,m.y)}generateBufferData(),this.setIndex(M),this.setAttribute("position",new Float32BufferAttribute(y,3)),this.setAttribute("normal",new Float32BufferAttribute(x,3)),this.setAttribute("uv",new Float32BufferAttribute(b,2))}toJSON(){const e=BufferGeometry.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class TorusKnotGeometry extends Geometry{constructor(e,t,n,o,c,h,d){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:o,p:c,q:h},void 0!==d&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new TorusKnotBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}}class TorusKnotBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c,h){super(),this.type="TorusKnotBufferGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:o,p:c,q:h},e=e||1,t=t||.4,n=Math.floor(n)||64,o=Math.floor(o)||8,c=c||2,h=h||3;const d=[],p=[],m=[],g=[],y=new Vector3,x=new Vector3,b=new Vector3,M=new Vector3,_=new Vector3,w=new Vector3,S=new Vector3;for(let T=0;T<=n;++T){const d=T/n*c*Math.PI*2;calculatePositionOnCurve(d,c,h,e,b),calculatePositionOnCurve(d+.01,c,h,e,M),w.subVectors(M,b),S.addVectors(M,b),_.crossVectors(w,S),S.crossVectors(_,w),_.normalize(),S.normalize();for(let e=0;e<=o;++e){const c=e/o*Math.PI*2,h=-t*Math.cos(c),d=t*Math.sin(c);y.x=b.x+(h*S.x+d*_.x),y.y=b.y+(h*S.y+d*_.y),y.z=b.z+(h*S.z+d*_.z),p.push(y.x,y.y,y.z),x.subVectors(y,b).normalize(),m.push(x.x,x.y,x.z),g.push(T/n),g.push(e/o)}}for(let T=1;T<=n;T++)for(let e=1;e<=o;e++){const t=(o+1)*(T-1)+(e-1),n=(o+1)*T+(e-1),c=(o+1)*T+e,h=(o+1)*(T-1)+e;d.push(t,n,h),d.push(n,c,h)}function calculatePositionOnCurve(e,t,n,o,c){const h=Math.cos(e),d=Math.sin(e),p=n/t*e,m=Math.cos(p);c.x=o*(2+m)*.5*h,c.y=o*(2+m)*d*.5,c.z=o*Math.sin(p)*.5}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(g,2))}}class TorusGeometry extends Geometry{constructor(e,t,n,o,c){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:o,arc:c},this.fromBufferGeometry(new TorusBufferGeometry(e,t,n,o,c)),this.mergeVertices()}}class TorusBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c){super(),this.type="TorusBufferGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:o,arc:c},e=e||1,t=t||.4,n=Math.floor(n)||8,o=Math.floor(o)||6,c=c||2*Math.PI;const h=[],d=[],p=[],m=[],g=new Vector3,y=new Vector3,x=new Vector3;for(let b=0;b<=n;b++)for(let h=0;h<=o;h++){const M=h/o*c,_=b/n*Math.PI*2;y.x=(e+t*Math.cos(_))*Math.cos(M),y.y=(e+t*Math.cos(_))*Math.sin(M),y.z=t*Math.sin(_),d.push(y.x,y.y,y.z),g.x=e*Math.cos(M),g.y=e*Math.sin(M),x.subVectors(y,g).normalize(),p.push(x.x,x.y,x.z),m.push(h/o),m.push(b/n)}for(let b=1;b<=n;b++)for(let e=1;e<=o;e++){const t=(o+1)*b+e-1,n=(o+1)*(b-1)+e-1,c=(o+1)*(b-1)+e,d=(o+1)*b+e;h.push(t,n,d),h.push(n,c,d)}this.setIndex(h),this.setAttribute("position",new Float32BufferAttribute(d,3)),this.setAttribute("normal",new Float32BufferAttribute(p,3)),this.setAttribute("uv",new Float32BufferAttribute(m,2))}}const cc={triangulate:function(e,t,n){n=n||2;const o=t&&t.length,c=o?t[0]*n:e.length;let h=linkedList(e,0,c,n,!0);const d=[];if(!h||h.next===h.prev)return d;let p,m,g,y,x,b,M;if(o&&(h=eliminateHoles(e,t,h,n)),e.length>80*n){p=g=e[0],m=y=e[1];for(let t=n;t<c;t+=n)x=e[t],b=e[t+1],x<p&&(p=x),b<m&&(m=b),x>g&&(g=x),b>y&&(y=b);M=Math.max(g-p,y-m),M=0!==M?1/M:0}return earcutLinked(h,d,n,p,m,M),d}};function linkedList(e,t,n,o,c){let h,d;if(c===signedArea(e,t,n,o)>0)for(h=t;h<n;h+=o)d=insertNode(h,e[h],e[h+1],d);else for(h=n-o;h>=t;h-=o)d=insertNode(h,e[h],e[h+1],d);return d&&equals(d,d.next)&&(removeNode(d),d=d.next),d}function filterPoints(e,t){if(!e)return e;t||(t=e);let n,o=e;do{if(n=!1,o.steiner||!equals(o,o.next)&&0!==area(o.prev,o,o.next))o=o.next;else{if(removeNode(o),o=t=o.prev,o===o.next)break;n=!0}}while(n||o!==t);return t}function earcutLinked(e,t,n,o,c,h,d){if(!e)return;!d&&h&&indexCurve(e,o,c,h);let p,m,g=e;while(e.prev!==e.next)if(p=e.prev,m=e.next,h?isEarHashed(e,o,c,h):isEar(e))t.push(p.i/n),t.push(e.i/n),t.push(m.i/n),removeNode(e),e=m.next,g=m.next;else if(e=m,e===g){d?1===d?(e=cureLocalIntersections(filterPoints(e),t,n),earcutLinked(e,t,n,o,c,h,2)):2===d&&splitEarcut(e,t,n,o,c,h):earcutLinked(filterPoints(e),t,n,o,c,h,1);break}}function isEar(e){const t=e.prev,n=e,o=e.next;if(area(t,n,o)>=0)return!1;let c=e.next.next;while(c!==e.prev){if(pointInTriangle(t.x,t.y,n.x,n.y,o.x,o.y,c.x,c.y)&&area(c.prev,c,c.next)>=0)return!1;c=c.next}return!0}function isEarHashed(e,t,n,o){const c=e.prev,h=e,d=e.next;if(area(c,h,d)>=0)return!1;const p=c.x<h.x?c.x<d.x?c.x:d.x:h.x<d.x?h.x:d.x,m=c.y<h.y?c.y<d.y?c.y:d.y:h.y<d.y?h.y:d.y,g=c.x>h.x?c.x>d.x?c.x:d.x:h.x>d.x?h.x:d.x,y=c.y>h.y?c.y>d.y?c.y:d.y:h.y>d.y?h.y:d.y,x=zOrder(p,m,t,n,o),b=zOrder(g,y,t,n,o);let M=e.prevZ,_=e.nextZ;while(M&&M.z>=x&&_&&_.z<=b){if(M!==e.prev&&M!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,M.x,M.y)&&area(M.prev,M,M.next)>=0)return!1;if(M=M.prevZ,_!==e.prev&&_!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,_.x,_.y)&&area(_.prev,_,_.next)>=0)return!1;_=_.nextZ}while(M&&M.z>=x){if(M!==e.prev&&M!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,M.x,M.y)&&area(M.prev,M,M.next)>=0)return!1;M=M.prevZ}while(_&&_.z<=b){if(_!==e.prev&&_!==e.next&&pointInTriangle(c.x,c.y,h.x,h.y,d.x,d.y,_.x,_.y)&&area(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function cureLocalIntersections(e,t,n){let o=e;do{const c=o.prev,h=o.next.next;!equals(c,h)&&intersects(c,o,o.next,h)&&locallyInside(c,h)&&locallyInside(h,c)&&(t.push(c.i/n),t.push(o.i/n),t.push(h.i/n),removeNode(o),removeNode(o.next),o=e=h),o=o.next}while(o!==e);return filterPoints(o)}function splitEarcut(e,t,n,o,c,h){let d=e;do{let e=d.next.next;while(e!==d.prev){if(d.i!==e.i&&isValidDiagonal(d,e)){let p=splitPolygon(d,e);return d=filterPoints(d,d.next),p=filterPoints(p,p.next),earcutLinked(d,t,n,o,c,h),void earcutLinked(p,t,n,o,c,h)}e=e.next}d=d.next}while(d!==e)}function eliminateHoles(e,t,n,o){const c=[];let h,d,p,m,g;for(h=0,d=t.length;h<d;h++)p=t[h]*o,m=h<d-1?t[h+1]*o:e.length,g=linkedList(e,p,m,o,!1),g===g.next&&(g.steiner=!0),c.push(getLeftmost(g));for(c.sort(compareX),h=0;h<c.length;h++)eliminateHole(c[h],n),n=filterPoints(n,n.next);return n}function compareX(e,t){return e.x-t.x}function eliminateHole(e,t){if(t=findHoleBridge(e,t),t){const n=splitPolygon(t,e);filterPoints(t,t.next),filterPoints(n,n.next)}}function findHoleBridge(e,t){let n=t;const o=e.x,c=e.y;let h,d=-1/0;do{if(c<=n.y&&c>=n.next.y&&n.next.y!==n.y){const e=n.x+(c-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=o&&e>d){if(d=e,e===o){if(c===n.y)return n;if(c===n.next.y)return n.next}h=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!h)return null;if(o===d)return h;const p=h,m=h.x,g=h.y;let y,x=1/0;n=h;do{o>=n.x&&n.x>=m&&o!==n.x&&pointInTriangle(c<g?o:d,c,m,g,c<g?d:o,c,n.x,n.y)&&(y=Math.abs(c-n.y)/(o-n.x),locallyInside(n,e)&&(y<x||y===x&&(n.x>h.x||n.x===h.x&&sectorContainsSector(h,n)))&&(h=n,x=y)),n=n.next}while(n!==p);return h}function sectorContainsSector(e,t){return area(e.prev,e,t.prev)<0&&area(t.next,e,e.next)<0}function indexCurve(e,t,n,o){let c=e;do{null===c.z&&(c.z=zOrder(c.x,c.y,t,n,o)),c.prevZ=c.prev,c.nextZ=c.next,c=c.next}while(c!==e);c.prevZ.nextZ=null,c.prevZ=null,sortLinked(c)}function sortLinked(e){let t,n,o,c,h,d,p,m,g=1;do{n=e,e=null,h=null,d=0;while(n){for(d++,o=n,p=0,t=0;t<g;t++)if(p++,o=o.nextZ,!o)break;m=g;while(p>0||m>0&&o)0!==p&&(0===m||!o||n.z<=o.z)?(c=n,n=n.nextZ,p--):(c=o,o=o.nextZ,m--),h?h.nextZ=c:e=c,c.prevZ=h,h=c;n=o}h.nextZ=null,g*=2}while(d>1);return e}function zOrder(e,t,n,o,c){return e=32767*(e-n)*c,t=32767*(t-o)*c,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),e|t<<1}function getLeftmost(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function pointInTriangle(e,t,n,o,c,h,d,p){return(c-d)*(t-p)-(e-d)*(h-p)>=0&&(e-d)*(o-p)-(n-d)*(t-p)>=0&&(n-d)*(h-p)-(c-d)*(o-p)>=0}function isValidDiagonal(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!intersectsPolygon(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&middleInside(e,t)&&(area(e.prev,e,t.prev)||area(e,t.prev,t))||equals(e,t)&&area(e.prev,e,e.next)>0&&area(t.prev,t,t.next)>0)}function area(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function equals(e,t){return e.x===t.x&&e.y===t.y}function intersects(e,t,n,o){const c=sign(area(e,t,n)),h=sign(area(e,t,o)),d=sign(area(n,o,e)),p=sign(area(n,o,t));return c!==h&&d!==p||(!(0!==c||!onSegment(e,n,t))||(!(0!==h||!onSegment(e,o,t))||(!(0!==d||!onSegment(n,e,o))||!(0!==p||!onSegment(n,t,o)))))}function onSegment(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function sign(e){return e>0?1:e<0?-1:0}function intersectsPolygon(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&intersects(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}function locallyInside(e,t){return area(e.prev,e,e.next)<0?area(e,t,e.next)>=0&&area(e,e.prev,t)>=0:area(e,t,e.prev)<0||area(e,e.next,t)<0}function middleInside(e,t){let n=e,o=!1;const c=(e.x+t.x)/2,h=(e.y+t.y)/2;do{n.y>h!==n.next.y>h&&n.next.y!==n.y&&c<(n.next.x-n.x)*(h-n.y)/(n.next.y-n.y)+n.x&&(o=!o),n=n.next}while(n!==e);return o}function splitPolygon(e,t){const n=new Node(e.i,e.x,e.y),o=new Node(t.i,t.x,t.y),c=e.next,h=t.prev;return e.next=t,t.prev=e,n.next=c,c.prev=n,o.next=n,n.prev=o,h.next=o,o.prev=h,o}function insertNode(e,t,n,o){const c=new Node(e,t,n);return o?(c.next=o.next,c.prev=o,o.next.prev=c,o.next=c):(c.prev=c,c.next=c),c}function removeNode(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(e,t,n,o){let c=0;for(let h=t,d=n-o;h<n;h+=o)c+=(e[d]-e[h])*(e[h+1]+e[d+1]),d=h;return c}const lc={area:function(e){const t=e.length;let n=0;for(let o=t-1,c=0;c<t;o=c++)n+=e[o].x*e[c].y-e[c].x*e[o].y;return.5*n},isClockWise:function(e){return lc.area(e)<0},triangulateShape:function(e,t){const n=[],o=[],c=[];removeDupEndPts(e),addContour(n,e);let h=e.length;t.forEach(removeDupEndPts);for(let p=0;p<t.length;p++)o.push(h),h+=t[p].length,addContour(n,t[p]);const d=cc.triangulate(n,o);for(let p=0;p<d.length;p+=3)c.push(d.slice(p,p+3));return c}};function removeDupEndPts(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function addContour(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class ExtrudeGeometry extends Geometry{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},this.fromBufferGeometry(new ExtrudeBufferGeometry(e,t)),this.mergeVertices()}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return toJSON(t,n,e)}}class ExtrudeBufferGeometry extends BufferGeometry{constructor(e,t){super(),this.type="ExtrudeBufferGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,o=[],c=[];for(let h=0,d=e.length;h<d;h++){const t=e[h];addShape(t)}function addShape(e){const h=[],d=void 0!==t.curveSegments?t.curveSegments:12,p=void 0!==t.steps?t.steps:1;let m=void 0!==t.depth?t.depth:100,g=void 0===t.bevelEnabled||t.bevelEnabled,y=void 0!==t.bevelThickness?t.bevelThickness:6,x=void 0!==t.bevelSize?t.bevelSize:y-2,b=void 0!==t.bevelOffset?t.bevelOffset:0,M=void 0!==t.bevelSegments?t.bevelSegments:3;const _=t.extrudePath,w=void 0!==t.UVGenerator?t.UVGenerator:uc;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),m=t.amount);let S,T,E,L,A,C=!1;_&&(S=_.getSpacedPoints(p),C=!0,g=!1,T=_.computeFrenetFrames(p,!1),E=new Vector3,L=new Vector3,A=new Vector3),g||(M=0,y=0,x=0,b=0);const P=e.extractPoints(d);let R=P.shape;const B=P.holes,D=!lc.isClockWise(R);if(D){R=R.reverse();for(let e=0,t=B.length;e<t;e++){const t=B[e];lc.isClockWise(t)&&(B[e]=t.reverse())}}const G=lc.triangulateShape(R,B),I=R;for(let t=0,n=B.length;t<n;t++){const e=B[t];R=R.concat(e)}function scalePt2(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const O=R.length,V=G.length;function getBevelVec(e,t,n){let o,c,h;const d=e.x-t.x,p=e.y-t.y,m=n.x-e.x,g=n.y-e.y,y=d*d+p*p,x=d*g-p*m;if(Math.abs(x)>Number.EPSILON){const x=Math.sqrt(y),b=Math.sqrt(m*m+g*g),M=t.x-p/x,_=t.y+d/x,w=n.x-g/b,S=n.y+m/b,T=((w-M)*g-(S-_)*m)/(d*g-p*m);o=M+d*T-e.x,c=_+p*T-e.y;const E=o*o+c*c;if(E<=2)return new Vector2(o,c);h=Math.sqrt(E/2)}else{let e=!1;d>Number.EPSILON?m>Number.EPSILON&&(e=!0):d<-Number.EPSILON?m<-Number.EPSILON&&(e=!0):Math.sign(p)===Math.sign(g)&&(e=!0),e?(o=-p,c=d,h=Math.sqrt(y)):(o=d,c=p,h=Math.sqrt(y/2))}return new Vector2(o/h,c/h)}const N=[];for(let t=0,n=I.length,o=n-1,c=t+1;t<n;t++,o++,c++)o===n&&(o=0),c===n&&(c=0),N[t]=getBevelVec(I[t],I[o],I[c]);const F=[];let U,z=N.concat();for(let t=0,n=B.length;t<n;t++){const e=B[t];U=[];for(let t=0,n=e.length,o=n-1,c=t+1;t<n;t++,o++,c++)o===n&&(o=0),c===n&&(c=0),U[t]=getBevelVec(e[t],e[o],e[c]);F.push(U),z=z.concat(U)}for(let t=0;t<M;t++){const e=t/M,n=y*Math.cos(e*Math.PI/2),o=x*Math.sin(e*Math.PI/2)+b;for(let t=0,c=I.length;t<c;t++){const e=scalePt2(I[t],N[t],o);v(e.x,e.y,-n)}for(let t=0,c=B.length;t<c;t++){const e=B[t];U=F[t];for(let t=0,c=e.length;t<c;t++){const c=scalePt2(e[t],U[t],o);v(c.x,c.y,-n)}}}const H=x+b;for(let t=0;t<O;t++){const e=g?scalePt2(R[t],z[t],H):R[t];C?(L.copy(T.normals[0]).multiplyScalar(e.x),E.copy(T.binormals[0]).multiplyScalar(e.y),A.copy(S[0]).add(L).add(E),v(A.x,A.y,A.z)):v(e.x,e.y,0)}for(let t=1;t<=p;t++)for(let e=0;e<O;e++){const n=g?scalePt2(R[e],z[e],H):R[e];C?(L.copy(T.normals[t]).multiplyScalar(n.x),E.copy(T.binormals[t]).multiplyScalar(n.y),A.copy(S[t]).add(L).add(E),v(A.x,A.y,A.z)):v(n.x,n.y,m/p*t)}for(let t=M-1;t>=0;t--){const e=t/M,n=y*Math.cos(e*Math.PI/2),o=x*Math.sin(e*Math.PI/2)+b;for(let t=0,c=I.length;t<c;t++){const e=scalePt2(I[t],N[t],o);v(e.x,e.y,m+n)}for(let t=0,c=B.length;t<c;t++){const e=B[t];U=F[t];for(let t=0,c=e.length;t<c;t++){const c=scalePt2(e[t],U[t],o);C?v(c.x,c.y+S[p-1].y,S[p-1].x+n):v(c.x,c.y,m+n)}}}function buildLidFaces(){const e=o.length/3;if(g){let e=0,t=O*e;for(let n=0;n<V;n++){const e=G[n];f3(e[2]+t,e[1]+t,e[0]+t)}e=p+2*M,t=O*e;for(let n=0;n<V;n++){const e=G[n];f3(e[0]+t,e[1]+t,e[2]+t)}}else{for(let e=0;e<V;e++){const t=G[e];f3(t[2],t[1],t[0])}for(let e=0;e<V;e++){const t=G[e];f3(t[0]+O*p,t[1]+O*p,t[2]+O*p)}}n.addGroup(e,o.length/3-e,0)}function buildSideFaces(){const e=o.length/3;let t=0;sidewalls(I,t),t+=I.length;for(let n=0,o=B.length;n<o;n++){const e=B[n];sidewalls(e,t),t+=e.length}n.addGroup(e,o.length/3-e,1)}function sidewalls(e,t){let n=e.length;while(--n>=0){const o=n;let c=n-1;c<0&&(c=e.length-1);for(let e=0,n=p+2*M;e<n;e++){const n=O*e,h=O*(e+1),d=t+o+n,p=t+c+n,m=t+c+h,g=t+o+h;f4(d,p,m,g)}}}function v(e,t,n){h.push(e),h.push(t),h.push(n)}function f3(e,t,c){addVertex(e),addVertex(t),addVertex(c);const h=o.length/3,d=w.generateTopUV(n,o,h-3,h-2,h-1);addUV(d[0]),addUV(d[1]),addUV(d[2])}function f4(e,t,c,h){addVertex(e),addVertex(t),addVertex(h),addVertex(t),addVertex(c),addVertex(h);const d=o.length/3,p=w.generateSideWallUV(n,o,d-6,d-3,d-2,d-1);addUV(p[0]),addUV(p[1]),addUV(p[3]),addUV(p[1]),addUV(p[2]),addUV(p[3])}function addVertex(e){o.push(h[3*e+0]),o.push(h[3*e+1]),o.push(h[3*e+2])}function addUV(e){c.push(e.x),c.push(e.y)}buildLidFaces(),buildSideFaces()}this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("uv",new Float32BufferAttribute(c,2)),this.computeVertexNormals()}toJSON(){const e=BufferGeometry.prototype.toJSON.call(this),t=this.parameters.shapes,n=this.parameters.options;return toJSON(t,n,e)}}const uc={generateTopUV:function(e,t,n,o,c){const h=t[3*n],d=t[3*n+1],p=t[3*o],m=t[3*o+1],g=t[3*c],y=t[3*c+1];return[new Vector2(h,d),new Vector2(p,m),new Vector2(g,y)]},generateSideWallUV:function(e,t,n,o,c,h){const d=t[3*n],p=t[3*n+1],m=t[3*n+2],g=t[3*o],y=t[3*o+1],x=t[3*o+2],b=t[3*c],M=t[3*c+1],_=t[3*c+2],w=t[3*h],S=t[3*h+1],T=t[3*h+2];return Math.abs(p-y)<.01?[new Vector2(d,1-m),new Vector2(g,1-x),new Vector2(b,1-_),new Vector2(w,1-T)]:[new Vector2(p,1-m),new Vector2(y,1-x),new Vector2(M,1-_),new Vector2(S,1-T)]}};function toJSON(e,t,n){if(n.shapes=[],Array.isArray(e))for(let o=0,c=e.length;o<c;o++){const t=e[o];n.shapes.push(t.uuid)}else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}class TextGeometry extends Geometry{constructor(e,t){super(),this.type="TextGeometry",this.parameters={text:e,parameters:t},this.fromBufferGeometry(new TextBufferGeometry(e,t)),this.mergeVertices()}}class TextBufferGeometry extends ExtrudeBufferGeometry{constructor(e,t){t=t||{};const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Geometry;const o=n.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),super(o,t),this.type="TextBufferGeometry"}}class SphereGeometry extends Geometry{constructor(e,t,n,o,c,h,d){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:o,phiLength:c,thetaStart:h,thetaLength:d},this.fromBufferGeometry(new SphereBufferGeometry(e,t,n,o,c,h,d)),this.mergeVertices()}}class SphereBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c,h,d){super(),this.type="SphereBufferGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:o,phiLength:c,thetaStart:h,thetaLength:d},e=e||1,t=Math.max(3,Math.floor(t)||8),n=Math.max(2,Math.floor(n)||6),o=void 0!==o?o:0,c=void 0!==c?c:2*Math.PI,h=void 0!==h?h:0,d=void 0!==d?d:Math.PI;const p=Math.min(h+d,Math.PI);let m=0;const g=[],y=new Vector3,x=new Vector3,b=[],M=[],_=[],w=[];for(let S=0;S<=n;S++){const b=[],T=S/n;let E=0;0==S&&0==h?E=.5/t:S==n&&p==Math.PI&&(E=-.5/t);for(let n=0;n<=t;n++){const p=n/t;y.x=-e*Math.cos(o+p*c)*Math.sin(h+T*d),y.y=e*Math.cos(h+T*d),y.z=e*Math.sin(o+p*c)*Math.sin(h+T*d),M.push(y.x,y.y,y.z),x.copy(y).normalize(),_.push(x.x,x.y,x.z),w.push(p+E,1-T),b.push(m++)}g.push(b)}for(let S=0;S<n;S++)for(let e=0;e<t;e++){const t=g[S][e+1],o=g[S][e],c=g[S+1][e],d=g[S+1][e+1];(0!==S||h>0)&&b.push(t,o,d),(S!==n-1||p<Math.PI)&&b.push(o,c,d)}this.setIndex(b),this.setAttribute("position",new Float32BufferAttribute(M,3)),this.setAttribute("normal",new Float32BufferAttribute(_,3)),this.setAttribute("uv",new Float32BufferAttribute(w,2))}}class RingGeometry extends Geometry{constructor(e,t,n,o,c,h){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:o,thetaStart:c,thetaLength:h},this.fromBufferGeometry(new RingBufferGeometry(e,t,n,o,c,h)),this.mergeVertices()}}class RingBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c,h){super(),this.type="RingBufferGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:o,thetaStart:c,thetaLength:h},e=e||.5,t=t||1,c=void 0!==c?c:0,h=void 0!==h?h:2*Math.PI,n=void 0!==n?Math.max(3,n):8,o=void 0!==o?Math.max(1,o):1;const d=[],p=[],m=[],g=[];let y=e;const x=(t-e)/o,b=new Vector3,M=new Vector2;for(let _=0;_<=o;_++){for(let e=0;e<=n;e++){const o=c+e/n*h;b.x=y*Math.cos(o),b.y=y*Math.sin(o),p.push(b.x,b.y,b.z),m.push(0,0,1),M.x=(b.x/t+1)/2,M.y=(b.y/t+1)/2,g.push(M.x,M.y)}y+=x}for(let _=0;_<o;_++){const e=_*(n+1);for(let t=0;t<n;t++){const o=t+e,c=o,h=o+n+1,p=o+n+2,m=o+1;d.push(c,h,m),d.push(h,p,m)}}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(g,2))}}class LatheGeometry extends Geometry{constructor(e,t,n,o){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:o},this.fromBufferGeometry(new LatheBufferGeometry(e,t,n,o)),this.mergeVertices()}}class LatheBufferGeometry extends BufferGeometry{constructor(e,t,n,o){super(),this.type="LatheBufferGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:o},t=Math.floor(t)||12,n=n||0,o=o||2*Math.PI,o=qn.clamp(o,0,2*Math.PI);const c=[],h=[],d=[],p=1/t,m=new Vector3,g=new Vector2;for(let y=0;y<=t;y++){const c=n+y*p*o,x=Math.sin(c),b=Math.cos(c);for(let n=0;n<=e.length-1;n++)m.x=e[n].x*x,m.y=e[n].y,m.z=e[n].x*b,h.push(m.x,m.y,m.z),g.x=y/t,g.y=n/(e.length-1),d.push(g.x,g.y)}for(let y=0;y<t;y++)for(let t=0;t<e.length-1;t++){const n=t+y*e.length,o=n,h=n+e.length,d=n+e.length+1,p=n+1;c.push(o,h,p),c.push(h,d,p)}if(this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2)),this.computeVertexNormals(),o===2*Math.PI){const n=this.attributes.normal.array,o=new Vector3,c=new Vector3,h=new Vector3,d=t*e.length*3;for(let t=0,p=0;t<e.length;t++,p+=3)o.x=n[p+0],o.y=n[p+1],o.z=n[p+2],c.x=n[d+p+0],c.y=n[d+p+1],c.z=n[d+p+2],h.addVectors(o,c).normalize(),n[p+0]=n[d+p+0]=h.x,n[p+1]=n[d+p+1]=h.y,n[p+2]=n[d+p+2]=h.z}}}class ShapeGeometry extends Geometry{constructor(e,t){super(),this.type="ShapeGeometry","object"===typeof t&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),t=t.curveSegments),this.parameters={shapes:e,curveSegments:t},this.fromBufferGeometry(new ShapeBufferGeometry(e,t)),this.mergeVertices()}toJSON(){const e=Geometry.prototype.toJSON.call(this),t=this.parameters.shapes;return toJSON$1(t,e)}}class ShapeBufferGeometry extends BufferGeometry{constructor(e,t){super(),this.type="ShapeBufferGeometry",this.parameters={shapes:e,curveSegments:t},t=t||12;const n=[],o=[],c=[],h=[];let d=0,p=0;if(!1===Array.isArray(e))addShape(e);else for(let m=0;m<e.length;m++)addShape(e[m]),this.addGroup(d,p,m),d+=p,p=0;function addShape(e){const d=o.length/3,m=e.extractPoints(t);let g=m.shape;const y=m.holes;!1===lc.isClockWise(g)&&(g=g.reverse());for(let t=0,n=y.length;t<n;t++){const e=y[t];!0===lc.isClockWise(e)&&(y[t]=e.reverse())}const x=lc.triangulateShape(g,y);for(let t=0,n=y.length;t<n;t++){const e=y[t];g=g.concat(e)}for(let t=0,n=g.length;t<n;t++){const e=g[t];o.push(e.x,e.y,0),c.push(0,0,1),h.push(e.x,e.y)}for(let t=0,o=x.length;t<o;t++){const e=x[t],o=e[0]+d,c=e[1]+d,h=e[2]+d;n.push(o,c,h),p+=3}}this.setIndex(n),this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("normal",new Float32BufferAttribute(c,3)),this.setAttribute("uv",new Float32BufferAttribute(h,2))}toJSON(){const e=BufferGeometry.prototype.toJSON.call(this),t=this.parameters.shapes;return toJSON$1(t,e)}}function toJSON$1(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,o=e.length;n<o;n++){const o=e[n];t.shapes.push(o.uuid)}else t.shapes.push(e.uuid);return t}class EdgesGeometry extends BufferGeometry{constructor(e,t){super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=void 0!==t?t:1;const n=[],o=Math.cos(qn.DEG2RAD*t),c=[0,0],h={};let d,p,m;const g=["a","b","c"];let y;e.isBufferGeometry?(y=new Geometry,y.fromBufferGeometry(e)):y=e.clone(),y.mergeVertices(),y.computeFaceNormals();const x=y.vertices,b=y.faces;for(let M=0,_=b.length;M<_;M++){const e=b[M];for(let t=0;t<3;t++)d=e[g[t]],p=e[g[(t+1)%3]],c[0]=Math.min(d,p),c[1]=Math.max(d,p),m=c[0]+","+c[1],void 0===h[m]?h[m]={index1:c[0],index2:c[1],face1:M,face2:void 0}:h[m].face2=M}for(m in h){const e=h[m];if(void 0===e.face2||b[e.face1].normal.dot(b[e.face2].normal)<=o){let t=x[e.index1];n.push(t.x,t.y,t.z),t=x[e.index2],n.push(t.x,t.y,t.z)}}this.setAttribute("position",new Float32BufferAttribute(n,3))}}class CylinderGeometry extends Geometry{constructor(e,t,n,o,c,h,d,p){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:o,heightSegments:c,openEnded:h,thetaStart:d,thetaLength:p},this.fromBufferGeometry(new CylinderBufferGeometry(e,t,n,o,c,h,d,p)),this.mergeVertices()}}class CylinderBufferGeometry extends BufferGeometry{constructor(e,t,n,o,c,h,d,p){super(),this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:o,heightSegments:c,openEnded:h,thetaStart:d,thetaLength:p};const m=this;e=void 0!==e?e:1,t=void 0!==t?t:1,n=n||1,o=Math.floor(o)||8,c=Math.floor(c)||1,h=void 0!==h&&h,d=void 0!==d?d:0,p=void 0!==p?p:2*Math.PI;const g=[],y=[],x=[],b=[];let M=0;const _=[],w=n/2;let S=0;function generateTorso(){const h=new Vector3,T=new Vector3;let E=0;const L=(t-e)/n;for(let m=0;m<=c;m++){const g=[],S=m/c,E=S*(t-e)+e;for(let e=0;e<=o;e++){const t=e/o,c=t*p+d,m=Math.sin(c),_=Math.cos(c);T.x=E*m,T.y=-S*n+w,T.z=E*_,y.push(T.x,T.y,T.z),h.set(m,L,_).normalize(),x.push(h.x,h.y,h.z),b.push(t,1-S),g.push(M++)}_.push(g)}for(let e=0;e<o;e++)for(let t=0;t<c;t++){const n=_[t][e],o=_[t+1][e],c=_[t+1][e+1],h=_[t][e+1];g.push(n,o,h),g.push(o,c,h),E+=6}m.addGroup(S,E,0),S+=E}function generateCap(n){const c=M,h=new Vector2,_=new Vector3;let T=0;const E=!0===n?e:t,L=!0===n?1:-1;for(let e=1;e<=o;e++)y.push(0,w*L,0),x.push(0,L,0),b.push(.5,.5),M++;const A=M;for(let e=0;e<=o;e++){const t=e/o,n=t*p+d,c=Math.cos(n),m=Math.sin(n);_.x=E*m,_.y=w*L,_.z=E*c,y.push(_.x,_.y,_.z),x.push(0,L,0),h.x=.5*c+.5,h.y=.5*m*L+.5,b.push(h.x,h.y),M++}for(let e=0;e<o;e++){const t=c+e,o=A+e;!0===n?g.push(o,o+1,t):g.push(o+1,o,t),T+=3}m.addGroup(S,T,!0===n?1:2),S+=T}generateTorso(),!1===h&&(e>0&&generateCap(!0),t>0&&generateCap(!1)),this.setIndex(g),this.setAttribute("position",new Float32BufferAttribute(y,3)),this.setAttribute("normal",new Float32BufferAttribute(x,3)),this.setAttribute("uv",new Float32BufferAttribute(b,2))}}class ConeGeometry extends CylinderGeometry{constructor(e,t,n,o,c,h,d){super(0,e,t,n,o,c,h,d),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:o,openEnded:c,thetaStart:h,thetaLength:d}}}class ConeBufferGeometry extends CylinderBufferGeometry{constructor(e,t,n,o,c,h,d){super(0,e,t,n,o,c,h,d),this.type="ConeBufferGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:o,openEnded:c,thetaStart:h,thetaLength:d}}}class CircleGeometry extends Geometry{constructor(e,t,n,o){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:o},this.fromBufferGeometry(new CircleBufferGeometry(e,t,n,o)),this.mergeVertices()}}class CircleBufferGeometry extends BufferGeometry{constructor(e,t,n,o){super(),this.type="CircleBufferGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:o},e=e||1,t=void 0!==t?Math.max(3,t):8,n=void 0!==n?n:0,o=void 0!==o?o:2*Math.PI;const c=[],h=[],d=[],p=[],m=new Vector3,g=new Vector2;h.push(0,0,0),d.push(0,0,1),p.push(.5,.5);for(let y=0,x=3;y<=t;y++,x+=3){const c=n+y/t*o;m.x=e*Math.cos(c),m.y=e*Math.sin(c),h.push(m.x,m.y,m.z),d.push(0,0,1),g.x=(h[x]/e+1)/2,g.y=(h[x+1]/e+1)/2,p.push(g.x,g.y)}for(let y=1;y<=t;y++)c.push(y,y+1,0);this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("normal",new Float32BufferAttribute(d,3)),this.setAttribute("uv",new Float32BufferAttribute(p,2))}}var hc=Object.freeze({__proto__:null,WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry});function ShadowMaterial(e){Material.call(this),this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.setValues(e)}function RawShaderMaterial(e){ShaderMaterial.call(this,e),this.type="RawShaderMaterial"}function MeshStandardMaterial(e){Material.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=mn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function MeshPhysicalMaterial(e){MeshStandardMaterial.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}function MeshPhongMaterial(e){Material.call(this),this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=mn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=re,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshToonMaterial(e){Material.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=mn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshNormalMaterial(e){Material.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=mn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshLambertMaterial(e){Material.call(this),this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=re,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function MeshMatcapMaterial(e){Material.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=mn,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function LineDashedMaterial(e){LineBasicMaterial.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}ShadowMaterial.prototype=Object.create(Material.prototype),ShadowMaterial.prototype.constructor=ShadowMaterial,ShadowMaterial.prototype.isShadowMaterial=!0,ShadowMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this},RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype),RawShaderMaterial.prototype.constructor=RawShaderMaterial,RawShaderMaterial.prototype.isRawShaderMaterial=!0,MeshStandardMaterial.prototype=Object.create(Material.prototype),MeshStandardMaterial.prototype.constructor=MeshStandardMaterial,MeshStandardMaterial.prototype.isMeshStandardMaterial=!0,MeshStandardMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},MeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype),MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial,MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=!0,MeshPhysicalMaterial.prototype.copy=function(e){return MeshStandardMaterial.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new Color).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this},MeshPhongMaterial.prototype=Object.create(Material.prototype),MeshPhongMaterial.prototype.constructor=MeshPhongMaterial,MeshPhongMaterial.prototype.isMeshPhongMaterial=!0,MeshPhongMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshToonMaterial.prototype=Object.create(Material.prototype),MeshToonMaterial.prototype.constructor=MeshToonMaterial,MeshToonMaterial.prototype.isMeshToonMaterial=!0,MeshToonMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshNormalMaterial.prototype=Object.create(Material.prototype),MeshNormalMaterial.prototype.constructor=MeshNormalMaterial,MeshNormalMaterial.prototype.isMeshNormalMaterial=!0,MeshNormalMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshLambertMaterial.prototype=Object.create(Material.prototype),MeshLambertMaterial.prototype.constructor=MeshLambertMaterial,MeshLambertMaterial.prototype.isMeshLambertMaterial=!0,MeshLambertMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},MeshMatcapMaterial.prototype=Object.create(Material.prototype),MeshMatcapMaterial.prototype.constructor=MeshMatcapMaterial,MeshMatcapMaterial.prototype.isMeshMatcapMaterial=!0,MeshMatcapMaterial.prototype.copy=function(e){return Material.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},LineDashedMaterial.prototype=Object.create(LineBasicMaterial.prototype),LineDashedMaterial.prototype.constructor=LineDashedMaterial,LineDashedMaterial.prototype.isLineDashedMaterial=!0,LineDashedMaterial.prototype.copy=function(e){return LineBasicMaterial.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var dc=Object.freeze({__proto__:null,ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});const pc={arraySlice:function(e,t,n){return pc.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"===typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function compareTime(t,n){return e[t]-e[n]}const t=e.length,n=new Array(t);for(let o=0;o!==t;++o)n[o]=o;return n.sort(compareTime),n},sortedArray:function(e,t,n){const o=e.length,c=new e.constructor(o);for(let h=0,d=0;d!==o;++h){const o=n[h]*t;for(let n=0;n!==t;++n)c[d++]=e[o+n]}return c},flattenJSON:function(e,t,n,o){let c=1,h=e[0];while(void 0!==h&&void 0===h[o])h=e[c++];if(void 0===h)return;let d=h[o];if(void 0!==d)if(Array.isArray(d))do{d=h[o],void 0!==d&&(t.push(h.time),n.push.apply(n,d)),h=e[c++]}while(void 0!==h);else if(void 0!==d.toArray)do{d=h[o],void 0!==d&&(t.push(h.time),d.toArray(n,n.length)),h=e[c++]}while(void 0!==h);else do{d=h[o],void 0!==d&&(t.push(h.time),n.push(d)),h=e[c++]}while(void 0!==h)},subclip:function(e,t,n,o,c){c=c||30;const h=e.clone();h.name=t;const d=[];for(let m=0;m<h.tracks.length;++m){const e=h.tracks[m],t=e.getValueSize(),p=[],g=[];for(let h=0;h<e.times.length;++h){const d=e.times[h]*c;if(!(d<n||d>=o)){p.push(e.times[h]);for(let n=0;n<t;++n)g.push(e.values[h*t+n])}}0!==p.length&&(e.times=pc.convertArray(p,e.times.constructor),e.values=pc.convertArray(g,e.values.constructor),d.push(e))}h.tracks=d;let p=1/0;for(let m=0;m<h.tracks.length;++m)p>h.tracks[m].times[0]&&(p=h.tracks[m].times[0]);for(let m=0;m<h.tracks.length;++m)h.tracks[m].shift(-1*p);return h.resetDuration(),h},makeClipAdditive:function(e,t,n,o){void 0===t&&(t=0),void 0===n&&(n=e),(void 0===o||o<=0)&&(o=30);const c=e.tracks.length,h=t/o;for(let d=0;d<c;++d){const t=n.tracks[d],o=t.ValueTypeName;if("bool"===o||"string"===o)continue;const c=e.tracks.find((function(e){return e.name===t.name&&e.ValueTypeName===o}));if(void 0===c)continue;let p=0;const m=t.getValueSize();t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(p=m/3);let g=0;const y=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=y/3);const x=t.times.length-1;let b;if(h<=t.times[0]){const e=p,n=m-p;b=pc.arraySlice(t.values,e,n)}else if(h>=t.times[x]){const e=x*m+p,n=e+m-p;b=pc.arraySlice(t.values,e,n)}else{const e=t.createInterpolant(),n=p,o=m-p;e.evaluate(h),b=pc.arraySlice(e.resultBuffer,n,o)}if("quaternion"===o){const e=(new Quaternion).fromArray(b).normalize().conjugate();e.toArray(b)}const M=c.times.length;for(let e=0;e<M;++e){const t=e*y+g;if("quaternion"===o)Quaternion.multiplyQuaternionsFlat(c.values,t,b,0,c.values,t);else{const e=y-2*g;for(let n=0;n<e;++n)c.values[t+n]-=b[n]}}}return e.blendMode=en,e}};function Interpolant(e,t,n,o){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==o?o:new t.constructor(n),this.sampleValues=t,this.valueSize=n}function CubicInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function LinearInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function DiscreteInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function KeyframeTrack(e,t,n,o){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=pc.convertArray(t,this.TimeBufferType),this.values=pc.convertArray(n,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}function BooleanKeyframeTrack(e,t,n){KeyframeTrack.call(this,e,t,n)}function ColorKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function NumberKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function QuaternionLinearInterpolant(e,t,n,o){Interpolant.call(this,e,t,n,o)}function QuaternionKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function StringKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function VectorKeyframeTrack(e,t,n,o){KeyframeTrack.call(this,e,t,n,o)}function AnimationClip(e,t,n,o){this.name=e,this.tracks=n,this.duration=void 0!==t?t:-1,this.blendMode=void 0!==o?o:$t,this.uuid=qn.generateUUID(),this.duration<0&&this.resetDuration()}function getTrackTypeForValueTypeName(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function parseKeyframeTrack(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=getTrackTypeForValueTypeName(e.type);if(void 0===e.times){const t=[],n=[];pc.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(Interpolant.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,o=t[n],c=t[n-1];e:{t:{let h;n:{r:if(!(e<o)){for(let h=n+2;;){if(void 0===o){if(e<c)break r;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,c)}if(n===h)break;if(c=o,o=t[++n],e<o)break t}h=t.length;break n}if(e>=c)break e;{const d=t[1];e<d&&(n=2,c=d);for(let h=n-2;;){if(void 0===c)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(n===h)break;if(o=c,c=t[--n-1],e>=c)break t}h=n,n=0}}while(n<h){const o=n+h>>>1;e<t[o]?h=o:n=o+1}if(o=t[n],c=t[n-1],void 0===c)return this._cachedIndex=0,this.beforeStart_(0,e,o);if(void 0===o)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,c,e)}this._cachedIndex=n,this.intervalChanged_(n,c,o)}return this.interpolate_(n,c,e,o)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,o=this.valueSize,c=e*o;for(let h=0;h!==o;++h)t[h]=n[c+h];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(Interpolant.prototype,{beforeStart_:Interpolant.prototype.copySampleValue_,afterEnd_:Interpolant.prototype.copySampleValue_}),CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:Jt,endingEnd:Jt},intervalChanged_:function(e,t,n){const o=this.parameterPositions;let c=e-2,h=e+1,d=o[c],p=o[h];if(void 0===d)switch(this.getSettings_().endingStart){case Qt:c=e,d=2*t-n;break;case Kt:c=o.length-2,d=t+o[c]-o[c+1];break;default:c=e,d=n}if(void 0===p)switch(this.getSettings_().endingEnd){case Qt:h=e,p=2*n-t;break;case Kt:h=1,p=n+o[1]-o[0];break;default:h=e-1,p=t}const m=.5*(n-t),g=this.valueSize;this._weightPrev=m/(t-d),this._weightNext=m/(p-n),this._offsetPrev=c*g,this._offsetNext=h*g},interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=e*d,m=p-d,g=this._offsetPrev,y=this._offsetNext,x=this._weightPrev,b=this._weightNext,M=(n-t)/(o-t),_=M*M,w=_*M,S=-x*w+2*x*_-x*M,T=(1+x)*w+(-1.5-2*x)*_+(-.5+x)*M+1,E=(-1-b)*w+(1.5+b)*_+.5*M,L=b*w-b*_;for(let A=0;A!==d;++A)c[A]=S*h[g+A]+T*h[m+A]+E*h[p+A]+L*h[y+A];return c}}),LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=e*d,m=p-d,g=(n-t)/(o-t),y=1-g;for(let x=0;x!==d;++x)c[x]=h[m+x]*y+h[p+x]*g;return c}}),DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(KeyframeTrack,{toJSON:function(e){const t=e.constructor;let n;if(void 0!==t.toJSON)n=t.toJSON(e);else{n={name:e.name,times:pc.convertArray(e.times,Array),values:pc.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}}),Object.assign(KeyframeTrack.prototype,{constructor:KeyframeTrack,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Yt,InterpolantFactoryMethodDiscrete:function(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case Xt:t=this.InterpolantFactoryMethodDiscrete;break;case Yt:t=this.InterpolantFactoryMethodLinear;break;case Zt:t=this.InterpolantFactoryMethodSmooth;break}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Xt;case this.InterpolantFactoryMethodLinear:return Yt;case this.InterpolantFactoryMethodSmooth:return Zt}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(0!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]+=e}return this},scale:function(e){if(1!==e){const t=this.times;for(let n=0,o=t.length;n!==o;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,o=n.length;let c=0,h=o-1;while(c!==o&&n[c]<e)++c;while(-1!==h&&n[h]>t)--h;if(++h,0!==c||h!==o){c>=h&&(h=Math.max(h,1),c=h-1);const e=this.getValueSize();this.times=pc.arraySlice(n,c,h),this.values=pc.arraySlice(this.values,c*e,h*e)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,o=this.values,c=n.length;0===c&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let h=null;for(let d=0;d!==c;d++){const t=n[d];if("number"===typeof t&&isNaN(t)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,d,t),e=!1;break}if(null!==h&&h>t){console.error("THREE.KeyframeTrack: Out of order keys.",this,d,t,h),e=!1;break}h=t}if(void 0!==o&&pc.isTypedArray(o))for(let d=0,p=o.length;d!==p;++d){const t=o[d];if(isNaN(t)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,d,t),e=!1;break}}return e},optimize:function(){const e=pc.arraySlice(this.times),t=pc.arraySlice(this.values),n=this.getValueSize(),o=this.getInterpolation()===Zt,c=e.length-1;let h=1;for(let d=1;d<c;++d){let c=!1;const p=e[d],m=e[d+1];if(p!==m&&(1!==d||p!==p[0]))if(o)c=!0;else{const e=d*n,o=e-n,h=e+n;for(let d=0;d!==n;++d){const n=t[e+d];if(n!==t[o+d]||n!==t[h+d]){c=!0;break}}}if(c){if(d!==h){e[h]=e[d];const o=d*n,c=h*n;for(let e=0;e!==n;++e)t[c+e]=t[o+e]}++h}}if(c>0){e[h]=e[c];for(let e=c*n,o=h*n,d=0;d!==n;++d)t[o+d]=t[e+d];++h}return h!==e.length?(this.times=pc.arraySlice(e,0,h),this.values=pc.arraySlice(t,0,h*n)):(this.times=e,this.values=t),this},clone:function(){const e=pc.arraySlice(this.times,0),t=pc.arraySlice(this.values,0),n=this.constructor,o=new n(this.name,e,t);return o.createInterpolant=this.createInterpolant,o}}),BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:BooleanKeyframeTrack,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:Xt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:ColorKeyframeTrack,ValueTypeName:"color"}),NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:NumberKeyframeTrack,ValueTypeName:"number"}),QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function(e,t,n,o){const c=this.resultBuffer,h=this.sampleValues,d=this.valueSize,p=(n-t)/(o-t);let m=e*d;for(let g=m+d;m!==g;m+=4)Quaternion.slerpFlat(c,0,h,m-d,h,m,p);return c}}),QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:"quaternion",DefaultInterpolation:Yt,InterpolantFactoryMethodLinear:function(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:StringKeyframeTrack,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:Xt,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:VectorKeyframeTrack,ValueTypeName:"vector"}),Object.assign(AnimationClip,{parse:function(e){const t=[],n=e.tracks,o=1/(e.fps||1);for(let c=0,h=n.length;c!==h;++c)t.push(parseKeyframeTrack(n[c]).scale(o));return new AnimationClip(e.name,e.duration,t,e.blendMode)},toJSON:function(e){const t=[],n=e.tracks,o={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let c=0,h=n.length;c!==h;++c)t.push(KeyframeTrack.toJSON(n[c]));return o},CreateFromMorphTargetSequence:function(e,t,n,o){const c=t.length,h=[];for(let d=0;d<c;d++){let e=[],p=[];e.push((d+c-1)%c,d,(d+1)%c),p.push(0,1,0);const m=pc.getKeyframeOrder(e);e=pc.sortedArray(e,1,m),p=pc.sortedArray(p,1,m),o||0!==e[0]||(e.push(c),p.push(p[0])),h.push(new NumberKeyframeTrack(".morphTargetInfluences["+t[d].name+"]",e,p).scale(1/n))}return new AnimationClip(e,-1,h)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let o=0;o<n.length;o++)if(n[o].name===t)return n[o];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const o={},c=/^([\w-]*?)([\d]+)$/;for(let d=0,p=e.length;d<p;d++){const t=e[d],n=t.name.match(c);if(n&&n.length>1){const e=n[1];let c=o[e];c||(o[e]=c=[]),c.push(t)}}const h=[];for(const d in o)h.push(AnimationClip.CreateFromMorphTargetSequence(d,o[d],t,n));return h},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(e,t,n,o,c){if(0!==n.length){const h=[],d=[];pc.flattenJSON(n,h,d,o),0!==h.length&&c.push(new e(t,h,d))}},n=[],o=e.name||"default",c=e.fps||30,h=e.blendMode;let d=e.length||-1;const p=e.hierarchy||[];for(let g=0;g<p.length;g++){const e=p[g].keys;if(e&&0!==e.length)if(e[0].morphTargets){const t={};let o;for(o=0;o<e.length;o++)if(e[o].morphTargets)for(let n=0;n<e[o].morphTargets.length;n++)t[e[o].morphTargets[n]]=-1;for(const c in t){const t=[],h=[];for(let n=0;n!==e[o].morphTargets.length;++n){const n=e[o];t.push(n.time),h.push(n.morphTarget===c?1:0)}n.push(new NumberKeyframeTrack(".morphTargetInfluence["+c+"]",t,h))}d=t.length*(c||1)}else{const o=".bones["+t[g].name+"]";addNonemptyTrack(VectorKeyframeTrack,o+".position",e,"pos",n),addNonemptyTrack(QuaternionKeyframeTrack,o+".quaternion",e,"rot",n),addNonemptyTrack(VectorKeyframeTrack,o+".scale",e,"scl",n)}}if(0===n.length)return null;const m=new AnimationClip(o,d,n,h);return m}}),Object.assign(AnimationClip.prototype,{resetDuration:function(){const e=this.tracks;let t=0;for(let n=0,o=e.length;n!==o;++n){const e=this.tracks[n];t=Math.max(t,e.times[e.times.length-1])}return this.duration=t,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new AnimationClip(this.name,this.duration,e,this.blendMode)}});const fc={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function LoadingManager(e,t,n){const o=this;let c=!1,h=0,d=0,p=void 0;const m=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){d++,!1===c&&void 0!==o.onStart&&o.onStart(e,h,d),c=!0},this.itemEnd=function(e){h++,void 0!==o.onProgress&&o.onProgress(e,h,d),h===d&&(c=!1,void 0!==o.onLoad&&o.onLoad())},this.itemError=function(e){void 0!==o.onError&&o.onError(e)},this.resolveURL=function(e){return p?p(e):e},this.setURLModifier=function(e){return p=e,this},this.addHandler=function(e,t){return m.push(e,t),this},this.removeHandler=function(e){const t=m.indexOf(e);return-1!==t&&m.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=m.length;t<n;t+=2){const n=m[t],o=m[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return o}return null}}const mc=new LoadingManager;function Loader(e){this.manager=void 0!==e?e:mc,this.crossOrigin="anonymous",this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(Loader.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise((function(o,c){n.load(e,o,t,c)}))},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const gc={};function FileLoader(e){Loader.call(this,e)}function AnimationLoader(e){Loader.call(this,e)}function CompressedTextureLoader(e){Loader.call(this,e)}function ImageLoader(e){Loader.call(this,e)}function CubeTextureLoader(e){Loader.call(this,e)}function DataTextureLoader(e){Loader.call(this,e)}function TextureLoader(e){Loader.call(this,e)}function Curve(){this.type="Curve",this.arcLengthDivisions=200}function EllipseCurve(e,t,n,o,c,h,d,p){Curve.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=o||1,this.aStartAngle=c||0,this.aEndAngle=h||2*Math.PI,this.aClockwise=d||!1,this.aRotation=p||0}function ArcCurve(e,t,n,o,c,h){EllipseCurve.call(this,e,t,n,n,o,c,h),this.type="ArcCurve"}function CubicPoly(){let e=0,t=0,n=0,o=0;function init(c,h,d,p){e=c,t=d,n=-3*c+3*h-2*d-p,o=2*c-2*h+d+p}return{initCatmullRom:function(e,t,n,o,c){init(t,n,c*(n-e),c*(o-t))},initNonuniformCatmullRom:function(e,t,n,o,c,h,d){let p=(t-e)/c-(n-e)/(c+h)+(n-t)/h,m=(n-t)/h-(o-t)/(h+d)+(o-n)/d;p*=h,m*=h,init(t,n,p,m)},calc:function(c){const h=c*c,d=h*c;return e+t*c+n*h+o*d}}}FileLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:FileLoader,load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=fc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;if(void 0!==gc[e])return void gc[e].push({onLoad:t,onProgress:n,onError:o});const d=/^data:(.*?)(;base64)?,(.*)$/,p=e.match(d);let m;if(p){const n=p[1],h=!!p[2];let d=p[3];d=decodeURIComponent(d),h&&(d=atob(d));try{let o;const h=(this.responseType||"").toLowerCase();switch(h){case"arraybuffer":case"blob":const e=new Uint8Array(d.length);for(let n=0;n<d.length;n++)e[n]=d.charCodeAt(n);o="blob"===h?new Blob([e.buffer],{type:n}):e.buffer;break;case"document":const t=new DOMParser;o=t.parseFromString(d,n);break;case"json":o=JSON.parse(d);break;default:o=d;break}setTimeout((function(){t&&t(o),c.manager.itemEnd(e)}),0)}catch(g){setTimeout((function(){o&&o(g),c.manager.itemError(e),c.manager.itemEnd(e)}),0)}}else{gc[e]=[],gc[e].push({onLoad:t,onProgress:n,onError:o}),m=new XMLHttpRequest,m.open("GET",e,!0),m.addEventListener("load",(function(t){const n=this.response,o=gc[e];if(delete gc[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),fc.add(e,n);for(let e=0,t=o.length;e<t;e++){const t=o[e];t.onLoad&&t.onLoad(n)}c.manager.itemEnd(e)}else{for(let e=0,n=o.length;e<n;e++){const n=o[e];n.onError&&n.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}}),!1),m.addEventListener("progress",(function(t){const n=gc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onProgress&&o.onProgress(t)}}),!1),m.addEventListener("error",(function(t){const n=gc[e];delete gc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}),!1),m.addEventListener("abort",(function(t){const n=gc[e];delete gc[e];for(let e=0,o=n.length;e<o;e++){const o=n[e];o.onError&&o.onError(t)}c.manager.itemError(e),c.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(m.responseType=this.responseType),void 0!==this.withCredentials&&(m.withCredentials=this.withCredentials),m.overrideMimeType&&m.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeader)m.setRequestHeader(e,this.requestHeader[e]);m.send(null)}return c.manager.itemStart(e),m},setResponseType:function(e){return this.responseType=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setMimeType:function(e){return this.mimeType=e,this}}),AnimationLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:AnimationLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const o=AnimationClip.parse(e[n]);t.push(o)}return t}}),CompressedTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:CompressedTextureLoader,load:function(e,t,n,o){const c=this,h=[],d=new CompressedTexture;d.image=h;const p=new FileLoader(this.manager);p.setPath(this.path),p.setResponseType("arraybuffer"),p.setRequestHeader(this.requestHeader);let m=0;function loadTexture(g){p.load(e[g],(function(e){const n=c.parse(e,!0);h[g]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},m+=1,6===m&&(1===n.mipmapCount&&(d.minFilter=Le),d.format=n.format,d.needsUpdate=!0,t&&t(d))}),n,o)}if(Array.isArray(e))for(let g=0,y=e.length;g<y;++g)loadTexture(g);else p.load(e,(function(e){const n=c.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){h[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)h[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),h[t].format=n.format,h[t].width=n.width,h[t].height=n.height}}else d.image.width=n.width,d.image.height=n.height,d.mipmaps=n.mipmaps;1===n.mipmapCount&&(d.minFilter=Le),d.format=n.format,d.needsUpdate=!0,t&&t(d)}),n,o);return d}}),ImageLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ImageLoader,load:function(e,t,n,o){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=fc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;const d=document.createElementNS("http://www.w3.org/1999/xhtml","img");function onImageLoad(){d.removeEventListener("load",onImageLoad,!1),d.removeEventListener("error",onImageError,!1),fc.add(e,this),t&&t(this),c.manager.itemEnd(e)}function onImageError(t){d.removeEventListener("load",onImageLoad,!1),d.removeEventListener("error",onImageError,!1),o&&o(t),c.manager.itemError(e),c.manager.itemEnd(e)}return d.addEventListener("load",onImageLoad,!1),d.addEventListener("error",onImageError,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(d.crossOrigin=this.crossOrigin),c.manager.itemStart(e),d.src=e,d}}),CubeTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:CubeTextureLoader,load:function(e,t,n,o){const c=new CubeTexture,h=new ImageLoader(this.manager);h.setCrossOrigin(this.crossOrigin),h.setPath(this.path);let d=0;function loadTexture(n){h.load(e[n],(function(e){c.images[n]=e,d++,6===d&&(c.needsUpdate=!0,t&&t(c))}),void 0,o)}for(let p=0;p<e.length;++p)loadTexture(p);return c}}),DataTextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:DataTextureLoader,load:function(e,t,n,o){const c=this,h=new DataTexture,d=new FileLoader(this.manager);return d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setPath(this.path),d.load(e,(function(e){const n=c.parse(e);n&&(void 0!==n.image?h.image=n.image:void 0!==n.data&&(h.image.width=n.width,h.image.height=n.height,h.image.data=n.data),h.wrapS=void 0!==n.wrapS?n.wrapS:be,h.wrapT=void 0!==n.wrapT?n.wrapT:be,h.magFilter=void 0!==n.magFilter?n.magFilter:Le,h.minFilter=void 0!==n.minFilter?n.minFilter:Le,h.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.format&&(h.format=n.format),void 0!==n.type&&(h.type=n.type),void 0!==n.mipmaps&&(h.mipmaps=n.mipmaps,h.minFilter=Pe),1===n.mipmapCount&&(h.minFilter=Le),h.needsUpdate=!0,t&&t(h,n))}),n,o),h}}),TextureLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:TextureLoader,load:function(e,t,n,o){const c=new Texture,h=new ImageLoader(this.manager);return h.setCrossOrigin(this.crossOrigin),h.setPath(this.path),h.load(e,(function(n){c.image=n;const o=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);c.format=o?We:qe,c.needsUpdate=!0,void 0!==t&&t(c)}),n,o),c}}),Object.assign(Curve.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e){void 0===e&&(e=5);const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e){void 0===e&&(e=5);const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,o=this.getPoint(0),c=0;t.push(0);for(let h=1;h<=e;h++)n=this.getPoint(h/e),c+=n.distanceTo(o),t.push(c),o=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let o=0;const c=n.length;let h;h=t||e*n[c-1];let d,p=0,m=c-1;while(p<=m)if(o=Math.floor(p+(m-p)/2),d=n[o]-h,d<0)p=o+1;else{if(!(d>0)){m=o;break}m=o-1}if(o=m,n[o]===h)return o/(c-1);const g=n[o],y=n[o+1],x=y-g,b=(h-g)/x,M=(o+b)/(c-1);return M},getTangent:function(e,t){const n=1e-4;let o=e-n,c=e+n;o<0&&(o=0),c>1&&(c=1);const h=this.getPoint(o),d=this.getPoint(c),p=t||(h.isVector2?new Vector2:new Vector3);return p.copy(d).sub(h).normalize(),p},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new Vector3,o=[],c=[],h=[],d=new Vector3,p=new Matrix4;for(let b=0;b<=e;b++){const t=b/e;o[b]=this.getTangentAt(t,new Vector3),o[b].normalize()}c[0]=new Vector3,h[0]=new Vector3;let m=Number.MAX_VALUE;const g=Math.abs(o[0].x),y=Math.abs(o[0].y),x=Math.abs(o[0].z);g<=m&&(m=g,n.set(1,0,0)),y<=m&&(m=y,n.set(0,1,0)),x<=m&&n.set(0,0,1),d.crossVectors(o[0],n).normalize(),c[0].crossVectors(o[0],d),h[0].crossVectors(o[0],c[0]);for(let b=1;b<=e;b++){if(c[b]=c[b-1].clone(),h[b]=h[b-1].clone(),d.crossVectors(o[b-1],o[b]),d.length()>Number.EPSILON){d.normalize();const e=Math.acos(qn.clamp(o[b-1].dot(o[b]),-1,1));c[b].applyMatrix4(p.makeRotationAxis(d,e))}h[b].crossVectors(o[b],c[b])}if(!0===t){let t=Math.acos(qn.clamp(c[0].dot(c[e]),-1,1));t/=e,o[0].dot(d.crossVectors(c[0],c[e]))>0&&(t=-t);for(let n=1;n<=e;n++)c[n].applyMatrix4(p.makeRotationAxis(o[n],t*n)),h[n].crossVectors(o[n],c[n])}return{tangents:o,normals:c,binormals:h}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),EllipseCurve.prototype=Object.create(Curve.prototype),EllipseCurve.prototype.constructor=EllipseCurve,EllipseCurve.prototype.isEllipseCurve=!0,EllipseCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=2*Math.PI;let c=this.aEndAngle-this.aStartAngle;const h=Math.abs(c)<Number.EPSILON;while(c<0)c+=o;while(c>o)c-=o;c<Number.EPSILON&&(c=h?0:o),!0!==this.aClockwise||h||(c===o?c=-o:c-=o);const d=this.aStartAngle+e*c;let p=this.aX+this.xRadius*Math.cos(d),m=this.aY+this.yRadius*Math.sin(d);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=p-this.aX,o=m-this.aY;p=n*e-o*t+this.aX,m=n*t+o*e+this.aY}return n.set(p,m)},EllipseCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},EllipseCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},EllipseCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},ArcCurve.prototype=Object.create(EllipseCurve.prototype),ArcCurve.prototype.constructor=ArcCurve,ArcCurve.prototype.isArcCurve=!0;const yc=new Vector3,vc=new CubicPoly,xc=new CubicPoly,bc=new CubicPoly;function CatmullRomCurve3(e,t,n,o){Curve.call(this),this.type="CatmullRomCurve3",this.points=e||[],this.closed=t||!1,this.curveType=n||"centripetal",this.tension=void 0!==o?o:.5}function CatmullRom(e,t,n,o,c){const h=.5*(o-t),d=.5*(c-n),p=e*e,m=e*p;return(2*n-2*o+h+d)*m+(-3*n+3*o-2*h-d)*p+h*e+n}function QuadraticBezierP0(e,t){const n=1-e;return n*n*t}function QuadraticBezierP1(e,t){return 2*(1-e)*e*t}function QuadraticBezierP2(e,t){return e*e*t}function QuadraticBezier(e,t,n,o){return QuadraticBezierP0(e,t)+QuadraticBezierP1(e,n)+QuadraticBezierP2(e,o)}function CubicBezierP0(e,t){const n=1-e;return n*n*n*t}function CubicBezierP1(e,t){const n=1-e;return 3*n*n*e*t}function CubicBezierP2(e,t){return 3*(1-e)*e*e*t}function CubicBezierP3(e,t){return e*e*e*t}function CubicBezier(e,t,n,o,c){return CubicBezierP0(e,t)+CubicBezierP1(e,n)+CubicBezierP2(e,o)+CubicBezierP3(e,c)}function CubicBezierCurve(e,t,n,o){Curve.call(this),this.type="CubicBezierCurve",this.v0=e||new Vector2,this.v1=t||new Vector2,this.v2=n||new Vector2,this.v3=o||new Vector2}function CubicBezierCurve3(e,t,n,o){Curve.call(this),this.type="CubicBezierCurve3",this.v0=e||new Vector3,this.v1=t||new Vector3,this.v2=n||new Vector3,this.v3=o||new Vector3}function LineCurve(e,t){Curve.call(this),this.type="LineCurve",this.v1=e||new Vector2,this.v2=t||new Vector2}function LineCurve3(e,t){Curve.call(this),this.type="LineCurve3",this.v1=e||new Vector3,this.v2=t||new Vector3}function QuadraticBezierCurve(e,t,n){Curve.call(this),this.type="QuadraticBezierCurve",this.v0=e||new Vector2,this.v1=t||new Vector2,this.v2=n||new Vector2}function QuadraticBezierCurve3(e,t,n){Curve.call(this),this.type="QuadraticBezierCurve3",this.v0=e||new Vector3,this.v1=t||new Vector3,this.v2=n||new Vector3}function SplineCurve(e){Curve.call(this),this.type="SplineCurve",this.points=e||[]}CatmullRomCurve3.prototype=Object.create(Curve.prototype),CatmullRomCurve3.prototype.constructor=CatmullRomCurve3,CatmullRomCurve3.prototype.isCatmullRomCurve3=!0,CatmullRomCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.points,c=o.length,h=(c-(this.closed?0:1))*e;let d,p,m=Math.floor(h),g=h-m;this.closed?m+=m>0?0:(Math.floor(Math.abs(m)/c)+1)*c:0===g&&m===c-1&&(m=c-2,g=1),this.closed||m>0?d=o[(m-1)%c]:(yc.subVectors(o[0],o[1]).add(o[0]),d=yc);const y=o[m%c],x=o[(m+1)%c];if(this.closed||m+2<c?p=o[(m+2)%c]:(yc.subVectors(o[c-1],o[c-2]).add(o[c-1]),p=yc),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(d.distanceToSquared(y),e),n=Math.pow(y.distanceToSquared(x),e),o=Math.pow(x.distanceToSquared(p),e);n<1e-4&&(n=1),t<1e-4&&(t=n),o<1e-4&&(o=n),vc.initNonuniformCatmullRom(d.x,y.x,x.x,p.x,t,n,o),xc.initNonuniformCatmullRom(d.y,y.y,x.y,p.y,t,n,o),bc.initNonuniformCatmullRom(d.z,y.z,x.z,p.z,t,n,o)}else"catmullrom"===this.curveType&&(vc.initCatmullRom(d.x,y.x,x.x,p.x,this.tension),xc.initCatmullRom(d.y,y.y,x.y,p.y,this.tension),bc.initCatmullRom(d.z,y.z,x.z,p.z,this.tension));return n.set(vc.calc(g),xc.calc(g),bc.calc(g)),n},CatmullRomCurve3.prototype.copy=function(e){Curve.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},CatmullRomCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},CatmullRomCurve3.prototype.fromJSON=function(e){Curve.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector3).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},CubicBezierCurve.prototype=Object.create(Curve.prototype),CubicBezierCurve.prototype.constructor=CubicBezierCurve,CubicBezierCurve.prototype.isCubicBezierCurve=!0,CubicBezierCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.v0,c=this.v1,h=this.v2,d=this.v3;return n.set(CubicBezier(e,o.x,c.x,h.x,d.x),CubicBezier(e,o.y,c.y,h.y,d.y)),n},CubicBezierCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},CubicBezierCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},CubicBezierCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},CubicBezierCurve3.prototype=Object.create(Curve.prototype),CubicBezierCurve3.prototype.constructor=CubicBezierCurve3,CubicBezierCurve3.prototype.isCubicBezierCurve3=!0,CubicBezierCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.v0,c=this.v1,h=this.v2,d=this.v3;return n.set(CubicBezier(e,o.x,c.x,h.x,d.x),CubicBezier(e,o.y,c.y,h.y,d.y),CubicBezier(e,o.z,c.z,h.z,d.z)),n},CubicBezierCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},CubicBezierCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},CubicBezierCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},LineCurve.prototype=Object.create(Curve.prototype),LineCurve.prototype.constructor=LineCurve,LineCurve.prototype.isLineCurve=!0,LineCurve.prototype.getPoint=function(e,t){const n=t||new Vector2;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},LineCurve.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},LineCurve.prototype.getTangent=function(e,t){const n=t||new Vector2;return n.copy(this.v2).sub(this.v1).normalize(),n},LineCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},LineCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},LineCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},LineCurve3.prototype=Object.create(Curve.prototype),LineCurve3.prototype.constructor=LineCurve3,LineCurve3.prototype.isLineCurve3=!0,LineCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n},LineCurve3.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},LineCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},LineCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},LineCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},QuadraticBezierCurve.prototype=Object.create(Curve.prototype),QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve,QuadraticBezierCurve.prototype.isQuadraticBezierCurve=!0,QuadraticBezierCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.v0,c=this.v1,h=this.v2;return n.set(QuadraticBezier(e,o.x,c.x,h.x),QuadraticBezier(e,o.y,c.y,h.y)),n},QuadraticBezierCurve.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},QuadraticBezierCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},QuadraticBezierCurve.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},QuadraticBezierCurve3.prototype=Object.create(Curve.prototype),QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3,QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=!0,QuadraticBezierCurve3.prototype.getPoint=function(e,t){const n=t||new Vector3,o=this.v0,c=this.v1,h=this.v2;return n.set(QuadraticBezier(e,o.x,c.x,h.x),QuadraticBezier(e,o.y,c.y,h.y),QuadraticBezier(e,o.z,c.z,h.z)),n},QuadraticBezierCurve3.prototype.copy=function(e){return Curve.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},QuadraticBezierCurve3.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},QuadraticBezierCurve3.prototype.fromJSON=function(e){return Curve.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},SplineCurve.prototype=Object.create(Curve.prototype),SplineCurve.prototype.constructor=SplineCurve,SplineCurve.prototype.isSplineCurve=!0,SplineCurve.prototype.getPoint=function(e,t){const n=t||new Vector2,o=this.points,c=(o.length-1)*e,h=Math.floor(c),d=c-h,p=o[0===h?h:h-1],m=o[h],g=o[h>o.length-2?o.length-1:h+1],y=o[h>o.length-3?o.length-1:h+2];return n.set(CatmullRom(d,p.x,m.x,g.x,y.x),CatmullRom(d,p.y,m.y,g.y,y.y)),n},SplineCurve.prototype.copy=function(e){Curve.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this},SplineCurve.prototype.toJSON=function(){const e=Curve.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e},SplineCurve.prototype.fromJSON=function(e){Curve.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new Vector2).fromArray(n))}return this};var Mc=Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});function CurvePath(){Curve.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function Path(e){CurvePath.call(this),this.type="Path",this.currentPoint=new Vector2,e&&this.setFromPoints(e)}function Shape(e){Path.call(this,e),this.uuid=qn.generateUUID(),this.type="Shape",this.holes=[]}function Light(e,t){Object3D.call(this),this.type="Light",this.color=new Color(e),this.intensity=void 0!==t?t:1,this.receiveShadow=void 0}function HemisphereLight(e,t,n){Light.call(this,e,n),this.type="HemisphereLight",this.castShadow=void 0,this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.groundColor=new Color(t)}function LightShadow(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,.5,500))}function SpotLight(e,t,n,o,c,h){Light.call(this,e,t),this.type="SpotLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(e){this.intensity=e/Math.PI}}),this.distance=void 0!==n?n:0,this.angle=void 0!==o?o:Math.PI/3,this.penumbra=void 0!==c?c:0,this.decay=void 0!==h?h:1,this.shadow=new SpotLightShadow}function PointLightShadow(){LightShadow.call(this,new PerspectiveCamera(90,1,.5,500)),this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}function PointLight(e,t,n,o){Light.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(e){this.intensity=e/(4*Math.PI)}}),this.distance=void 0!==n?n:0,this.decay=void 0!==o?o:1,this.shadow=new PointLightShadow}function OrthographicCamera(e,t,n,o,c,h){Camera.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=void 0!==e?e:-1,this.right=void 0!==t?t:1,this.top=void 0!==n?n:1,this.bottom=void 0!==o?o:-1,this.near=void 0!==c?c:.1,this.far=void 0!==h?h:2e3,this.updateProjectionMatrix()}function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,.5,500))}function DirectionalLight(e,t){Light.call(this,e,t),this.type="DirectionalLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}function AmbientLight(e,t){Light.call(this,e,t),this.type="AmbientLight",this.castShadow=void 0}function RectAreaLight(e,t,n,o){Light.call(this,e,t),this.type="RectAreaLight",this.width=void 0!==n?n:10,this.height=void 0!==o?o:10}CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new LineCurve(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let o=0;while(o<n.length){if(n[o]>=t){const e=n[o]-t,c=this.curves[o],h=c.getLength(),d=0===h?0:1-e/h;return c.getPointAt(d)}o++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,o=this.curves.length;n<o;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e){void 0===e&&(e=40);const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e){e=e||12;const t=[];let n;for(let o=0,c=this.curves;o<c.length;o++){const h=c[o],d=h&&h.isEllipseCurve?2*e:h&&(h.isLineCurve||h.isLineCurve3)?1:h&&h.isSplineCurve?e*h.points.length:e,p=h.getPoints(d);for(let e=0;e<p.length;e++){const o=p[e];n&&n.equals(o)||(t.push(o),n=o)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){Curve.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=Curve.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e},fromJSON:function(e){Curve.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new Mc[n.type]).fromJSON(n))}return this}}),Path.prototype=Object.assign(Object.create(CurvePath.prototype),{constructor:Path,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new LineCurve(this.currentPoint.clone(),new Vector2(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,o){const c=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,o));return this.curves.push(c),this.currentPoint.set(n,o),this},bezierCurveTo:function(e,t,n,o,c,h){const d=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(n,o),new Vector2(c,h));return this.curves.push(d),this.currentPoint.set(c,h),this},splineThru:function(e){const t=[this.currentPoint.clone()].concat(e),n=new SplineCurve(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,o,c,h){const d=this.currentPoint.x,p=this.currentPoint.y;return this.absarc(e+d,t+p,n,o,c,h),this},absarc:function(e,t,n,o,c,h){return this.absellipse(e,t,n,n,o,c,h),this},ellipse:function(e,t,n,o,c,h,d,p){const m=this.currentPoint.x,g=this.currentPoint.y;return this.absellipse(e+m,t+g,n,o,c,h,d,p),this},absellipse:function(e,t,n,o,c,h,d,p){const m=new EllipseCurve(e,t,n,o,c,h,d,p);if(this.curves.length>0){const e=m.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(m);const g=m.getPoint(1);return this.currentPoint.copy(g),this},copy:function(e){return CurvePath.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=CurvePath.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return CurvePath.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),Shape.prototype=Object.assign(Object.create(Path.prototype),{constructor:Shape,getPointsHoles:function(e){const t=[];for(let n=0,o=this.holes.length;n<o;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){Path.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this},toJSON:function(){const e=Path.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e},fromJSON:function(e){Path.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new Path).fromJSON(n))}return this}}),Light.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Light,isLight:!0,copy:function(e){return Object3D.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}),HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(LightShadow.prototype,{_projScreenMatrix:new Matrix4,_lightPositionWorld:new Vector3,_lookTarget:new Vector3,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,o=this._projScreenMatrix,c=this._lookTarget,h=this._lightPositionWorld;h.setFromMatrixPosition(e.matrixWorld),t.position.copy(h),c.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(c),t.updateMatrixWorld(),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=2*qn.RAD2DEG*e.angle,o=this.mapSize.width/this.mapSize.height,c=e.distance||t.far;n===t.fov&&o===t.aspect&&c===t.far||(t.fov=n,t.aspect=o,t.far=c,t.updateProjectionMatrix()),LightShadow.prototype.updateMatrices.call(this,e)}}),SpotLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:SpotLight,isSpotLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),PointLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:PointLightShadow,isPointLightShadow:!0,updateMatrices:function(e,t){void 0===t&&(t=0);const n=this.camera,o=this.matrix,c=this._lightPositionWorld,h=this._lookTarget,d=this._projScreenMatrix;c.setFromMatrixPosition(e.matrixWorld),n.position.copy(c),h.copy(n.position),h.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(h),n.updateMatrixWorld(),o.makeTranslation(-c.x,-c.y,-c.z),d.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(d)}}),PointLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:PointLight,isPointLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:!0,copy:function(e,t){return Camera.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,o,c,h){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=o,this.view.width=c,this.view.height=h,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,o=(this.top+this.bottom)/2;let c=n-e,h=n+e,d=o+t,p=o-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;c+=e*this.view.offsetX,h=c+e*this.view.width,d-=t*this.view.offsetY,p=d-t*this.view.height}this.projectionMatrix.makeOrthographic(c,h,d,p,this.near,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){const t=Object3D.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}),DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow,isDirectionalLightShadow:!0,updateMatrices:function(e){LightShadow.prototype.updateMatrices.call(this,e)}}),DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:AmbientLight,isAmbientLight:!0}),RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=Light.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}});class SphericalHarmonics3{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Vector3)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,o=e.y,c=e.z,h=this.coefficients;return t.copy(h[0]).multiplyScalar(.282095),t.addScaledVector(h[1],.488603*o),t.addScaledVector(h[2],.488603*c),t.addScaledVector(h[3],.488603*n),t.addScaledVector(h[4],n*o*1.092548),t.addScaledVector(h[5],o*c*1.092548),t.addScaledVector(h[6],.315392*(3*c*c-1)),t.addScaledVector(h[7],n*c*1.092548),t.addScaledVector(h[8],.546274*(n*n-o*o)),t}getIrradianceAt(e,t){const n=e.x,o=e.y,c=e.z,h=this.coefficients;return t.copy(h[0]).multiplyScalar(.886227),t.addScaledVector(h[1],1.023328*o),t.addScaledVector(h[2],1.023328*c),t.addScaledVector(h[3],1.023328*n),t.addScaledVector(h[4],.858086*n*o),t.addScaledVector(h[5],.858086*o*c),t.addScaledVector(h[6],.743125*c*c-.247708),t.addScaledVector(h[7],.858086*n*c),t.addScaledVector(h[8],.429043*(n*n-o*o)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t){void 0===t&&(t=0);const n=this.coefficients;for(let o=0;o<9;o++)n[o].fromArray(e,t+3*o);return this}toArray(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);const n=this.coefficients;for(let o=0;o<9;o++)n[o].toArray(e,t+3*o);return e}static getBasisAt(e,t){const n=e.x,o=e.y,c=e.z;t[0]=.282095,t[1]=.488603*o,t[2]=.488603*c,t[3]=.488603*n,t[4]=1.092548*n*o,t[5]=1.092548*o*c,t[6]=.315392*(3*c*c-1),t[7]=1.092548*n*c,t[8]=.546274*(n*n-o*o)}}function LightProbe(e,t){Light.call(this,void 0,t),this.type="LightProbe",this.sh=void 0!==e?e:new SphericalHarmonics3}function MaterialLoader(e){Loader.call(this,e),this.textures={}}LightProbe.prototype=Object.assign(Object.create(Light.prototype),{constructor:LightProbe,isLightProbe:!0,copy:function(e){return Light.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=Light.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),MaterialLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:MaterialLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t=this.textures;function getTexture(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const n=new dc[e.type];if(void 0!==e.uuid&&(n.uuid=e.uuid),void 0!==e.name&&(n.name=e.name),void 0!==e.color&&n.color.setHex(e.color),void 0!==e.roughness&&(n.roughness=e.roughness),void 0!==e.metalness&&(n.metalness=e.metalness),void 0!==e.sheen&&(n.sheen=(new Color).setHex(e.sheen)),void 0!==e.emissive&&n.emissive.setHex(e.emissive),void 0!==e.specular&&n.specular.setHex(e.specular),void 0!==e.shininess&&(n.shininess=e.shininess),void 0!==e.clearcoat&&(n.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(n.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(n.fog=e.fog),void 0!==e.flatShading&&(n.flatShading=e.flatShading),void 0!==e.blending&&(n.blending=e.blending),void 0!==e.combine&&(n.combine=e.combine),void 0!==e.side&&(n.side=e.side),void 0!==e.opacity&&(n.opacity=e.opacity),void 0!==e.transparent&&(n.transparent=e.transparent),void 0!==e.alphaTest&&(n.alphaTest=e.alphaTest),void 0!==e.depthTest&&(n.depthTest=e.depthTest),void 0!==e.depthWrite&&(n.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(n.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(n.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(n.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(n.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(n.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(n.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(n.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(n.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(n.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(n.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(n.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(n.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(n.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(n.rotation=e.rotation),1!==e.linewidth&&(n.linewidth=e.linewidth),void 0!==e.dashSize&&(n.dashSize=e.dashSize),void 0!==e.gapSize&&(n.gapSize=e.gapSize),void 0!==e.scale&&(n.scale=e.scale),void 0!==e.polygonOffset&&(n.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(n.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(n.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(n.skinning=e.skinning),void 0!==e.morphTargets&&(n.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(n.morphNormals=e.morphNormals),void 0!==e.dithering&&(n.dithering=e.dithering),void 0!==e.vertexTangents&&(n.vertexTangents=e.vertexTangents),void 0!==e.visible&&(n.visible=e.visible),void 0!==e.toneMapped&&(n.toneMapped=e.toneMapped),void 0!==e.userData&&(n.userData=e.userData),void 0!==e.vertexColors&&("number"===typeof e.vertexColors?n.vertexColors=e.vertexColors>0:n.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const o in e.uniforms){const t=e.uniforms[o];switch(n.uniforms[o]={},t.type){case"t":n.uniforms[o].value=getTexture(t.value);break;case"c":n.uniforms[o].value=(new Color).setHex(t.value);break;case"v2":n.uniforms[o].value=(new Vector2).fromArray(t.value);break;case"v3":n.uniforms[o].value=(new Vector3).fromArray(t.value);break;case"v4":n.uniforms[o].value=(new Vector4).fromArray(t.value);break;case"m3":n.uniforms[o].value=(new Matrix3).fromArray(t.value);break;case"m4":n.uniforms[o].value=(new Matrix4).fromArray(t.value);break;default:n.uniforms[o].value=t.value}}if(void 0!==e.defines&&(n.defines=e.defines),void 0!==e.vertexShader&&(n.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(n.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const o in e.extensions)n.extensions[o]=e.extensions[o];if(void 0!==e.shading&&(n.flatShading=1===e.shading),void 0!==e.size&&(n.size=e.size),void 0!==e.sizeAttenuation&&(n.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(n.map=getTexture(e.map)),void 0!==e.matcap&&(n.matcap=getTexture(e.matcap)),void 0!==e.alphaMap&&(n.alphaMap=getTexture(e.alphaMap)),void 0!==e.bumpMap&&(n.bumpMap=getTexture(e.bumpMap)),void 0!==e.bumpScale&&(n.bumpScale=e.bumpScale),void 0!==e.normalMap&&(n.normalMap=getTexture(e.normalMap)),void 0!==e.normalMapType&&(n.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),n.normalScale=(new Vector2).fromArray(t)}return void 0!==e.displacementMap&&(n.displacementMap=getTexture(e.displacementMap)),void 0!==e.displacementScale&&(n.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(n.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(n.roughnessMap=getTexture(e.roughnessMap)),void 0!==e.metalnessMap&&(n.metalnessMap=getTexture(e.metalnessMap)),void 0!==e.emissiveMap&&(n.emissiveMap=getTexture(e.emissiveMap)),void 0!==e.emissiveIntensity&&(n.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(n.specularMap=getTexture(e.specularMap)),void 0!==e.envMap&&(n.envMap=getTexture(e.envMap)),void 0!==e.envMapIntensity&&(n.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(n.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(n.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(n.lightMap=getTexture(e.lightMap)),void 0!==e.lightMapIntensity&&(n.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(n.aoMap=getTexture(e.aoMap)),void 0!==e.aoMapIntensity&&(n.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(n.gradientMap=getTexture(e.gradientMap)),void 0!==e.clearcoatMap&&(n.clearcoatMap=getTexture(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=getTexture(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(n.clearcoatNormalMap=getTexture(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(n.clearcoatNormalScale=(new Vector2).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(n.transmission=e.transmission),void 0!==e.transmissionMap&&(n.transmissionMap=getTexture(e.transmissionMap)),n},setTextures:function(e){return this.textures=e,this}});const _c={decodeText:function(e){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let o=0,c=e.length;o<c;o++)t+=String.fromCharCode(e[o]);try{return decodeURIComponent(escape(t))}catch(n){return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}};function InstancedBufferGeometry(){BufferGeometry.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function InstancedBufferAttribute(e,t,n,o){"number"===typeof n&&(o=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),BufferAttribute.call(this,e,t,n),this.meshPerAttribute=o||1}function BufferGeometryLoader(e){Loader.call(this,e)}InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:!0,copy:function(e){return BufferGeometry.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){const e=BufferGeometry.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:!0,copy:function(e){return BufferAttribute.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=BufferAttribute.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),BufferGeometryLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:BufferGeometryLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.load(e,(function(n){try{t(c.parse(JSON.parse(n)))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)},parse:function(e){const t={},n={};function getInterleavedBuffer(e,n){if(void 0!==t[n])return t[n];const o=e.interleavedBuffers,c=o[n],h=getArrayBuffer(e,c.buffer),d=new wc[c.type](h),p=new InterleavedBuffer(d,c.stride);return p.uuid=c.uuid,t[n]=p,p}function getArrayBuffer(e,t){if(void 0!==n[t])return n[t];const o=e.arrayBuffers,c=o[t],h=new Uint32Array(c).buffer;return n[t]=h,h}const o=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,c=e.data.index;if(void 0!==c){const e=new wc[c.type](c.array);o.setIndex(new BufferAttribute(e,1))}const h=e.data.attributes;for(const y in h){const t=h[y];let n;if(t.isInterleavedBufferAttribute){const o=getInterleavedBuffer(e.data,t.data);n=new InterleavedBufferAttribute(o,t.itemSize,t.offset,t.normalized)}else{const e=new wc[t.type](t.array),o=t.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;n=new o(e,t.itemSize,t.normalized)}void 0!==t.name&&(n.name=t.name),o.setAttribute(y,n)}const d=e.data.morphAttributes;if(d)for(const y in d){const t=d[y],n=[];for(let o=0,c=t.length;o<c;o++){const c=t[o];let h;if(c.isInterleavedBufferAttribute){const t=getInterleavedBuffer(e.data,c.data);h=new InterleavedBufferAttribute(t,c.itemSize,c.offset,c.normalized)}else{const e=new wc[c.type](c.array);h=new BufferAttribute(e,c.itemSize,c.normalized)}void 0!==c.name&&(h.name=c.name),n.push(h)}o.morphAttributes[y]=n}const p=e.data.morphTargetsRelative;p&&(o.morphTargetsRelative=!0);const m=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==m)for(let y=0,x=m.length;y!==x;++y){const e=m[y];o.addGroup(e.start,e.count,e.materialIndex)}const g=e.data.boundingSphere;if(void 0!==g){const e=new Vector3;void 0!==g.center&&e.fromArray(g.center),o.boundingSphere=new Sphere(e,g.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}});const wc={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!==typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function ObjectLoader(e){Loader.call(this,e)}ObjectLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ObjectLoader,load:function(e,t,n,o){const c=this,h=""===this.path?_c.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||h;const d=new FileLoader(c.manager);d.setPath(this.path),d.setRequestHeader(this.requestHeader),d.load(e,(function(n){let h=null;try{h=JSON.parse(n)}catch(p){return void 0!==o&&o(p),void console.error("THREE:ObjectLoader: Can't parse "+e+".",p.message)}const d=h.metadata;void 0!==d&&void 0!==d.type&&"geometry"!==d.type.toLowerCase()?c.parse(h,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,o)},parse:function(e,t){const n=this.parseShape(e.shapes),o=this.parseGeometries(e.geometries,n),c=this.parseImages(e.images,(function(){void 0!==t&&t(p)})),h=this.parseTextures(e.textures,c),d=this.parseMaterials(e.materials,h),p=this.parseObject(e.object,o,d);return e.animations&&(p.animations=this.parseAnimations(e.animations)),void 0!==e.images&&0!==e.images.length||void 0!==t&&t(p),p},parseShape:function(e){const t={};if(void 0!==e)for(let n=0,o=e.length;n<o;n++){const o=(new Shape).fromJSON(e[n]);t[o.uuid]=o}return t},parseGeometries:function(e,t){const n={};let o;if(void 0!==e){const c=new BufferGeometryLoader;for(let h=0,d=e.length;h<d;h++){let d;const p=e[h];switch(p.type){case"PlaneGeometry":case"PlaneBufferGeometry":d=new hc[p.type](p.width,p.height,p.widthSegments,p.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":d=new hc[p.type](p.width,p.height,p.depth,p.widthSegments,p.heightSegments,p.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":d=new hc[p.type](p.radius,p.segments,p.thetaStart,p.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":d=new hc[p.type](p.radiusTop,p.radiusBottom,p.height,p.radialSegments,p.heightSegments,p.openEnded,p.thetaStart,p.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":d=new hc[p.type](p.radius,p.height,p.radialSegments,p.heightSegments,p.openEnded,p.thetaStart,p.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":d=new hc[p.type](p.radius,p.widthSegments,p.heightSegments,p.phiStart,p.phiLength,p.thetaStart,p.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":d=new hc[p.type](p.radius,p.detail);break;case"RingGeometry":case"RingBufferGeometry":d=new hc[p.type](p.innerRadius,p.outerRadius,p.thetaSegments,p.phiSegments,p.thetaStart,p.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":d=new hc[p.type](p.radius,p.tube,p.radialSegments,p.tubularSegments,p.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":d=new hc[p.type](p.radius,p.tube,p.tubularSegments,p.radialSegments,p.p,p.q);break;case"TubeGeometry":case"TubeBufferGeometry":d=new hc[p.type]((new Mc[p.path.type]).fromJSON(p.path),p.tubularSegments,p.radius,p.radialSegments,p.closed);break;case"LatheGeometry":case"LatheBufferGeometry":d=new hc[p.type](p.points,p.segments,p.phiStart,p.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":d=new hc[p.type](p.vertices,p.indices,p.radius,p.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":o=[];for(let n=0,c=p.shapes.length;n<c;n++){const e=t[p.shapes[n]];o.push(e)}d=new hc[p.type](o,p.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":o=[];for(let n=0,c=p.shapes.length;n<c;n++){const e=t[p.shapes[n]];o.push(e)}const e=p.options.extrudePath;void 0!==e&&(p.options.extrudePath=(new Mc[e.type]).fromJSON(e)),d=new hc[p.type](o,p.options);break;case"BufferGeometry":case"InstancedBufferGeometry":d=c.parse(p);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+p.type+'"');continue}d.uuid=p.uuid,void 0!==p.name&&(d.name=p.name),!0===d.isBufferGeometry&&void 0!==p.userData&&(d.userData=p.userData),n[p.uuid]=d}}return n},parseMaterials:function(e,t){const n={},o={};if(void 0!==e){const c=new MaterialLoader;c.setTextures(t);for(let t=0,h=e.length;t<h;t++){const h=e[t];if("MultiMaterial"===h.type){const e=[];for(let t=0;t<h.materials.length;t++){const o=h.materials[t];void 0===n[o.uuid]&&(n[o.uuid]=c.parse(o)),e.push(n[o.uuid])}o[h.uuid]=e}else void 0===n[h.uuid]&&(n[h.uuid]=c.parse(h)),o[h.uuid]=n[h.uuid]}}return o},parseAnimations:function(e){const t=[];for(let n=0;n<e.length;n++){const o=e[n],c=AnimationClip.parse(o);void 0!==o.uuid&&(c.uuid=o.uuid),t.push(c)}return t},parseImages:function(e,t){const n=this,o={};let c;function loadImage(e){return n.manager.itemStart(e),c.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}if(void 0!==e&&e.length>0){const h=new LoadingManager(t);c=new ImageLoader(h),c.setCrossOrigin(this.crossOrigin);for(let t=0,c=e.length;t<c;t++){const c=e[t],h=c.url;if(Array.isArray(h)){o[c.uuid]=[];for(let e=0,t=h.length;e<t;e++){const t=h[e],d=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t;o[c.uuid].push(loadImage(d))}}else{const e=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)?c.url:n.resourcePath+c.url;o[c.uuid]=loadImage(e)}}}return o},parseTextures:function(e,t){function parseConstant(e,t){return"number"===typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const n={};if(void 0!==e)for(let o=0,c=e.length;o<c;o++){const c=e[o];let h;void 0===c.image&&console.warn('THREE.ObjectLoader: No "image" specified for',c.uuid),void 0===t[c.image]&&console.warn("THREE.ObjectLoader: Undefined image",c.image),h=Array.isArray(t[c.image])?new CubeTexture(t[c.image]):new Texture(t[c.image]),h.needsUpdate=!0,h.uuid=c.uuid,void 0!==c.name&&(h.name=c.name),void 0!==c.mapping&&(h.mapping=parseConstant(c.mapping,Sc)),void 0!==c.offset&&h.offset.fromArray(c.offset),void 0!==c.repeat&&h.repeat.fromArray(c.repeat),void 0!==c.center&&h.center.fromArray(c.center),void 0!==c.rotation&&(h.rotation=c.rotation),void 0!==c.wrap&&(h.wrapS=parseConstant(c.wrap[0],Tc),h.wrapT=parseConstant(c.wrap[1],Tc)),void 0!==c.format&&(h.format=c.format),void 0!==c.type&&(h.type=c.type),void 0!==c.encoding&&(h.encoding=c.encoding),void 0!==c.minFilter&&(h.minFilter=parseConstant(c.minFilter,Ec)),void 0!==c.magFilter&&(h.magFilter=parseConstant(c.magFilter,Ec)),void 0!==c.anisotropy&&(h.anisotropy=c.anisotropy),void 0!==c.flipY&&(h.flipY=c.flipY),void 0!==c.premultiplyAlpha&&(h.premultiplyAlpha=c.premultiplyAlpha),void 0!==c.unpackAlignment&&(h.unpackAlignment=c.unpackAlignment),n[c.uuid]=h}return n},parseObject:function(e,t,n){let o,c,h;function getGeometry(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function getMaterial(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let o=0,c=e.length;o<c;o++){const c=e[o];void 0===n[c]&&console.warn("THREE.ObjectLoader: Undefined material",c),t.push(n[c])}return t}return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),n[e]}}switch(e.type){case"Scene":o=new Scene,void 0!==e.background&&Number.isInteger(e.background)&&(o.background=new Color(e.background)),void 0!==e.fog&&("Fog"===e.fog.type?o.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(o.fog=new FogExp2(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":o=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(o.focus=e.focus),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.filmGauge&&(o.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(o.filmOffset=e.filmOffset),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":o=new DirectionalLight(e.color,e.intensity);break;case"PointLight":o=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=(new LightProbe).fromJSON(e);break;case"SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case"Mesh":c=getGeometry(e.geometry),h=getMaterial(e.material),o=new Mesh(c,h);break;case"InstancedMesh":c=getGeometry(e.geometry),h=getMaterial(e.material);const t=e.count,n=e.instanceMatrix;o=new InstancedMesh(c,h,t),o.instanceMatrix=new BufferAttribute(new Float32Array(n.array),16);break;case"LOD":o=new LOD;break;case"Line":o=new Line(getGeometry(e.geometry),getMaterial(e.material),e.mode);break;case"LineLoop":o=new LineLoop(getGeometry(e.geometry),getMaterial(e.material));break;case"LineSegments":o=new LineSegments(getGeometry(e.geometry),getMaterial(e.material));break;case"PointCloud":case"Points":o=new Points(getGeometry(e.geometry),getMaterial(e.material));break;case"Sprite":o=new Sprite(getMaterial(e.material));break;case"Group":o=new Group;break;default:o=new Object3D}if(o.uuid=e.uuid,void 0!==e.name&&(o.name=e.name),void 0!==e.matrix?(o.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(void 0!==e.position&&o.position.fromArray(e.position),void 0!==e.rotation&&o.rotation.fromArray(e.rotation),void 0!==e.quaternion&&o.quaternion.fromArray(e.quaternion),void 0!==e.scale&&o.scale.fromArray(e.scale)),void 0!==e.castShadow&&(o.castShadow=e.castShadow),void 0!==e.receiveShadow&&(o.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(o.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(o.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(o.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&o.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(o.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(o.visible=e.visible),void 0!==e.frustumCulled&&(o.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(o.renderOrder=e.renderOrder),void 0!==e.userData&&(o.userData=e.userData),void 0!==e.layers&&(o.layers.mask=e.layers),void 0!==e.children){const c=e.children;for(let e=0;e<c.length;e++)o.add(this.parseObject(c[e],t,n))}if("LOD"===e.type){void 0!==e.autoUpdate&&(o.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e],c=o.getObjectByProperty("uuid",n.object);void 0!==c&&o.addLevel(c,n.distance)}}return o}});const Sc={UVMapping:de,CubeReflectionMapping:pe,CubeRefractionMapping:fe,EquirectangularReflectionMapping:me,EquirectangularRefractionMapping:ge,CubeUVReflectionMapping:ye,CubeUVRefractionMapping:ve},Tc={RepeatWrapping:xe,ClampToEdgeWrapping:be,MirroredRepeatWrapping:Me},Ec={NearestFilter:_e,NearestMipmapNearestFilter:we,NearestMipmapLinearFilter:Te,LinearFilter:Le,LinearMipmapNearestFilter:Ae,LinearMipmapLinearFilter:Pe};function ImageBitmapLoader(e){"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),Loader.call(this,e),this.options={premultiplyAlpha:"none"}}function ShapePath(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}function Font(e){this.type="Font",this.data=e}function createPaths(e,t,n){const o=Array.from?Array.from(e):String(e).split(""),c=t/n.resolution,h=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*c,d=[];let p=0,m=0;for(let g=0;g<o.length;g++){const e=o[g];if("\n"===e)p=0,m-=h;else{const t=createPath(e,c,p,m,n);p+=t.offsetX,d.push(t.path)}}return d}function createPath(e,t,n,o,c){const h=c.glyphs[e]||c.glyphs["?"];if(!h)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+c.familyName+".");const d=new ShapePath;let p,m,g,y,x,b,M,_;if(h.o){const e=h._cachedOutline||(h._cachedOutline=h.o.split(" "));for(let c=0,h=e.length;c<h;){const h=e[c++];switch(h){case"m":p=e[c++]*t+n,m=e[c++]*t+o,d.moveTo(p,m);break;case"l":p=e[c++]*t+n,m=e[c++]*t+o,d.lineTo(p,m);break;case"q":g=e[c++]*t+n,y=e[c++]*t+o,x=e[c++]*t+n,b=e[c++]*t+o,d.quadraticCurveTo(x,b,g,y);break;case"b":g=e[c++]*t+n,y=e[c++]*t+o,x=e[c++]*t+n,b=e[c++]*t+o,M=e[c++]*t+n,_=e[c++]*t+o,d.bezierCurveTo(x,b,M,_,g,y);break}}}return{offsetX:h.ha*t,path:d}}function FontLoader(e){Loader.call(this,e)}let Lc;ImageBitmapLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:ImageBitmapLoader,isImageBitmapLoader:!0,setOptions:function setOptions(e){return this.options=e,this},load:function(e,t,n,o){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,h=fc.get(e);if(void 0!==h)return c.manager.itemStart(e),setTimeout((function(){t&&t(h),c.manager.itemEnd(e)}),0),h;fetch(e).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,c.options)})).then((function(n){fc.add(e,n),t&&t(n),c.manager.itemEnd(e)})).catch((function(t){o&&o(t),c.manager.itemError(e),c.manager.itemEnd(e)})),c.manager.itemStart(e)}}),Object.assign(ShapePath.prototype,{moveTo:function(e,t){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,o){return this.currentPath.quadraticCurveTo(e,t,n,o),this},bezierCurveTo:function(e,t,n,o,c,h){return this.currentPath.bezierCurveTo(e,t,n,o,c,h),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function toShapesNoHoles(e){const t=[];for(let n=0,o=e.length;n<o;n++){const o=e[n],c=new Shape;c.curves=o.curves,t.push(c)}return t}function isPointInsidePolygon(e,t){const n=t.length;let o=!1;for(let c=n-1,h=0;h<n;c=h++){let n=t[c],d=t[h],p=d.x-n.x,m=d.y-n.y;if(Math.abs(m)>Number.EPSILON){if(m<0&&(n=t[h],p=-p,d=t[c],m=-m),e.y<n.y||e.y>d.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=m*(e.x-n.x)-p*(e.y-n.y);if(0===t)return!0;if(t<0)continue;o=!o}}else{if(e.y!==n.y)continue;if(d.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=d.x)return!0}}return o}const n=lc.isClockWise,o=this.subPaths;if(0===o.length)return[];if(!0===t)return toShapesNoHoles(o);let c,h,d;const p=[];if(1===o.length)return h=o[0],d=new Shape,d.curves=h.curves,p.push(d),p;let m=!n(o[0].getPoints());m=e?!m:m;const g=[],y=[];let x,b,M=[],_=0;y[_]=void 0,M[_]=[];for(let w=0,S=o.length;w<S;w++)h=o[w],x=h.getPoints(),c=n(x),c=e?!c:c,c?(!m&&y[_]&&_++,y[_]={s:new Shape,p:x},y[_].s.curves=h.curves,m&&_++,M[_]=[]):M[_].push({h:h,p:x[0]});if(!y[0])return toShapesNoHoles(o);if(y.length>1){let e=!1;const t=[];for(let n=0,o=y.length;n<o;n++)g[n]=[];for(let n=0,o=y.length;n<o;n++){const o=M[n];for(let c=0;c<o.length;c++){const h=o[c];let d=!0;for(let o=0;o<y.length;o++)isPointInsidePolygon(h.p,y[o].p)&&(n!==o&&t.push({froms:n,tos:o,hole:c}),d?(d=!1,g[o].push(h)):e=!0);d&&g[n].push(h)}}t.length>0&&(e||(M=g))}for(let w=0,S=y.length;w<S;w++){d=y[w].s,p.push(d),b=M[w];for(let e=0,t=b.length;e<t;e++)d.holes.push(b[e].h)}return p}}),Object.assign(Font.prototype,{isFont:!0,generateShapes:function(e,t){void 0===t&&(t=100);const n=[],o=createPaths(e,t,this.data);for(let c=0,h=o.length;c<h;c++)Array.prototype.push.apply(n,o[c].toShapes());return n}}),FontLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:FontLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(this.manager);h.setPath(this.path),h.setRequestHeader(this.requestHeader),h.load(e,(function(e){let n;try{n=JSON.parse(e)}catch(h){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(e.substring(65,e.length-2))}const o=c.parse(n);t&&t(o)}),n,o)},parse:function(e){return new Font(e)}});const Ac={getContext:function(){return void 0===Lc&&(Lc=new(window.AudioContext||window.webkitAudioContext)),Lc},setContext:function(e){Lc=e}};function AudioLoader(e){Loader.call(this,e)}function HemisphereLightProbe(e,t,n){LightProbe.call(this,void 0,n);const o=(new Color).set(e),c=(new Color).set(t),h=new Vector3(o.r,o.g,o.b),d=new Vector3(c.r,c.g,c.b),p=Math.sqrt(Math.PI),m=p*Math.sqrt(.75);this.sh.coefficients[0].copy(h).add(d).multiplyScalar(p),this.sh.coefficients[1].copy(h).sub(d).multiplyScalar(m)}function AmbientLightProbe(e,t){LightProbe.call(this,void 0,t);const n=(new Color).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}AudioLoader.prototype=Object.assign(Object.create(Loader.prototype),{constructor:AudioLoader,load:function(e,t,n,o){const c=this,h=new FileLoader(c.manager);h.setResponseType("arraybuffer"),h.setPath(c.path),h.setRequestHeader(c.requestHeader),h.load(e,(function(n){try{const e=n.slice(0),o=Ac.getContext();o.decodeAudioData(e,(function(e){t(e)}))}catch(h){o?o(h):console.error(h),c.manager.itemError(e)}}),n,o)}}),HemisphereLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{constructor:HemisphereLightProbe,isHemisphereLightProbe:!0,copy:function(e){return LightProbe.prototype.copy.call(this,e),this},toJSON:function(e){const t=LightProbe.prototype.toJSON.call(this,e);return t}}),AmbientLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{constructor:AmbientLightProbe,isAmbientLightProbe:!0,copy:function(e){return LightProbe.prototype.copy.call(this,e),this},toJSON:function(e){const t=LightProbe.prototype.toJSON.call(this,e);return t}});const Cc=new Matrix4,Pc=new Matrix4;function StereoCamera(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(StereoCamera.prototype,{update:function(e){const t=this._cache,n=t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep;if(n){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),o=t.eyeSep/2,c=o*t.near/t.focus,h=t.near*Math.tan(qn.DEG2RAD*t.fov*.5)/t.zoom;let d,p;Pc.elements[12]=-o,Cc.elements[12]=o,d=-h*t.aspect+c,p=h*t.aspect+c,n.elements[0]=2*t.near/(p-d),n.elements[8]=(p+d)/(p-d),this.cameraL.projectionMatrix.copy(n),d=-h*t.aspect-c,p=h*t.aspect-c,n.elements[0]=2*t.near/(p-d),n.elements[8]=(p+d)/(p-d),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Pc),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Cc)}});class Clock{constructor(e){this.autoStart=void 0===e||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"===typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=("undefined"===typeof performance?Date:performance).now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}const Rc=new Vector3,Bc=new Quaternion,Dc=new Vector3,Gc=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=Ac.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Rc,Bc,Dc),Gc.set(0,0,-1).applyQuaternion(Bc),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Rc.x,e),t.positionY.linearRampToValueAtTime(Rc.y,e),t.positionZ.linearRampToValueAtTime(Rc.z,e),t.forwardX.linearRampToValueAtTime(Gc.x,e),t.forwardY.linearRampToValueAtTime(Gc.y,e),t.forwardZ.linearRampToValueAtTime(Gc.z,e),t.upX.linearRampToValueAtTime(n.x,e),t.upY.linearRampToValueAtTime(n.y,e),t.upZ.linearRampToValueAtTime(n.z,e)}else t.setPosition(Rc.x,Rc.y,Rc.z),t.setOrientation(Gc.x,Gc.y,Gc.z,n.x,n.y,n.z)}}class Audio extends Object3D{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e){if(void 0===e&&(e=0),!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e,this.connect()):this.filters=e,this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Ic=new Vector3,Oc=new Quaternion,Vc=new Vector3,Nc=new Vector3;class PositionalAudio extends Audio{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Ic,Oc,Vc),Nc.set(0,0,1).applyQuaternion(Oc);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Ic.x,e),t.positionY.linearRampToValueAtTime(Ic.y,e),t.positionZ.linearRampToValueAtTime(Ic.z,e),t.orientationX.linearRampToValueAtTime(Nc.x,e),t.orientationY.linearRampToValueAtTime(Nc.y,e),t.orientationZ.linearRampToValueAtTime(Nc.z,e)}else t.setPosition(Ic.x,Ic.y,Ic.z),t.setOrientation(Nc.x,Nc.y,Nc.z)}}class AudioAnalyser{constructor(e,t){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=void 0!==t?t:2048,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}function PropertyMixer(e,t,n){let o,c,h;switch(this.binding=e,this.valueSize=n,t){case"quaternion":o=this._slerp,c=this._slerpAdditive,h=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":o=this._select,c=this._select,h=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:o=this._lerp,c=this._lerpAdditive,h=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=o,this._mixBufferRegionAdditive=c,this._setIdentity=h,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(PropertyMixer.prototype,{accumulate:function(e,t){const n=this.buffer,o=this.valueSize,c=e*o+o;let h=this.cumulativeWeight;if(0===h){for(let e=0;e!==o;++e)n[c+e]=n[e];h=t}else{h+=t;const e=t/h;this._mixBufferRegion(n,c,0,e,o)}this.cumulativeWeight=h},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,o=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,o,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,o=e*t+t,c=this.cumulativeWeight,h=this.cumulativeWeightAdditive,d=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,c<1){const e=t*this._origIndex;this._mixBufferRegion(n,o,e,1-c,t)}h>0&&this._mixBufferRegionAdditive(n,o,this._addIndex*t,1,t);for(let p=t,m=t+t;p!==m;++p)if(n[p]!==n[p+t]){d.setValue(n,o);break}},saveOriginalState:function(){const e=this.binding,t=this.buffer,n=this.valueSize,o=n*this._origIndex;e.getValue(t,o);for(let c=n,h=o;c!==h;++c)t[c]=t[o+c%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,o,c){if(o>=.5)for(let h=0;h!==c;++h)e[t+h]=e[n+h]},_slerp:function(e,t,n,o){Quaternion.slerpFlat(e,t,e,t,e,n,o)},_slerpAdditive:function(e,t,n,o,c){const h=this._workIndex*c;Quaternion.multiplyQuaternionsFlat(e,h,e,t,e,n),Quaternion.slerpFlat(e,t,e,t,e,h,o)},_lerp:function(e,t,n,o,c){const h=1-o;for(let d=0;d!==c;++d){const c=t+d;e[c]=e[c]*h+e[n+d]*o}},_lerpAdditive:function(e,t,n,o,c){for(let h=0;h!==c;++h){const c=t+h;e[c]=e[c]+e[n+h]*o}}});const Fc="\\[\\]\\.:\\/",Uc=new RegExp("["+Fc+"]","g"),zc="[^"+Fc+"]",Hc="[^"+Fc.replace("\\.","")+"]",kc=/((?:WC+[\/:])*)/.source.replace("WC",zc),jc=/(WCOD+)?/.source.replace("WCOD",Hc),Wc=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",zc),qc=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",zc),Xc=new RegExp("^"+kc+jc+Wc+qc+"$"),Yc=["material","materials","bones"];function Composite(e,t,n){const o=n||PropertyBinding.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,o)}function PropertyBinding(e,t,n){this.path=t,this.parsedPath=n||PropertyBinding.parseTrackName(t),this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}function AnimationObjectGroup(){this.uuid=qn.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,o=arguments.length;n!==o;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}Object.assign(Composite.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,o=this._bindings[n];void 0!==o&&o.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let o=this._targetGroup.nCachedObjects_,c=n.length;o!==c;++o)n[o].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}),Object.assign(PropertyBinding,{Composite:Composite,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,t,n):new PropertyBinding(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(Uc,"")},parseTrackName:function(e){const t=Xc.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},o=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){const e=n.nodeName.substring(o+1);-1!==Yc.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,o),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const searchNodeSubtree=function(e){for(let n=0;n<e.length;n++){const o=e[n];if(o.name===t||o.uuid===t)return o;const c=searchNodeSubtree(o.children);if(c)return c}return null},n=searchNodeSubtree(e.children);if(n)return n}return null}}),Object.assign(PropertyBinding.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(e,t){e[t]=this.node[this.propertyName]},function getValue_array(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)e[t++]=n[o]},function getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]},function setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_array(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++]},function setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++];this.targetObject.needsUpdate=!0},function setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let o=0,c=n.length;o!==c;++o)n[o]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)},function setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function getValue_unbound(e,t){this.bind(),this.getValue(e,t)},setValue:function getValue_unbound(e,t){this.bind(),this.setValue(e,t)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,o=t.propertyName;let c=t.propertyIndex;if(e||(e=PropertyBinding.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let o=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===o){o=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==o){if(void 0===e[o])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[o]}}const h=e[o];if(void 0===h){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+o+" but it wasn't found.",e)}let d=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?d=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(d=this.Versioning.MatrixWorldNeedsUpdate);let p=this.BindingType.Direct;if(void 0!==c){if("morphTargetInfluences"===o){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[c]&&(c=e.morphTargetDictionary[c])}p=this.BindingType.ArrayElement,this.resolvedProperty=h,this.propertyIndex=c}else void 0!==h.fromArray&&void 0!==h.toArray?(p=this.BindingType.HasFromToArray,this.resolvedProperty=h):Array.isArray(h)?(p=this.BindingType.EntireArray,this.resolvedProperty=h):this.propertyName=o;this.getValue=this.GetterByBindingType[p],this.setValue=this.SetterByBindingTypeAndVersioning[p][d]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(PropertyBinding.prototype,{_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue}),Object.assign(AnimationObjectGroup.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,o=this._parsedPaths,c=this._bindings,h=c.length;let d=void 0,p=e.length,m=this.nCachedObjects_;for(let g=0,y=arguments.length;g!==y;++g){const y=arguments[g],x=y.uuid;let b=t[x];if(void 0===b){b=p++,t[x]=b,e.push(y);for(let e=0,t=h;e!==t;++e)c[e].push(new PropertyBinding(y,n[e],o[e]))}else if(b<m){d=e[b];const p=--m,g=e[p];t[g.uuid]=b,e[b]=g,t[x]=p,e[p]=y;for(let e=0,t=h;e!==t;++e){const t=c[e],h=t[p];let d=t[b];t[b]=h,void 0===d&&(d=new PropertyBinding(y,n[e],o[e])),t[p]=d}}else e[b]!==d&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=m},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let c=this.nCachedObjects_;for(let h=0,d=arguments.length;h!==d;++h){const d=arguments[h],p=d.uuid,m=t[p];if(void 0!==m&&m>=c){const h=c++,g=e[h];t[g.uuid]=m,e[m]=g,t[p]=h,e[h]=d;for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[h],c=t[m];t[m]=o,t[h]=c}}}this.nCachedObjects_=c},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,o=n.length;let c=this.nCachedObjects_,h=e.length;for(let d=0,p=arguments.length;d!==p;++d){const p=arguments[d],m=p.uuid,g=t[m];if(void 0!==g)if(delete t[m],g<c){const d=--c,p=e[d],m=--h,y=e[m];t[p.uuid]=g,e[g]=p,t[y.uuid]=d,e[d]=y,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e],o=t[d],c=t[m];t[g]=o,t[d]=c,t.pop()}}else{const c=--h,d=e[c];t[d.uuid]=g,e[g]=d,e.pop();for(let e=0,t=o;e!==t;++e){const t=n[e];t[g]=t[c],t.pop()}}}this.nCachedObjects_=c},subscribe_:function(e,t){const n=this._bindingsIndicesByPath;let o=n[e];const c=this._bindings;if(void 0!==o)return c[o];const h=this._paths,d=this._parsedPaths,p=this._objects,m=p.length,g=this.nCachedObjects_,y=new Array(m);o=c.length,n[e]=o,h.push(e),d.push(t),c.push(y);for(let x=g,b=p.length;x!==b;++x){const n=p[x];y[x]=new PropertyBinding(n,e,t)}return y},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const o=this._paths,c=this._parsedPaths,h=this._bindings,d=h.length-1,p=h[d],m=e[d];t[m]=n,h[n]=p,h.pop(),c[n]=c[d],c.pop(),o[n]=o[d],o.pop()}}});class AnimationAction{constructor(e,t,n,o){this._mixer=e,this._clip=t,this._localRoot=n||null,this.blendMode=o||t.blendMode;const c=t.tracks,h=c.length,d=new Array(h),p={endingStart:Jt,endingEnd:Jt};for(let m=0;m!==h;++m){const e=c[m].createInterpolant(null);d[m]=e,e.settings=p}this._interpolantSettings=p,this._interpolants=d,this._propertyBindings=new Array(h),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Wt,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,o=e._clip.duration,c=o/n,h=n/o;e.warp(1,c,t),this.warp(h,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const o=this._mixer,c=o.time,h=this.timeScale;let d=this._timeScaleInterpolant;null===d&&(d=o._lendControlInterpolant(),this._timeScaleInterpolant=d);const p=d.parameterPositions,m=d.sampleValues;return p[0]=c,p[1]=c+n,m[0]=e/h,m[1]=t/h,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,o){if(!this.enabled)return void this._updateWeight(e);const c=this._startTime;if(null!==c){const o=(e-c)*n;if(o<0||0===n)return;this._startTime=null,t=n*o}t*=this._updateTimeScale(e);const h=this._updateTime(t),d=this._updateWeight(e);if(d>0){const e=this._interpolants,t=this._propertyBindings;switch(this.blendMode){case en:for(let n=0,o=e.length;n!==o;++n)e[n].evaluate(h),t[n].accumulateAdditive(d);break;case $t:default:for(let n=0,c=e.length;n!==c;++n)e[n].evaluate(h),t[n].accumulate(o,d)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const o=n.evaluate(e)[0];t*=o,e>n.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){const o=n.evaluate(e)[0];t*=o,e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let o=this.time+e,c=this._loopCount;const h=n===qt;if(0===e)return-1===c?o:h&&1===(1&c)?t-o:o;if(n===jt){-1===c&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(o>=t)o=t;else{if(!(o<0)){this.time=o;break e}o=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===c&&(e>=0?(c=0,this._setEndings(!0,0===this.repetitions,h)):this._setEndings(0===this.repetitions,!0,h)),o>=t||o<0){const n=Math.floor(o/t);o-=t*n,c+=Math.abs(n);const d=this.repetitions-c;if(d<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,o=e>0?t:0,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===d){const t=e<0;this._setEndings(t,!t,h)}else this._setEndings(!1,!1,h);this._loopCount=c,this.time=o,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=o;if(h&&1===(1&c))return t-o}return o}_setEndings(e,t,n){const o=this._interpolantSettings;n?(o.endingStart=Qt,o.endingEnd=Qt):(o.endingStart=e?this.zeroSlopeAtStart?Qt:Jt:Kt,o.endingEnd=t?this.zeroSlopeAtEnd?Qt:Jt:Kt)}_scheduleFading(e,t,n){const o=this._mixer,c=o.time;let h=this._weightInterpolant;null===h&&(h=o._lendControlInterpolant(),this._weightInterpolant=h);const d=h.parameterPositions,p=h.sampleValues;return d[0]=c,p[0]=t,d[1]=c+e,p[1]=n,this}}function AnimationMixer(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}AnimationMixer.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:AnimationMixer,_bindAction:function(e,t){const n=e._localRoot||this._root,o=e._clip.tracks,c=o.length,h=e._propertyBindings,d=e._interpolants,p=n.uuid,m=this._bindingsByRootAndName;let g=m[p];void 0===g&&(g={},m[p]=g);for(let y=0;y!==c;++y){const e=o[y],c=e.name;let m=g[c];if(void 0!==m)h[y]=m;else{if(m=h[y],void 0!==m){null===m._cacheIndex&&(++m.referenceCount,this._addInactiveBinding(m,p,c));continue}const o=t&&t._propertyBindings[y].binding.parsedPath;m=new PropertyMixer(PropertyBinding.create(n,c,o),e.ValueTypeName,e.getValueSize()),++m.referenceCount,this._addInactiveBinding(m,p,c),h[y]=m}d[y].resultBuffer=m.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,o=this._actionsByClip[n];this._bindAction(e,o&&o.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0===n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0===--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const o=this._actions,c=this._actionsByClip;let h=c[t];if(void 0===h)h={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,c[t]=h;else{const t=h.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=o.length,o.push(e),h.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],o=e._cacheIndex;n._cacheIndex=o,t[o]=n,t.pop(),e._cacheIndex=null;const c=e._clip.uuid,h=this._actionsByClip,d=h[c],p=d.knownActions,m=p[p.length-1],g=e._byClipCacheIndex;m._byClipCacheIndex=g,p[g]=m,p.pop(),e._byClipCacheIndex=null;const y=d.actionByRoot,x=(e._localRoot||this._root).uuid;delete y[x],0===p.length&&delete h[c],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let n=0,o=t.length;n!==o;++n){const e=t[n];0===--e.referenceCount&&this._removeInactiveBinding(e)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,o=this._nActiveActions++,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,o=--this._nActiveActions,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_addInactiveBinding:function(e,t,n){const o=this._bindingsByRootAndName,c=this._bindings;let h=o[t];void 0===h&&(h={},o[t]=h),h[n]=e,e._cacheIndex=c.length,c.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,o=n.rootNode.uuid,c=n.path,h=this._bindingsByRootAndName,d=h[o],p=t[t.length-1],m=e._cacheIndex;p._cacheIndex=m,t[m]=p,t.pop(),delete d[c],0===Object.keys(d).length&&delete h[o]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,o=this._nActiveBindings++,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,o=--this._nActiveBindings,c=t[o];e._cacheIndex=o,t[o]=e,c._cacheIndex=n,t[n]=c},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,o=--this._nActiveControlInterpolants,c=t[o];e.__cacheIndex=o,t[o]=e,c.__cacheIndex=n,t[n]=c},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const o=t||this._root,c=o.uuid;let h="string"===typeof e?AnimationClip.findByName(o,e):e;const d=null!==h?h.uuid:e,p=this._actionsByClip[d];let m=null;if(void 0===n&&(n=null!==h?h.blendMode:$t),void 0!==p){const e=p.actionByRoot[c];if(void 0!==e&&e.blendMode===n)return e;m=p.knownActions[0],null===h&&(h=m._clip)}if(null===h)return null;const g=new AnimationAction(this,h,t,n);return this._bindAction(g,m),this._addInactiveAction(g,d,c),g},existingAction:function(e,t){const n=t||this._root,o=n.uuid,c="string"===typeof e?AnimationClip.findByName(n,e):e,h=c?c.uuid:e,d=this._actionsByClip[h];return void 0!==d&&d.actionByRoot[o]||null},stopAllAction:function(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this},update:function(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,o=this.time+=e,c=Math.sign(e),h=this._accuIndex^=1;for(let m=0;m!==n;++m){const n=t[m];n._update(o,e,c,h)}const d=this._bindings,p=this._nActiveBindings;for(let m=0;m!==p;++m)d[m].apply(h);return this},setTime:function(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,o=this._actionsByClip,c=o[n];if(void 0!==c){const e=c.knownActions;for(let n=0,o=e.length;n!==o;++n){const o=e[n];this._deactivateAction(o);const c=o._cacheIndex,h=t[t.length-1];o._cacheIndex=null,o._byClipCacheIndex=null,h._cacheIndex=c,t[c]=h,t.pop(),this._removeInactiveBindingsForAction(o)}delete o[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const h in n){const e=n[h].actionByRoot,o=e[t];void 0!==o&&(this._deactivateAction(o),this._removeInactiveAction(o))}const o=this._bindingsByRootAndName,c=o[t];if(void 0!==c)for(const h in c){const e=c[h];e.restoreOriginalState(),this._removeInactiveBinding(e)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}});class Uniform{constructor(e){"string"===typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())}}function InstancedInterleavedBuffer(e,t,n){InterleavedBuffer.call(this,e,t),this.meshPerAttribute=n||1}function GLBufferAttribute(e,t,n,o,c){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=o,this.count=c,this.version=0}function Raycaster(e,t,n,o){this.ray=new Ray(e,t),this.near=n||0,this.far=o||1/0,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function ascSort(e,t){return e.distance-t.distance}function intersectObject(e,t,n,o){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===o){const o=e.children;for(let e=0,c=o.length;e<c;e++)intersectObject(o[e],t,n,!0)}}InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:!0,copy:function(e){return InterleavedBuffer.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=InterleavedBuffer.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=InterleavedBuffer.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.defineProperty(GLBufferAttribute.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(GLBufferAttribute.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}}),Object.assign(Raycaster.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(e,t,n){const o=n||[];return intersectObject(e,this,o,t),o.sort(ascSort),o},intersectObjects:function(e,t,n){const o=n||[];if(!1===Array.isArray(e))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),o;for(let c=0,h=e.length;c<h;c++)intersectObject(e[c],this,o,t);return o.sort(ascSort),o}});class Spherical{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}clone(){return(new this.constructor).copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(qn.clamp(t/this.radius,-1,1))),this}}class Cylindrical{constructor(e,t,n){return this.radius=void 0!==e?e:1,this.theta=void 0!==t?t:0,this.y=void 0!==n?n:0,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}clone(){return(new this.constructor).copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}}const Zc=new Vector2;class Box2{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=void 0!==e?e:new Vector2(1/0,1/0),this.max=void 0!==t?t:new Vector2(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Zc.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new Vector2),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new Vector2),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new Vector2),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new Vector2),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){const t=Zc.copy(e).clamp(this.min,this.max);return t.sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Jc=new Vector3,Qc=new Vector3;class Line3{constructor(e,t){this.start=void 0!==e?e:new Vector3,this.end=void 0!==t?t:new Vector3}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Vector3),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Vector3),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new Vector3),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Jc.subVectors(e,this.start),Qc.subVectors(this.end,this.start);const n=Qc.dot(Qc),o=Qc.dot(Jc);let c=o/n;return t&&(c=qn.clamp(c,0,1)),c}closestPointToPoint(e,t,n){const o=this.closestPointToPointParameter(e,t);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new Vector3),this.delta(n).multiplyScalar(o).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function ImmediateRenderObject(e){Object3D.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}ImmediateRenderObject.prototype=Object.create(Object3D.prototype),ImmediateRenderObject.prototype.constructor=ImmediateRenderObject,ImmediateRenderObject.prototype.isImmediateRenderObject=!0;const Kc=new Vector3;class SpotLightHelper extends Object3D{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new BufferGeometry,o=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let h=0,d=1,p=32;h<p;h++,d++){const e=h/p*Math.PI*2,t=d/p*Math.PI*2;o.push(Math.cos(e),Math.sin(e),1,Math.cos(t),Math.sin(t),1)}n.setAttribute("position",new Float32BufferAttribute(o,3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(n,c),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Kc.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Kc),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const $c=new Vector3,el=new Matrix4,tl=new Matrix4;class SkeletonHelper extends LineSegments{constructor(e){const t=getBoneList(e),n=new BufferGeometry,o=[],c=[],h=new Color(0,0,1),d=new Color(0,1,0);for(let m=0;m<t.length;m++){const e=t[m];e.parent&&e.parent.isBone&&(o.push(0,0,0),o.push(0,0,0),c.push(h.r,h.g,h.b),c.push(d.r,d.g,d.b))}n.setAttribute("position",new Float32BufferAttribute(o,3)),n.setAttribute("color",new Float32BufferAttribute(c,3));const p=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,p),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,o=n.getAttribute("position");tl.getInverse(this.root.matrixWorld);for(let c=0,h=0;c<t.length;c++){const e=t[c];e.parent&&e.parent.isBone&&(el.multiplyMatrices(tl,e.matrixWorld),$c.setFromMatrixPosition(el),o.setXYZ(h,$c.x,$c.y,$c.z),el.multiplyMatrices(tl,e.parent.matrixWorld),$c.setFromMatrixPosition(el),o.setXYZ(h+1,$c.x,$c.y,$c.z),h+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function getBoneList(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,getBoneList(e.children[n]));return t}class PointLightHelper extends Mesh{constructor(e,t,n){const o=new SphereBufferGeometry(t,4,2),c=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(o,c),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const nl=new Vector3,rl=new Color,il=new Color;class HemisphereLightHelper extends Object3D{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const o=new OctahedronBufferGeometry(t);o.rotateY(.5*Math.PI),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const c=o.getAttribute("position"),h=new Float32Array(3*c.count);o.setAttribute("color",new BufferAttribute(h,3)),this.add(new Mesh(o,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");rl.copy(this.light.color),il.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const o=e<n/2?rl:il;t.setXYZ(e,o.r,o.g,o.b)}t.needsUpdate=!0}e.lookAt(nl.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(e,t,n,o){e=e||10,t=t||10,n=new Color(void 0!==n?n:4473924),o=new Color(void 0!==o?o:8947848);const c=t/2,h=e/t,d=e/2,p=[],m=[];for(let x=0,b=0,M=-d;x<=t;x++,M+=h){p.push(-d,0,M,d,0,M),p.push(M,0,-d,M,0,d);const e=x===c?n:o;e.toArray(m,b),b+=3,e.toArray(m,b),b+=3,e.toArray(m,b),b+=3,e.toArray(m,b),b+=3}const g=new BufferGeometry;g.setAttribute("position",new Float32BufferAttribute(p,3)),g.setAttribute("color",new Float32BufferAttribute(m,3));const y=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(g,y),this.type="GridHelper"}}class PolarGridHelper extends LineSegments{constructor(e,t,n,o,c,h){e=e||10,t=t||16,n=n||8,o=o||64,c=new Color(void 0!==c?c:4473924),h=new Color(void 0!==h?h:8947848);const d=[],p=[];for(let y=0;y<=t;y++){const n=y/t*(2*Math.PI),o=Math.sin(n)*e,m=Math.cos(n)*e;d.push(0,0,0),d.push(o,0,m);const g=1&y?c:h;p.push(g.r,g.g,g.b),p.push(g.r,g.g,g.b)}for(let y=0;y<=n;y++){const t=1&y?c:h,m=e-e/n*y;for(let e=0;e<o;e++){let n=e/o*(2*Math.PI),c=Math.sin(n)*m,h=Math.cos(n)*m;d.push(c,0,h),p.push(t.r,t.g,t.b),n=(e+1)/o*(2*Math.PI),c=Math.sin(n)*m,h=Math.cos(n)*m,d.push(c,0,h),p.push(t.r,t.g,t.b)}}const m=new BufferGeometry;m.setAttribute("position",new Float32BufferAttribute(d,3)),m.setAttribute("color",new Float32BufferAttribute(p,3));const g=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(m,g),this.type="PolarGridHelper"}}const ol=new Vector3,al=new Vector3,sl=new Vector3;class DirectionalLightHelper extends Object3D{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===t&&(t=1);let o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const c=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(o,c),this.add(this.lightPlane),o=new BufferGeometry,o.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(o,c),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){ol.setFromMatrixPosition(this.light.matrixWorld),al.setFromMatrixPosition(this.light.target.matrixWorld),sl.subVectors(al,ol),this.lightPlane.lookAt(al),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(al),this.targetLine.scale.z=sl.length()}}const cl=new Vector3,ll=new Camera;class CameraHelper extends LineSegments{constructor(e){const t=new BufferGeometry,n=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),o=[],c=[],h={},d=new Color(16755200),p=new Color(16711680),m=new Color(43775),g=new Color(16777215),y=new Color(3355443);function addLine(e,t,n){addPoint(e,n),addPoint(t,n)}function addPoint(e,t){o.push(0,0,0),c.push(t.r,t.g,t.b),void 0===h[e]&&(h[e]=[]),h[e].push(o.length/3-1)}addLine("n1","n2",d),addLine("n2","n4",d),addLine("n4","n3",d),addLine("n3","n1",d),addLine("f1","f2",d),addLine("f2","f4",d),addLine("f4","f3",d),addLine("f3","f1",d),addLine("n1","f1",d),addLine("n2","f2",d),addLine("n3","f3",d),addLine("n4","f4",d),addLine("p","n1",p),addLine("p","n2",p),addLine("p","n3",p),addLine("p","n4",p),addLine("u1","u2",m),addLine("u2","u3",m),addLine("u3","u1",m),addLine("c","t",g),addLine("p","c",y),addLine("cn1","cn2",y),addLine("cn3","cn4",y),addLine("cf1","cf2",y),addLine("cf3","cf4",y),t.setAttribute("position",new Float32BufferAttribute(o,3)),t.setAttribute("color",new Float32BufferAttribute(c,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=h,this.update()}update(){const e=this.geometry,t=this.pointMap,n=1,o=1;ll.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",t,e,ll,0,0,-1),setPoint("t",t,e,ll,0,0,1),setPoint("n1",t,e,ll,-n,-o,-1),setPoint("n2",t,e,ll,n,-o,-1),setPoint("n3",t,e,ll,-n,o,-1),setPoint("n4",t,e,ll,n,o,-1),setPoint("f1",t,e,ll,-n,-o,1),setPoint("f2",t,e,ll,n,-o,1),setPoint("f3",t,e,ll,-n,o,1),setPoint("f4",t,e,ll,n,o,1),setPoint("u1",t,e,ll,.7*n,1.1*o,-1),setPoint("u2",t,e,ll,.7*-n,1.1*o,-1),setPoint("u3",t,e,ll,0,2*o,-1),setPoint("cf1",t,e,ll,-n,0,1),setPoint("cf2",t,e,ll,n,0,1),setPoint("cf3",t,e,ll,0,-o,1),setPoint("cf4",t,e,ll,0,o,1),setPoint("cn1",t,e,ll,-n,0,-1),setPoint("cn2",t,e,ll,n,0,-1),setPoint("cn3",t,e,ll,0,-o,-1),setPoint("cn4",t,e,ll,0,o,-1),e.getAttribute("position").needsUpdate=!0}}function setPoint(e,t,n,o,c,h,d){cl.set(c,h,d).unproject(o);const p=t[e];if(void 0!==p){const e=n.getAttribute("position");for(let t=0,n=p.length;t<n;t++)e.setXYZ(p[t],cl.x,cl.y,cl.z)}}const ul=new Box3;class BoxHelper extends LineSegments{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=new Float32Array(24),c=new BufferGeometry;c.setIndex(new BufferAttribute(n,1)),c.setAttribute("position",new BufferAttribute(o,3)),super(c,new LineBasicMaterial({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&ul.setFromObject(this.object),ul.isEmpty())return;const t=ul.min,n=ul.max,o=this.geometry.attributes.position,c=o.array;c[0]=n.x,c[1]=n.y,c[2]=n.z,c[3]=t.x,c[4]=n.y,c[5]=n.z,c[6]=t.x,c[7]=t.y,c[8]=n.z,c[9]=n.x,c[10]=t.y,c[11]=n.z,c[12]=n.x,c[13]=n.y,c[14]=t.z,c[15]=t.x,c[16]=n.y,c[17]=t.z,c[18]=t.x,c[19]=t.y,c[20]=t.z,c[21]=n.x,c[22]=t.y,c[23]=t.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return LineSegments.prototype.copy.call(this,e),this.object=e.object,this}}class Box3Helper extends LineSegments{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),o=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],c=new BufferGeometry;c.setIndex(new BufferAttribute(n,1)),c.setAttribute("position",new Float32BufferAttribute(o,3)),super(c,new LineBasicMaterial({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class PlaneHelper extends Line{constructor(e,t,n){const o=void 0!==n?n:16776960,c=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],h=new BufferGeometry;h.setAttribute("position",new Float32BufferAttribute(c,3)),h.computeBoundingSphere(),super(h,new LineBasicMaterial({color:o,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=void 0===t?1:t;const d=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],p=new BufferGeometry;p.setAttribute("position",new Float32BufferAttribute(d,3)),p.computeBoundingSphere(),this.add(new Mesh(p,new MeshBasicMaterial({color:o,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?w:_,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const hl=new Vector3;let dl,pl;class ArrowHelper extends Object3D{constructor(e,t,n,o,c,h){super(),this.type="ArrowHelper",void 0===e&&(e=new Vector3(0,0,1)),void 0===t&&(t=new Vector3(0,0,0)),void 0===n&&(n=1),void 0===o&&(o=16776960),void 0===c&&(c=.2*n),void 0===h&&(h=.2*c),void 0===dl&&(dl=new BufferGeometry,dl.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),pl=new CylinderBufferGeometry(0,.5,1,5,1),pl.translate(0,-.5,0)),this.position.copy(t),this.line=new Line(dl,new LineBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(pl,new MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,c,h)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{hl.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(hl,t)}}setLength(e,t,n){void 0===t&&(t=.2*e),void 0===n&&(n=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class AxesHelper extends LineSegments{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],o=new BufferGeometry;o.setAttribute("position",new Float32BufferAttribute(t,3)),o.setAttribute("color",new Float32BufferAttribute(n,3));const c=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(o,c),this.type="AxesHelper"}}const fl=4,ml=8,gl=Math.pow(2,ml),yl=[.125,.215,.35,.446,.526,.582],vl=ml-fl+1+yl.length,xl=20,bl={[on]:0,[an]:1,[cn]:2,[un]:3,[hn]:4,[dn]:5,[sn]:6},Ml=new OrthographicCamera,{_lodPlanes:_l,_sizeLods:wl,_sigmas:Sl}=_createPlanes();let Tl=null;const El=(1+Math.sqrt(5))/2,Ll=1/El,Al=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,El,Ll),new Vector3(0,El,-Ll),new Vector3(Ll,0,El),new Vector3(-Ll,0,El),new Vector3(El,Ll,0),new Vector3(-El,Ll,0)];class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=_getBlurShader(xl),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,o=100){Tl=this._renderer.getRenderTarget();const c=this._allocateTargets();return this._sceneToCubeUV(e,n,o,c),t>0&&this._blur(c,0,0,t),this._applyPMREM(c),this._cleanup(c),c}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=_getCubemapShader(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=_getEquirectShader(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let e=0;e<_l.length;e++)_l[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Tl),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e){Tl=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:_e,minFilter:_e,generateMipmaps:!1,type:Be,format:Ze,encoding:_isLDR(e)?e.encoding:cn,depthBuffer:!1},n=_createRenderTarget(t);return n.depthBuffer=!e,this._pingPongRenderTarget=_createRenderTarget(t),n}_compileMaterial(e){const t=new Mesh(_l[0],e);this._renderer.compile(t,Ml)}_sceneToCubeUV(e,t,n,o){const c=90,h=1,d=new PerspectiveCamera(c,h,t,n),p=[1,-1,1,1,1,1],m=[1,1,1,-1,-1,-1],g=this._renderer,y=g.outputEncoding,x=g.toneMapping,b=g.getClearColor(),M=g.getClearAlpha();g.toneMapping=ae,g.outputEncoding=on;let _=e.background;if(_&&_.isColor){_.convertSRGBToLinear();const t=Math.max(_.r,_.g,_.b),n=Math.min(Math.max(Math.ceil(Math.log2(t)),-128),127);_=_.multiplyScalar(Math.pow(2,-n));const o=(n+128)/255;g.setClearColor(_,o),e.background=null}for(let w=0;w<6;w++){const t=w%3;0==t?(d.up.set(0,p[w],0),d.lookAt(m[w],0,0)):1==t?(d.up.set(0,0,p[w]),d.lookAt(0,m[w],0)):(d.up.set(0,p[w],0),d.lookAt(0,0,m[w])),_setViewport(o,t*gl,w>2?gl:0,gl,gl),g.setRenderTarget(o),g.render(e,d)}g.toneMapping=x,g.outputEncoding=y,g.setClearColor(b,M)}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=_getCubemapShader()):null==this._equirectShader&&(this._equirectShader=_getEquirectShader());const o=e.isCubeTexture?this._cubemapShader:this._equirectShader,c=new Mesh(_l[0],o),h=o.uniforms;h["envMap"].value=e,e.isCubeTexture||h["texelSize"].value.set(1/e.image.width,1/e.image.height),h["inputEncoding"].value=bl[e.encoding],h["outputEncoding"].value=bl[t.texture.encoding],_setViewport(t,0,0,3*gl,2*gl),n.setRenderTarget(t),n.render(c,Ml)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let o=1;o<vl;o++){const t=Math.sqrt(Sl[o]*Sl[o]-Sl[o-1]*Sl[o-1]),n=Al[(o-1)%Al.length];this._blur(e,o-1,o,t,n)}t.autoClear=n}_blur(e,t,n,o,c){const h=this._pingPongRenderTarget;this._halfBlur(e,h,t,n,o,"latitudinal",c),this._halfBlur(h,e,n,n,o,"longitudinal",c)}_halfBlur(e,t,n,o,c,h,d){const p=this._renderer,m=this._blurMaterial;"latitudinal"!==h&&"longitudinal"!==h&&console.error("blur direction must be either latitudinal or longitudinal!");const g=3,y=new Mesh(_l[o],m),x=m.uniforms,b=wl[n]-1,M=isFinite(c)?Math.PI/(2*b):2*Math.PI/(2*xl-1),_=c/M,w=isFinite(c)?1+Math.floor(g*_):xl;w>xl&&console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${w} samples when the maximum is set to ${xl}`);const S=[];let T=0;for(let C=0;C<xl;++C){const e=C/_,t=Math.exp(-e*e/2);S.push(t),0==C?T+=t:C<w&&(T+=2*t)}for(let C=0;C<S.length;C++)S[C]=S[C]/T;x["envMap"].value=e.texture,x["samples"].value=w,x["weights"].value=S,x["latitudinal"].value="latitudinal"===h,d&&(x["poleAxis"].value=d),x["dTheta"].value=M,x["mipInt"].value=ml-n,x["inputEncoding"].value=bl[e.texture.encoding],x["outputEncoding"].value=bl[e.texture.encoding];const E=wl[o],L=3*Math.max(0,gl-2*E),A=(0===o?0:2*gl)+2*E*(o>ml-fl?o-ml+fl:0);_setViewport(t,L,A,3*E,2*E),p.setRenderTarget(t),p.render(y,Ml)}}function _isLDR(e){return void 0!==e&&e.type===Be&&(e.encoding===on||e.encoding===an||e.encoding===sn)}function _createPlanes(){const e=[],t=[],n=[];let o=ml;for(let c=0;c<vl;c++){const h=Math.pow(2,o);t.push(h);let d=1/h;c>ml-fl?d=yl[c-ml+fl-1]:0==c&&(d=0),n.push(d);const p=1/(h-1),m=-p/2,g=1+p/2,y=[m,m,g,m,g,g,m,m,g,g,m,g],x=6,b=6,M=3,_=2,w=1,S=new Float32Array(M*b*x),T=new Float32Array(_*b*x),E=new Float32Array(w*b*x);for(let e=0;e<x;e++){const t=e%3*2/3-1,n=e>2?0:-1,o=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];S.set(o,M*b*e),T.set(y,_*b*e);const c=[e,e,e,e,e,e];E.set(c,w*b*e)}const L=new BufferGeometry;L.setAttribute("position",new BufferAttribute(S,M)),L.setAttribute("uv",new BufferAttribute(T,_)),L.setAttribute("faceIndex",new BufferAttribute(E,w)),e.push(L),o>fl&&o--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function _createRenderTarget(e){const t=new WebGLRenderTarget(3*gl,3*gl,e);return t.texture.mapping=ye,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function _setViewport(e,t,n,o,c){e.viewport.set(t,n,o,c),e.scissor.set(t,n,o,c)}function _getBlurShader(e){const t=new Float32Array(e),n=new Vector3(0,1,0),o=new RawShaderMaterial({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:bl[on]},outputEncoding:{value:bl[on]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:L,depthTest:!1,depthWrite:!1});return o}function _getEquirectShader(){const e=new Vector2(1,1),t=new RawShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:bl[on]},outputEncoding:{value:bl[on]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:L,depthTest:!1,depthWrite:!1});return t}function _getCubemapShader(){const e=new RawShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:bl[on]},outputEncoding:{value:bl[on]}},vertexShader:_getCommonVertexShader(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:L,depthTest:!1,depthWrite:!1});return e}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function _getEncodings(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}function Face4(e,t,n,o,c,h,d){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Face3(e,t,n,c,h,d)}const Cl=0,Pl=1,Rl=0,Bl=1,Dl=2;function MeshFaceMaterial(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function MultiMaterial(e){return void 0===e&&(e=[]),console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function PointCloud(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new Points(e,t)}function Particle(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Sprite(e)}function ParticleSystem(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new Points(e,t)}function PointCloudMaterial(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function ParticleBasicMaterial(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function ParticleSystemMaterial(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new PointsMaterial(e)}function Vertex(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Vector3(e,t,n)}function DynamicBufferAttribute(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new BufferAttribute(e,t).setUsage(Gn)}function Int8Attribute(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Int8BufferAttribute(e,t)}function Uint8Attribute(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Uint8BufferAttribute(e,t)}function Uint8ClampedAttribute(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Uint8ClampedBufferAttribute(e,t)}function Int16Attribute(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Int16BufferAttribute(e,t)}function Uint16Attribute(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Uint16BufferAttribute(e,t)}function Int32Attribute(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new Int32BufferAttribute(e,t)}function Uint32Attribute(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Uint32BufferAttribute(e,t)}function Float32Attribute(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Float32BufferAttribute(e,t)}function Float64Attribute(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new Float64BufferAttribute(e,t)}function ClosedSplineCurve3(e){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom",this.closed=!0}function SplineCurve3(e){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom"}function Spline(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),CatmullRomCurve3.call(this,e),this.type="catmullrom"}function AxisHelper(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new AxesHelper(e)}function BoundingBoxHelper(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new BoxHelper(e,t)}function EdgesHelper(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new LineSegments(new EdgesGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}function WireframeHelper(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new LineSegments(new WireframeGeometry(e.geometry),new LineBasicMaterial({color:void 0!==t?t:16777215}))}function XHRLoader(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new FileLoader(e)}function BinaryTextureLoader(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new DataTextureLoader(e)}function WebGLRenderTargetCube(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new WebGLCubeRenderTarget(e,n)}Curve.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Curve.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(CurvePath.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=new Geometry;for(let n=0,o=e.length;n<o;n++){const o=e[n];t.vertices.push(new Vector3(o.x,o.y,o.z||0))}return t}}),Object.assign(Path.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),ClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype),SplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype),Spline.prototype=Object.create(CatmullRomCurve3.prototype),Object.assign(Spline.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),GridHelper.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},SkeletonHelper.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(Loader.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),_c.extractUrlBase(e)}}),Loader.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(ObjectLoader.prototype,{setTexturePath:function(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}),Object.assign(Box2.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Box3.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(Sphere.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Frustum.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},Line3.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(qn,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),qn.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),qn.ceilPowerOfTwo(e)}}),Object.assign(Matrix3.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}}),Object.assign(Matrix4.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new Vector3).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,o,c,h){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,o,n,c,h)}}),Plane.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},Quaternion.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},Object.assign(Ray.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(Triangle.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(Triangle,{barycoordFromPoint:function(e,t,n,o,c){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Triangle.getBarycoord(e,t,n,o,c)},normal:function(e,t,n,o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Triangle.getNormal(e,t,n,o)}}),Object.assign(Shape.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new ExtrudeGeometry(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ShapeGeometry(this,e)}}),Object.assign(Vector2.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Vector3.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Vector4.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Geometry.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(Object3D.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Mesh.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Mesh.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),tn},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(LOD.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(Skeleton.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),SkinnedMesh.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(Curve.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),PerspectiveCamera.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Gn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Gn)}}}),Object.assign(BufferAttribute.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Gn:Dn),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(BufferGeometry.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new BufferAttribute(arguments[1],arguments[2])))},addDrawCall:function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(InstancedBufferGeometry.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(Raycaster.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(InterleavedBuffer.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Gn},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(InterleavedBuffer.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Gn:Dn),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(ExtrudeBufferGeometry.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.assign(Scene.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(Uniform.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Color}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===T}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(MeshPhongMaterial.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(MeshPhysicalMaterial.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(WebGLRenderer.prototype,{clearTarget:function(e,t,n,o){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,o)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?an:on}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Audio.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this,n=new AudioLoader;return n.load(e,(function(e){t.setBuffer(e)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),AudioAnalyser.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},CubeCamera.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)};const Gl={merge:function(e,t,n){let o;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),o=t.matrix,t=t.geometry),e.merge(t,o,n)},center:function(e){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),e.center()}};function CanvasRenderer(){console.error("THREE.CanvasRenderer has been removed")}function JSONLoader(){console.error("THREE.JSONLoader has been removed.")}Yn.crossOrigin=void 0,Yn.loadTexture=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const c=new TextureLoader;c.setCrossOrigin(this.crossOrigin);const h=c.load(e,n,void 0,o);return t&&(h.mapping=t),h},Yn.loadTextureCube=function(e,t,n,o){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const c=new CubeTextureLoader;c.setCrossOrigin(this.crossOrigin);const h=c.load(e,n,void 0,o);return t&&(h.mapping=t),h},Yn.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Yn.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const Il={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function LensFlare(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:o}}))},"./src/plugins/Visualizer/Visualizer.vue":function(e,t,n){"use strict";n.r(t);var o=n("./src/plugins/Visualizer/Visualizer.vue?vue&type=template&id=502b953a&scoped=true&"),c=n("./src/plugins/Visualizer/Visualizer.vue?vue&type=script&lang=js&"),h=(n("./src/plugins/Visualizer/Visualizer.vue?vue&type=style&index=0&id=502b953a&scoped=true&lang=css&"),n("./node_modules/vue-loader/lib/runtime/componentNormalizer.js")),d=n("./node_modules/vuetify-loader/lib/runtime/installDirectives.js"),p=n.n(d),m=n("./node_modules/vuetify/lib/directives/resize/index.js"),g=Object(h["default"])(c["default"],o["render"],o["staticRenderFns"],!1,null,"502b953a",null);t["default"]=g.exports,p()(g,{Resize:m["default"]})},"./src/plugins/Visualizer/Visualizer.vue?vue&type=script&lang=js&":function(e,t,n){"use strict";n.r(t);var o=n("./node_modules/cache-loader/dist/cjs.js?!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=script&lang=js&");t["default"]=o["default"]},"./src/plugins/Visualizer/Visualizer.vue?vue&type=style&index=0&id=502b953a&scoped=true&lang=css&":function(e,t,n){"use strict";n.r(t);var o=n("./node_modules/mini-css-extract-plugin/dist/loader.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=style&index=0&id=502b953a&scoped=true&lang=css&"),c=n.n(o);for(var h in o)["default"].indexOf(h)<0&&function(e){n.d(t,e,(function(){return o[e]}))}(h);t["default"]=c.a},"./src/plugins/Visualizer/Visualizer.vue?vue&type=template&id=502b953a&scoped=true&":function(e,t,n){"use strict";n.r(t);var o=n('./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3e016849-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/plugins/Visualizer/Visualizer.vue?vue&type=template&id=502b953a&scoped=true&');n.d(t,"render",(function(){return o["render"]})),n.d(t,"staticRenderFns",(function(){return o["staticRenderFns"]}))},"./src/plugins/Visualizer/index.js":function(e,t,n){"use strict";n.r(t);var o=n("./src/plugins/Visualizer/Visualizer.vue"),c=n("./src/routes/index.js");Object(c["registerRoute"])(o["default"],{Job:{Visualizer:{icon:"mdi-rotate-3d",caption:"plugins.visualizer.menuCaption",path:"/Job/Visualizer"}}})}}]);
//# sourceMappingURL=Visualizer.2b94521d.js.map